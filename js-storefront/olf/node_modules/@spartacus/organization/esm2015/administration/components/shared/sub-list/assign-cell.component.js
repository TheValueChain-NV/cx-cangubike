import { ChangeDetectionStrategy, Component } from '@angular/core';
import { filter, first, switchMap, take } from 'rxjs/operators';
import { LoadStatus, } from '@spartacus/organization/administration/core';
import { CellComponent } from '../table/cell.component';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/storefront";
import * as i2 from "../item.service";
import * as i3 from "../message/services/message.service";
import * as i4 from "../list/list.service";
import * as i5 from "@angular/common";
export class AssignCellComponent extends CellComponent {
    constructor(outlet, organizationItemService, messageService, organizationSubListService) {
        super(outlet);
        this.outlet = outlet;
        this.organizationItemService = organizationItemService;
        this.messageService = messageService;
        this.organizationSubListService = organizationSubListService;
    }
    get isAssigned() {
        var _a;
        return (_a = this.item) === null || _a === void 0 ? void 0 : _a.selected;
    }
    toggleAssign() {
        const isAssigned = this.isAssigned;
        this.organizationItemService.key$
            .pipe(first(), switchMap((key) => isAssigned
            ? this.unassign(key, this.link)
            : this.assign(key, this.link)), take(1), filter((data) => data.status === LoadStatus.SUCCESS))
            .subscribe((data) => this.notify(data.item, isAssigned ? 'unassigned' : 'assigned'));
    }
    assign(key, linkKey) {
        return this.organizationSubListService.assign(key, linkKey);
    }
    unassign(key, linkKey) {
        return this.organizationSubListService.unassign(key, linkKey);
    }
    /**
     * Returns the key for the linked object.
     *
     * At the moment, we're using a generic approach to assign objects,
     * but the object do not have a normalized shape. Therefor, we need
     * to evaluate the context to return the right key for the associated
     * item.
     */
    get link() {
        var _a, _b;
        return ((_b = (_a = this.outlet.context.code) !== null && _a !== void 0 ? _a : this.outlet.context.customerId) !== null && _b !== void 0 ? _b : this.outlet.context.uid);
    }
    notify(item, state) {
        this.messageService.add({
            message: {
                key: `${this.organizationSubListService.viewType}.${state}`,
                params: {
                    item,
                },
            },
        });
    }
}
AssignCellComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AssignCellComponent, deps: [{ token: i1.OutletContextData }, { token: i2.ItemService }, { token: i3.MessageService }, { token: i4.ListService }], target: i0.ɵɵFactoryTarget.Component });
AssignCellComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.0.5", type: AssignCellComponent, selector: "cx-org-assign-cell", usesInheritance: true, ngImport: i0, template: `
    <button type="button" *ngIf="hasItem" (click)="toggleAssign()" class="link">
      {{ isAssigned ? 'unassign' : 'assign' }}
    </button>
  `, isInline: true, directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: AssignCellComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'cx-org-assign-cell',
                    template: `
    <button type="button" *ngIf="hasItem" (click)="toggleAssign()" class="link">
      {{ isAssigned ? 'unassign' : 'assign' }}
    </button>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.OutletContextData }, { type: i2.ItemService }, { type: i3.MessageService }, { type: i4.ListService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzaWduLWNlbGwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vZmVhdHVyZS1saWJzL29yZ2FuaXphdGlvbi9hZG1pbmlzdHJhdGlvbi9jb21wb25lbnRzL3NoYXJlZC9zdWItbGlzdC9hc3NpZ24tY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLaEUsT0FBTyxFQUNMLFVBQVUsR0FFWCxNQUFNLDZDQUE2QyxDQUFDO0FBS3JELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7OztBQVl4RCxNQUFNLE9BQU8sbUJBQXVCLFNBQVEsYUFBYTtJQUN2RCxZQUNZLE1BQWlELEVBQ2pELHVCQUF1QyxFQUN2QyxjQUE4QixFQUM5QiwwQkFBMEM7UUFFcEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBTEosV0FBTSxHQUFOLE1BQU0sQ0FBMkM7UUFDakQsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUFnQjtRQUN2QyxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUFnQjtJQUd0RCxDQUFDO0lBRUQsSUFBSSxVQUFVOztRQUNaLE9BQU8sTUFBQyxJQUFJLENBQUMsSUFBWSwwQ0FBRSxRQUFRLENBQUM7SUFDdEMsQ0FBQztJQUVELFlBQVk7UUFDVixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ25DLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJO2FBQzlCLElBQUksQ0FDSCxLQUFLLEVBQUUsRUFDUCxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNoQixVQUFVO1lBQ1IsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDL0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDaEMsRUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ1AsTUFBTSxDQUNKLENBQUMsSUFBK0IsRUFBRSxFQUFFLENBQ2xDLElBQUksQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE9BQU8sQ0FDckMsQ0FDRjthQUNBLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQy9ELENBQUM7SUFDTixDQUFDO0lBRVMsTUFBTSxDQUNkLEdBQVcsRUFDWCxPQUFlO1FBRWYsT0FBUSxJQUFJLENBQUMsMEJBQWdELENBQUMsTUFBTSxDQUNsRSxHQUFHLEVBQ0gsT0FBTyxDQUNSLENBQUM7SUFDSixDQUFDO0lBRVMsUUFBUSxDQUNoQixHQUFXLEVBQ1gsT0FBZTtRQUVmLE9BQVEsSUFBSSxDQUFDLDBCQUFnRCxDQUFDLFFBQVEsQ0FDcEUsR0FBRyxFQUNILE9BQU8sQ0FDUixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUFjLElBQUk7O1FBQ2hCLE9BQU8sQ0FDTCxNQUFBLE1BQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxtQ0FDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxtQ0FDOUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUN4QixDQUFDO0lBQ0osQ0FBQztJQUVTLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUMxQixJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQztZQUN0QixPQUFPLEVBQUU7Z0JBQ1AsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLFFBQVEsSUFBSSxLQUFLLEVBQUU7Z0JBQzNELE1BQU0sRUFBRTtvQkFDTixJQUFJO2lCQUNMO2FBQ0Y7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDOztnSEFoRlUsbUJBQW1CO29HQUFuQixtQkFBbUIsaUZBUHBCOzs7O0dBSVQ7MkZBR1UsbUJBQW1CO2tCQVQvQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxvQkFBb0I7b0JBQzlCLFFBQVEsRUFBRTs7OztHQUlUO29CQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2lCQUNoRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgZmlyc3QsIHN3aXRjaE1hcCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIE91dGxldENvbnRleHREYXRhLFxuICBUYWJsZURhdGFPdXRsZXRDb250ZXh0LFxufSBmcm9tICdAc3BhcnRhY3VzL3N0b3JlZnJvbnQnO1xuaW1wb3J0IHtcbiAgTG9hZFN0YXR1cyxcbiAgT3JnYW5pemF0aW9uSXRlbVN0YXR1cyxcbn0gZnJvbSAnQHNwYXJ0YWN1cy9vcmdhbml6YXRpb24vYWRtaW5pc3RyYXRpb24vY29yZSc7XG5pbXBvcnQgeyBJdGVtU2VydmljZSB9IGZyb20gJy4uL2l0ZW0uc2VydmljZSc7XG5pbXBvcnQgeyBMaXN0U2VydmljZSB9IGZyb20gJy4uL2xpc3QvbGlzdC5zZXJ2aWNlJztcbmltcG9ydCB7IE1lc3NhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vbWVzc2FnZS9zZXJ2aWNlcy9tZXNzYWdlLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3ViTGlzdFNlcnZpY2UgfSBmcm9tICcuL3N1Yi1saXN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2VsbENvbXBvbmVudCB9IGZyb20gJy4uL3RhYmxlL2NlbGwuY29tcG9uZW50JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtb3JnLWFzc2lnbi1jZWxsJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiAqbmdJZj1cImhhc0l0ZW1cIiAoY2xpY2spPVwidG9nZ2xlQXNzaWduKClcIiBjbGFzcz1cImxpbmtcIj5cbiAgICAgIHt7IGlzQXNzaWduZWQgPyAndW5hc3NpZ24nIDogJ2Fzc2lnbicgfX1cbiAgICA8L2J1dHRvbj5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEFzc2lnbkNlbGxDb21wb25lbnQ8VD4gZXh0ZW5kcyBDZWxsQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIG91dGxldDogT3V0bGV0Q29udGV4dERhdGE8VGFibGVEYXRhT3V0bGV0Q29udGV4dD4sXG4gICAgcHJvdGVjdGVkIG9yZ2FuaXphdGlvbkl0ZW1TZXJ2aWNlOiBJdGVtU2VydmljZTxUPixcbiAgICBwcm90ZWN0ZWQgbWVzc2FnZVNlcnZpY2U6IE1lc3NhZ2VTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBvcmdhbml6YXRpb25TdWJMaXN0U2VydmljZTogTGlzdFNlcnZpY2U8VD5cbiAgKSB7XG4gICAgc3VwZXIob3V0bGV0KTtcbiAgfVxuXG4gIGdldCBpc0Fzc2lnbmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5pdGVtIGFzIGFueSk/LnNlbGVjdGVkO1xuICB9XG5cbiAgdG9nZ2xlQXNzaWduKCkge1xuICAgIGNvbnN0IGlzQXNzaWduZWQgPSB0aGlzLmlzQXNzaWduZWQ7XG4gICAgdGhpcy5vcmdhbml6YXRpb25JdGVtU2VydmljZS5rZXkkXG4gICAgICAucGlwZShcbiAgICAgICAgZmlyc3QoKSxcbiAgICAgICAgc3dpdGNoTWFwKChrZXkpID0+XG4gICAgICAgICAgaXNBc3NpZ25lZFxuICAgICAgICAgICAgPyB0aGlzLnVuYXNzaWduKGtleSwgdGhpcy5saW5rKVxuICAgICAgICAgICAgOiB0aGlzLmFzc2lnbihrZXksIHRoaXMubGluaylcbiAgICAgICAgKSxcbiAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgZmlsdGVyKFxuICAgICAgICAgIChkYXRhOiBPcmdhbml6YXRpb25JdGVtU3RhdHVzPFQ+KSA9PlxuICAgICAgICAgICAgZGF0YS5zdGF0dXMgPT09IExvYWRTdGF0dXMuU1VDQ0VTU1xuICAgICAgICApXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChkYXRhKSA9PlxuICAgICAgICB0aGlzLm5vdGlmeShkYXRhLml0ZW0sIGlzQXNzaWduZWQgPyAndW5hc3NpZ25lZCcgOiAnYXNzaWduZWQnKVxuICAgICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3NpZ24oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbGlua0tleTogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8T3JnYW5pemF0aW9uSXRlbVN0YXR1czxUPj4ge1xuICAgIHJldHVybiAodGhpcy5vcmdhbml6YXRpb25TdWJMaXN0U2VydmljZSBhcyBTdWJMaXN0U2VydmljZTxUPikuYXNzaWduKFxuICAgICAga2V5LFxuICAgICAgbGlua0tleVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5hc3NpZ24oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgbGlua0tleTogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8T3JnYW5pemF0aW9uSXRlbVN0YXR1czxUPj4ge1xuICAgIHJldHVybiAodGhpcy5vcmdhbml6YXRpb25TdWJMaXN0U2VydmljZSBhcyBTdWJMaXN0U2VydmljZTxUPikudW5hc3NpZ24oXG4gICAgICBrZXksXG4gICAgICBsaW5rS2V5XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBsaW5rZWQgb2JqZWN0LlxuICAgKlxuICAgKiBBdCB0aGUgbW9tZW50LCB3ZSdyZSB1c2luZyBhIGdlbmVyaWMgYXBwcm9hY2ggdG8gYXNzaWduIG9iamVjdHMsXG4gICAqIGJ1dCB0aGUgb2JqZWN0IGRvIG5vdCBoYXZlIGEgbm9ybWFsaXplZCBzaGFwZS4gVGhlcmVmb3IsIHdlIG5lZWRcbiAgICogdG8gZXZhbHVhdGUgdGhlIGNvbnRleHQgdG8gcmV0dXJuIHRoZSByaWdodCBrZXkgZm9yIHRoZSBhc3NvY2lhdGVkXG4gICAqIGl0ZW0uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IGxpbmsoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vdXRsZXQuY29udGV4dC5jb2RlID8/XG4gICAgICB0aGlzLm91dGxldC5jb250ZXh0LmN1c3RvbWVySWQgPz9cbiAgICAgIHRoaXMub3V0bGV0LmNvbnRleHQudWlkXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBub3RpZnkoaXRlbSwgc3RhdGUpIHtcbiAgICB0aGlzLm1lc3NhZ2VTZXJ2aWNlLmFkZCh7XG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIGtleTogYCR7dGhpcy5vcmdhbml6YXRpb25TdWJMaXN0U2VydmljZS52aWV3VHlwZX0uJHtzdGF0ZX1gLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBpdGVtLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIl19