import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { TREE_TOGGLE } from './unit-tree.model';
import * as i0 from "@angular/core";
/**
 * Service to populate Unit data to `Table` data. Unit
 * data is driven by the table configuration, using the `OrganizationTables.UNIT`.
 */
export class UnitTreeService {
    constructor() {
        /**
         * Indicates the minimum number of (initial) expanded units.
         */
        this.minimalExpanded = 1;
        this.globalToggle$ = new BehaviorSubject(undefined);
        this.treeToggle$ = new BehaviorSubject(new Map());
    }
    /**
     * Initializes the unit tree with an active unit.
     *
     * The active unit will be collapsed.
     */
    initialize(root, activeUnitId) {
        if (activeUnitId) {
            this.expandUntilActiveNode(root, activeUnitId);
        }
    }
    /**
     * Sets the global toggle state to _collapsed_ and clears the toggle state
     * for individual units.
     */
    collapseAll() {
        this.globalToggle$.next(TREE_TOGGLE.COLLAPSED);
        this.treeToggle$.next(new Map());
    }
    /**
     * Sets the global toggle state to _expanded_ and clears the toggle state
     * for individual units.
     */
    expandAll() {
        this.globalToggle$.next(TREE_TOGGLE.EXPANDED);
        this.treeToggle$.next(new Map());
    }
    /**
     * Indicates whether the give unit is expanded.
     *
     * The returned (boolean) expand state is driven by the global toggle
     * state (expand / collapse all) and the toggle state for individual units.
     * There's also the `minimalExpanded` taken into consideration.
     */
    isExpanded(unitId, level) {
        var _a;
        const toggleState = (_a = this.treeToggle$.value) === null || _a === void 0 ? void 0 : _a.get(unitId);
        if (this.globalToggle$.value === TREE_TOGGLE.COLLAPSED &&
            toggleState !== TREE_TOGGLE.EXPANDED) {
            return false;
        }
        return (
        // the current node is expanded
        toggleState === TREE_TOGGLE.EXPANDED ||
            // the node is not collapsed, but globally expanded ("expand all") or above
            // the minimum visible nodes
            ((this.globalToggle$.value === TREE_TOGGLE.EXPANDED ||
                level < this.minimalExpanded) &&
                toggleState !== TREE_TOGGLE.COLLAPSED));
    }
    toggle(unit) {
        const currentState = this.treeToggle$.value;
        currentState.set(unit.id, this.isExpanded(unit.id, unit.depthLevel)
            ? TREE_TOGGLE.COLLAPSED
            : TREE_TOGGLE.EXPANDED);
        this.treeToggle$.next(currentState);
    }
    /**
     * Expands all tree nodes till the active unit, to ensure that the
     * full tree is collapsed till the active item.
     *
     * This is useful while navigating the tree by the router.
     */
    expandUntilActiveNode(node, activeUnitId) {
        const hasActiveChild = (n, id) => {
            var _a;
            return !!((_a = n.children) === null || _a === void 0 ? void 0 : _a.find((child) => child.id === id || hasActiveChild(child, id)));
        };
        const findInvolvedTreeNodes = (n, activeItems = []) => {
            if (hasActiveChild(n, activeUnitId)) {
                activeItems.push(n.id);
            }
            n.children.forEach((child) => {
                findInvolvedTreeNodes(child, activeItems);
            });
            return activeItems;
        };
        const m = this.treeToggle$.value;
        findInvolvedTreeNodes(node).forEach((activeId) => {
            if (m.get(activeId) !== TREE_TOGGLE.EXPANDED) {
                m.set(activeId, TREE_TOGGLE.EXPANDED);
            }
        });
        if (m !== this.treeToggle$.value) {
            this.treeToggle$.next(m);
        }
    }
}
UnitTreeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UnitTreeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
UnitTreeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UnitTreeService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: UnitTreeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pdC10cmVlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9mZWF0dXJlLWxpYnMvb3JnYW5pemF0aW9uL2FkbWluaXN0cmF0aW9uL2NvbXBvbmVudHMvdW5pdC9zZXJ2aWNlcy91bml0LXRyZWUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBSzNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUVoRDs7O0dBR0c7QUFJSCxNQUFNLE9BQU8sZUFBZTtJQUg1QjtRQUlFOztXQUVHO1FBQ08sb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFFcEIsa0JBQWEsR0FBaUMsSUFBSSxlQUFlLENBQ3pFLFNBQVMsQ0FDVixDQUFDO1FBRUYsZ0JBQVcsR0FBOEMsSUFBSSxlQUFlLENBQzFFLElBQUksR0FBRyxFQUFFLENBQ1YsQ0FBQztLQXlHSDtJQXZHQzs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLElBQWlCLEVBQUUsWUFBb0I7UUFDaEQsSUFBSSxZQUFZLEVBQUU7WUFDaEIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUztRQUNQLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFJ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QUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQzs7NEdBcEhVLGVBQWU7Z0hBQWYsZUFBZSxjQUZkLE1BQU07MkZBRVAsZUFBZTtrQkFIM0IsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCMkJVbml0Tm9kZSxcbiAgQjJCVW5pdFRyZWVOb2RlLFxufSBmcm9tICdAc3BhcnRhY3VzL29yZ2FuaXphdGlvbi9hZG1pbmlzdHJhdGlvbi9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVFJFRV9UT0dHTEUgfSBmcm9tICcuL3VuaXQtdHJlZS5tb2RlbCc7XG5cbi8qKlxuICogU2VydmljZSB0byBwb3B1bGF0ZSBVbml0IGRhdGEgdG8gYFRhYmxlYCBkYXRhLiBVbml0XG4gKiBkYXRhIGlzIGRyaXZlbiBieSB0aGUgdGFibGUgY29uZmlndXJhdGlvbiwgdXNpbmcgdGhlIGBPcmdhbml6YXRpb25UYWJsZXMuVU5JVGAuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBVbml0VHJlZVNlcnZpY2Uge1xuICAvKipcbiAgICogSW5kaWNhdGVzIHRoZSBtaW5pbXVtIG51bWJlciBvZiAoaW5pdGlhbCkgZXhwYW5kZWQgdW5pdHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgbWluaW1hbEV4cGFuZGVkID0gMTtcblxuICBwcm90ZWN0ZWQgZ2xvYmFsVG9nZ2xlJDogQmVoYXZpb3JTdWJqZWN0PFRSRUVfVE9HR0xFPiA9IG5ldyBCZWhhdmlvclN1YmplY3QoXG4gICAgdW5kZWZpbmVkXG4gICk7XG5cbiAgdHJlZVRvZ2dsZSQ6IEJlaGF2aW9yU3ViamVjdDxNYXA8c3RyaW5nLCBUUkVFX1RPR0dMRT4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChcbiAgICBuZXcgTWFwKClcbiAgKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHVuaXQgdHJlZSB3aXRoIGFuIGFjdGl2ZSB1bml0LlxuICAgKlxuICAgKiBUaGUgYWN0aXZlIHVuaXQgd2lsbCBiZSBjb2xsYXBzZWQuXG4gICAqL1xuICBpbml0aWFsaXplKHJvb3Q6IEIyQlVuaXROb2RlLCBhY3RpdmVVbml0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChhY3RpdmVVbml0SWQpIHtcbiAgICAgIHRoaXMuZXhwYW5kVW50aWxBY3RpdmVOb2RlKHJvb3QsIGFjdGl2ZVVuaXRJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdsb2JhbCB0b2dnbGUgc3RhdGUgdG8gX2NvbGxhcHNlZF8gYW5kIGNsZWFycyB0aGUgdG9nZ2xlIHN0YXRlXG4gICAqIGZvciBpbmRpdmlkdWFsIHVuaXRzLlxuICAgKi9cbiAgY29sbGFwc2VBbGwoKSB7XG4gICAgdGhpcy5nbG9iYWxUb2dnbGUkLm5leHQoVFJFRV9UT0dHTEUuQ09MTEFQU0VEKTtcbiAgICB0aGlzLnRyZWVUb2dnbGUkLm5leHQobmV3IE1hcCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnbG9iYWwgdG9nZ2xlIHN0YXRlIHRvIF9leHBhbmRlZF8gYW5kIGNsZWFycyB0aGUgdG9nZ2xlIHN0YXRlXG4gICAqIGZvciBpbmRpdmlkdWFsIHVuaXRzLlxuICAgKi9cbiAgZXhwYW5kQWxsKCkge1xuICAgIHRoaXMuZ2xvYmFsVG9nZ2xlJC5uZXh0KFRSRUVfVE9HR0xFLkVYUEFOREVEKTtcbiAgICB0aGlzLnRyZWVUb2dnbGUkLm5leHQobmV3IE1hcCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZ2l2ZSB1bml0IGlzIGV4cGFuZGVkLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgKGJvb2xlYW4pIGV4cGFuZCBzdGF0ZSBpcyBkcml2ZW4gYnkgdGhlIGdsb2JhbCB0b2dnbGVcbiAgICogc3RhdGUgKGV4cGFuZCAvIGNvbGxhcHNlIGFsbCkgYW5kIHRoZSB0b2dnbGUgc3RhdGUgZm9yIGluZGl2aWR1YWwgdW5pdHMuXG4gICAqIFRoZXJlJ3MgYWxzbyB0aGUgYG1pbmltYWxFeHBhbmRlZGAgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uLlxuICAgKi9cbiAgaXNFeHBhbmRlZCh1bml0SWQ6IHN0cmluZywgbGV2ZWw6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRvZ2dsZVN0YXRlID0gdGhpcy50cmVlVG9nZ2xlJC52YWx1ZT8uZ2V0KHVuaXRJZCk7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLmdsb2JhbFRvZ2dsZSQudmFsdWUgPT09IFRSRUVfVE9HR0xFLkNPTExBUFNFRCAmJlxuICAgICAgdG9nZ2xlU3RhdGUgIT09IFRSRUVfVE9HR0xFLkVYUEFOREVEXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgZXhwYW5kZWRcbiAgICAgIHRvZ2dsZVN0YXRlID09PSBUUkVFX1RPR0dMRS5FWFBBTkRFRCB8fFxuICAgICAgLy8gdGhlIG5vZGUgaXMgbm90IGNvbGxhcHNlZCwgYnV0IGdsb2JhbGx5IGV4cGFuZGVkIChcImV4cGFuZCBhbGxcIikgb3IgYWJvdmVcbiAgICAgIC8vIHRoZSBtaW5pbXVtIHZpc2libGUgbm9kZXNcbiAgICAgICgodGhpcy5nbG9iYWxUb2dnbGUkLnZhbHVlID09PSBUUkVFX1RPR0dMRS5FWFBBTkRFRCB8fFxuICAgICAgICBsZXZlbCA8IHRoaXMubWluaW1hbEV4cGFuZGVkKSAmJlxuICAgICAgICB0b2dnbGVTdGF0ZSAhPT0gVFJFRV9UT0dHTEUuQ09MTEFQU0VEKVxuICAgICk7XG4gIH1cblxuICB0b2dnbGUodW5pdDogQjJCVW5pdFRyZWVOb2RlKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy50cmVlVG9nZ2xlJC52YWx1ZTtcbiAgICBjdXJyZW50U3RhdGUuc2V0KFxuICAgICAgdW5pdC5pZCxcbiAgICAgIHRoaXMuaXNFeHBhbmRlZCh1bml0LmlkLCB1bml0LmRlcHRoTGV2ZWwpXG4gICAgICAgID8gVFJFRV9UT0dHTEUuQ09MTEFQU0VEXG4gICAgICAgIDogVFJFRV9UT0dHTEUuRVhQQU5ERURcbiAgICApO1xuICAgIHRoaXMudHJlZVRvZ2dsZSQubmV4dChjdXJyZW50U3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZHMgYWxsIHRyZWUgbm9kZXMgdGlsbCB0aGUgYWN0aXZlIHVuaXQsIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgKiBmdWxsIHRyZWUgaXMgY29sbGFwc2VkIHRpbGwgdGhlIGFjdGl2ZSBpdGVtLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGlsZSBuYXZpZ2F0aW5nIHRoZSB0cmVlIGJ5IHRoZSByb3V0ZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZXhwYW5kVW50aWxBY3RpdmVOb2RlKG5vZGU6IEIyQlVuaXROb2RlLCBhY3RpdmVVbml0SWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGhhc0FjdGl2ZUNoaWxkID0gKG46IEIyQlVuaXROb2RlLCBpZDogc3RyaW5nKTogYm9vbGVhbiA9PlxuICAgICAgISFuLmNoaWxkcmVuPy5maW5kKFxuICAgICAgICAoY2hpbGQpID0+IGNoaWxkLmlkID09PSBpZCB8fCBoYXNBY3RpdmVDaGlsZChjaGlsZCwgaWQpXG4gICAgICApO1xuXG4gICAgY29uc3QgZmluZEludm9sdmVkVHJlZU5vZGVzID0gKFxuICAgICAgbjogQjJCVW5pdE5vZGUsXG4gICAgICBhY3RpdmVJdGVtcyA9IFtdXG4gICAgKTogc3RyaW5nW10gPT4ge1xuICAgICAgaWYgKGhhc0FjdGl2ZUNoaWxkKG4sIGFjdGl2ZVVuaXRJZCkpIHtcbiAgICAgICAgYWN0aXZlSXRlbXMucHVzaChuLmlkKTtcbiAgICAgIH1cbiAgICAgIG4uY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgZmluZEludm9sdmVkVHJlZU5vZGVzKGNoaWxkLCBhY3RpdmVJdGVtcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RpdmVJdGVtcztcbiAgICB9O1xuXG4gICAgY29uc3QgbSA9IHRoaXMudHJlZVRvZ2dsZSQudmFsdWU7XG4gICAgZmluZEludm9sdmVkVHJlZU5vZGVzKG5vZGUpLmZvckVhY2goKGFjdGl2ZUlkKSA9PiB7XG4gICAgICBpZiAobS5nZXQoYWN0aXZlSWQpICE9PSBUUkVFX1RPR0dMRS5FWFBBTkRFRCkge1xuICAgICAgICBtLnNldChhY3RpdmVJZCwgVFJFRV9UT0dHTEUuRVhQQU5ERUQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChtICE9PSB0aGlzLnRyZWVUb2dnbGUkLnZhbHVlKSB7XG4gICAgICB0aGlzLnRyZWVUb2dnbGUkLm5leHQobSk7XG4gICAgfVxuICB9XG59XG4iXX0=