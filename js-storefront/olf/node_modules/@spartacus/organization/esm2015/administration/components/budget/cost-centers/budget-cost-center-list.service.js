import { Injectable } from '@angular/core';
import { filter, map } from 'rxjs/operators';
import { SubListService } from '../../shared/sub-list/sub-list.service';
import { OrganizationTableType } from '../../shared/organization.model';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/storefront";
import * as i2 from "@spartacus/organization/administration/core";
export class BudgetCostCenterListService extends SubListService {
    constructor(tableService, budgetService) {
        super(tableService);
        this.tableService = tableService;
        this.budgetService = budgetService;
        this.tableType = OrganizationTableType.BUDGET_ASSIGNED_COST_CENTERS;
        this._domainType = OrganizationTableType.COST_CENTER;
    }
    load(_pagination, code) {
        return this.budgetService.getCostCenters(code).pipe(filter((list) => Boolean(list)), map((costCenter) => this.filterSelected(costCenter)));
    }
    /**
     * As we can't filter with the backend API, we do this client side.
     */
    filterSelected({ pagination, sorts, values, }) {
        return {
            pagination,
            sorts,
            values: values.filter((value) => value.active),
        };
    }
}
BudgetCostCenterListService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BudgetCostCenterListService, deps: [{ token: i1.TableService }, { token: i2.BudgetService }], target: i0.ɵɵFactoryTarget.Injectable });
BudgetCostCenterListService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BudgetCostCenterListService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.5", ngImport: i0, type: BudgetCostCenterListService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.TableService }, { type: i2.BudgetService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVkZ2V0LWNvc3QtY2VudGVyLWxpc3Quc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2ZlYXR1cmUtbGlicy9vcmdhbml6YXRpb24vYWRtaW5pc3RyYXRpb24vY29tcG9uZW50cy9idWRnZXQvY29zdC1jZW50ZXJzL2J1ZGdldC1jb3N0LWNlbnRlci1saXN0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQVEzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUN4RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQzs7OztBQUt4RSxNQUFNLE9BQU8sMkJBQTRCLFNBQVEsY0FBc0I7SUFJckUsWUFDWSxZQUEwQixFQUMxQixhQUE0QjtRQUV0QyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFIVixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUw5QixjQUFTLEdBQUcscUJBQXFCLENBQUMsNEJBQTRCLENBQUM7UUFDL0QsZ0JBQVcsR0FBRyxxQkFBcUIsQ0FBQyxXQUFXLENBQUM7SUFPMUQsQ0FBQztJQUVTLElBQUksQ0FDWixXQUE0QixFQUM1QixJQUFZO1FBRVosT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQ2pELE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQy9CLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUNyRCxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ08sY0FBYyxDQUFDLEVBQ3ZCLFVBQVUsRUFDVixLQUFLLEVBQ0wsTUFBTSxHQUNvQjtRQUMxQixPQUFPO1lBQ0wsVUFBVTtZQUNWLEtBQUs7WUFDTCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztTQUMvQyxDQUFDO0lBQ0osQ0FBQzs7d0hBbENVLDJCQUEyQjs0SEFBM0IsMkJBQTJCLGNBRjFCLE1BQU07MkZBRVAsMkJBQTJCO2tCQUh2QyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvc3RDZW50ZXIsIEVudGl0aWVzTW9kZWwsIFBhZ2luYXRpb25Nb2RlbCB9IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XG5pbXBvcnQge1xuICBCdWRnZXQsXG4gIEJ1ZGdldFNlcnZpY2UsXG59IGZyb20gJ0BzcGFydGFjdXMvb3JnYW5pemF0aW9uL2FkbWluaXN0cmF0aW9uL2NvcmUnO1xuaW1wb3J0IHsgVGFibGVTZXJ2aWNlIH0gZnJvbSAnQHNwYXJ0YWN1cy9zdG9yZWZyb250JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViTGlzdFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvc3ViLWxpc3Qvc3ViLWxpc3Quc2VydmljZSc7XG5pbXBvcnQgeyBPcmdhbml6YXRpb25UYWJsZVR5cGUgfSBmcm9tICcuLi8uLi9zaGFyZWQvb3JnYW5pemF0aW9uLm1vZGVsJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEJ1ZGdldENvc3RDZW50ZXJMaXN0U2VydmljZSBleHRlbmRzIFN1Ykxpc3RTZXJ2aWNlPEJ1ZGdldD4ge1xuICBwcm90ZWN0ZWQgdGFibGVUeXBlID0gT3JnYW5pemF0aW9uVGFibGVUeXBlLkJVREdFVF9BU1NJR05FRF9DT1NUX0NFTlRFUlM7XG4gIHByb3RlY3RlZCBfZG9tYWluVHlwZSA9IE9yZ2FuaXphdGlvblRhYmxlVHlwZS5DT1NUX0NFTlRFUjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgdGFibGVTZXJ2aWNlOiBUYWJsZVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGJ1ZGdldFNlcnZpY2U6IEJ1ZGdldFNlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIodGFibGVTZXJ2aWNlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkKFxuICAgIF9wYWdpbmF0aW9uOiBQYWdpbmF0aW9uTW9kZWwsXG4gICAgY29kZTogc3RyaW5nXG4gICk6IE9ic2VydmFibGU8RW50aXRpZXNNb2RlbDxDb3N0Q2VudGVyPj4ge1xuICAgIHJldHVybiB0aGlzLmJ1ZGdldFNlcnZpY2UuZ2V0Q29zdENlbnRlcnMoY29kZSkucGlwZShcbiAgICAgIGZpbHRlcigobGlzdCkgPT4gQm9vbGVhbihsaXN0KSksXG4gICAgICBtYXAoKGNvc3RDZW50ZXIpID0+IHRoaXMuZmlsdGVyU2VsZWN0ZWQoY29zdENlbnRlcikpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyB3ZSBjYW4ndCBmaWx0ZXIgd2l0aCB0aGUgYmFja2VuZCBBUEksIHdlIGRvIHRoaXMgY2xpZW50IHNpZGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgZmlsdGVyU2VsZWN0ZWQoe1xuICAgIHBhZ2luYXRpb24sXG4gICAgc29ydHMsXG4gICAgdmFsdWVzLFxuICB9OiBFbnRpdGllc01vZGVsPENvc3RDZW50ZXI+KTogRW50aXRpZXNNb2RlbDxDb3N0Q2VudGVyPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2luYXRpb24sXG4gICAgICBzb3J0cyxcbiAgICAgIHZhbHVlczogdmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLmFjdGl2ZSksXG4gICAgfTtcbiAgfVxufVxuIl19