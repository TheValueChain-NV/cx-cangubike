{"ast":null,"code":"import * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, APP_INITIALIZER, NgModule } from '@angular/core';\nimport * as i3 from '@spartacus/storefront';\nimport { PageComponentModule } from '@spartacus/storefront';\nimport * as i1$1 from '@spartacus/core';\nimport { AuthStorageService, AuthActions, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, AuthHttpHeaderService, InterceptorUtil, USE_CUSTOMER_SUPPORT_AGENT_TOKEN, GlobalMessageType, AuthService } from '@spartacus/core';\nimport { map, take, switchMap } from 'rxjs/operators';\nimport { __awaiter } from 'tslib';\nimport { BehaviorSubject, combineLatest, of, from } from 'rxjs';\nimport * as i3$1 from '@ngrx/store';\nconst ASM_ENABLED_LOCAL_STORAGE_KEY = 'asm_enabled';\n\n/**\n * The AsmEnablerService is used to enable ASM for those scenario's\n * where it's actually used. This service is added to avoid any polution\n * of the UI and runtime performance for the ordinary production user.\n */\nlet AsmEnablerService = /*#__PURE__*/(() => {\n  class AsmEnablerService {\n    constructor(location, winRef, launchDialogService, featureModules) {\n      this.location = location;\n      this.winRef = winRef;\n      this.launchDialogService = launchDialogService;\n      this.featureModules = featureModules;\n    }\n    /**\n     * Loads the ASM UI if needed. The ASM UI will be added based on the\n     * existence of a URL parameter or previous usage given by local storage.\n     */\n    load() {\n      if (this.isEnabled()) {\n        this.addUi();\n      }\n    }\n    /**\n     * Indicates whether the ASM module is enabled.\n     */\n    isEnabled() {\n      if (this.isLaunched() && !this.isUsedBefore()) {\n        if (this.winRef.localStorage) {\n          this.winRef.localStorage.setItem(ASM_ENABLED_LOCAL_STORAGE_KEY, 'true');\n        }\n      }\n      return this.isLaunched() || this.isUsedBefore();\n    }\n    /**\n     * Indicates whether ASM is launched through the URL,\n     * using the asm flag in the URL.\n     */\n    isLaunched() {\n      const params = this.location.path().split('?')[1];\n      return !!params && params.split('&').includes('asm=true');\n    }\n    /**\n     * Evaluates local storage where we persist the usage of ASM.\n     */\n    isUsedBefore() {\n      if (this.winRef.localStorage) {\n        return this.winRef.localStorage.getItem(ASM_ENABLED_LOCAL_STORAGE_KEY) === 'true';\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Adds the ASM UI by using the `cx-storefront` outlet.\n     */\n    addUi() {\n      this.featureModules.resolveFeature('asm').subscribe(() => this.launchDialogService.launch(\"ASM\" /* ASM */));\n    }\n  }\n\n  AsmEnablerService.ɵfac = function AsmEnablerService_Factory(t) {\n    return new (t || AsmEnablerService)(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i1$1.WindowRef), i0.ɵɵinject(i3.LaunchDialogService), i0.ɵɵinject(i1$1.FeatureModulesService));\n  };\n  AsmEnablerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmEnablerService,\n    factory: AsmEnablerService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmEnablerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The ASM loader module takes care of loading the ASM UI\n * only in case there's a reason to do so.\n */\nlet AsmLoaderModule = /*#__PURE__*/(() => {\n  class AsmLoaderModule {}\n  AsmLoaderModule.ɵfac = function AsmLoaderModule_Factory(t) {\n    return new (t || AsmLoaderModule)();\n  };\n  AsmLoaderModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AsmLoaderModule\n  });\n  AsmLoaderModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: APP_INITIALIZER,\n      useFactory: asmFactory,\n      deps: [AsmEnablerService],\n      multi: true\n    }],\n    imports: [[CommonModule, PageComponentModule]]\n  });\n  return AsmLoaderModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n *\n * We do not like to block the UI, which is why we delgate loading of ASM\n * to a real component; the router and state aren't available in an optimized\n * way during the APP_INITIALIZER.\n */\nfunction asmFactory(asmEnablerService) {\n  const isReady = () => {\n    asmEnablerService.load();\n  };\n  return isReady;\n}\n\n/**\n * Indicates if auth token is for regular user or CS Agent.\n */\nvar TokenTarget = /*#__PURE__*/(() => {\n  (function (TokenTarget) {\n    TokenTarget[\"CSAgent\"] = \"CSAgent\";\n    TokenTarget[\"User\"] = \"User\";\n  })(TokenTarget || (TokenTarget = {}));\n  return TokenTarget;\n})();\n/**\n * With AsmAuthStorageService apart from storing the token we also need to store\n * information for which user is the token (regular user or CS Agent).\n *\n * Overrides `AuthStorageService`.\n */let AsmAuthStorageService = /*#__PURE__*/(() => {\n  class AsmAuthStorageService extends AuthStorageService {\n    constructor() {\n      super(...arguments);\n      this._tokenTarget$ = new BehaviorSubject(TokenTarget.User);\n    }\n    /**\n     * Get target user for current auth token.\n     *\n     * @return observable with TokenTarget\n     */\n    getTokenTarget() {\n      return this._tokenTarget$;\n    }\n    /**\n     * Set new token target.\n     *\n     * @param tokenTarget\n     */\n    setTokenTarget(tokenTarget) {\n      this._tokenTarget$.next(tokenTarget);\n    }\n    /**\n     * Get token for previously user session, when it was interrupted by CS agent login.\n     *\n     * @return previously logged in user token.\n     */\n    getEmulatedUserToken() {\n      return this.emulatedUserToken;\n    }\n    /**\n     * Save user token on CS agent login.\n     *\n     * @param token\n     */\n    setEmulatedUserToken(token) {\n      this.emulatedUserToken = token;\n    }\n    /**\n     * Change token target to CS Agent.\n     */\n    switchTokenTargetToCSAgent() {\n      this._tokenTarget$.next(TokenTarget.CSAgent);\n    }\n    /**\n     * Change token target to user.\n     */\n    switchTokenTargetToUser() {\n      this._tokenTarget$.next(TokenTarget.User);\n    }\n    /**\n     * When we start emulation from the UI (not by ASM login) we can't restore user session on cs agent logout.\n     * Only available solution is to drop session we could restore, to avoid account hijack.\n     */\n    clearEmulatedUserToken() {\n      this.emulatedUserToken = undefined;\n    }\n  }\n  AsmAuthStorageService.ɵfac = /* @__PURE__ */function () {\n    let ɵAsmAuthStorageService_BaseFactory;\n    return function AsmAuthStorageService_Factory(t) {\n      return (ɵAsmAuthStorageService_BaseFactory || (ɵAsmAuthStorageService_BaseFactory = i0.ɵɵgetInheritedFactory(AsmAuthStorageService)))(t || AsmAuthStorageService);\n    };\n  }();\n  AsmAuthStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmAuthStorageService,\n    factory: AsmAuthStorageService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmAuthStorageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Auth service for CS agent. Useful to login/logout agent, start emulation\n * or get information about the status of emulation.\n */\nlet CsAgentAuthService = /*#__PURE__*/(() => {\n  class CsAgentAuthService {\n    constructor(authService, authStorageService, userIdService, oAuthLibWrapperService, store, userService) {\n      this.authService = authService;\n      this.authStorageService = authStorageService;\n      this.userIdService = userIdService;\n      this.oAuthLibWrapperService = oAuthLibWrapperService;\n      this.store = store;\n      this.userService = userService;\n    }\n    /**\n     * Loads access token for a customer support agent.\n     * @param userId\n     * @param password\n     */\n    authorizeCustomerSupportAgent(userId, password) {\n      return __awaiter(this, void 0, void 0, function* () {\n        let userToken;\n        this.authStorageService.getToken().subscribe(token => userToken = token).unsubscribe();\n        this.authStorageService.switchTokenTargetToCSAgent();\n        try {\n          yield this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password);\n          // Start emulation for currently logged in user\n          let customerId;\n          this.userService.get().subscribe(user => customerId = user === null || user === void 0 ? void 0 : user.customerId).unsubscribe();\n          this.store.dispatch(new AuthActions.Logout());\n          if (customerId !== undefined && userToken !== undefined) {\n            // OCC specific user id handling. Customize when implementing different backend\n            this.userIdService.setUserId(customerId);\n            this.authStorageService.setEmulatedUserToken(userToken);\n            this.store.dispatch(new AuthActions.Login());\n          } else {\n            // When we can't get the customerId just end all current sessions\n            this.userIdService.setUserId(OCC_USER_ID_ANONYMOUS);\n            this.authStorageService.clearEmulatedUserToken();\n          }\n        } catch (_a) {\n          this.authStorageService.switchTokenTargetToUser();\n        }\n      });\n    }\n    /**\n     * Starts an ASM customer emulation session.\n     * A customer emulation session is stopped by calling logout().\n     * @param customerId\n     */\n    startCustomerEmulationSession(customerId) {\n      this.authStorageService.clearEmulatedUserToken();\n      // OCC specific user id handling. Customize when implementing different backend\n      this.store.dispatch(new AuthActions.Logout());\n      this.userIdService.setUserId(customerId);\n      this.store.dispatch(new AuthActions.Login());\n    }\n    /**\n     * Check if CS agent is currently logged in.\n     *\n     * @returns observable emitting true when CS agent is logged in or false when not.\n     */\n    isCustomerSupportAgentLoggedIn() {\n      return combineLatest([this.authStorageService.getToken(), this.authStorageService.getTokenTarget()]).pipe(map(([token, tokenTarget]) => Boolean((token === null || token === void 0 ? void 0 : token.access_token) && tokenTarget === TokenTarget.CSAgent)));\n    }\n    /**\n     * Utility function to determine if customer is emulated.\n     *\n     * @returns observable emitting true when there is active emulation session or false when not.\n     */\n    isCustomerEmulated() {\n      return this.userIdService.isEmulated();\n    }\n    /**\n     * Returns the customer support agent's token loading status\n     */\n    getCustomerSupportAgentTokenLoading() {\n      // TODO(#8248): Create new loading state outside of store\n      return of(false);\n    }\n    /**\n     * Logout a customer support agent.\n     */\n    logoutCustomerSupportAgent() {\n      return __awaiter(this, void 0, void 0, function* () {\n        const emulatedToken = this.authStorageService.getEmulatedUserToken();\n        let isCustomerEmulated;\n        this.userIdService.isEmulated().subscribe(emulated => isCustomerEmulated = emulated).unsubscribe();\n        yield this.oAuthLibWrapperService.revokeAndLogout();\n        this.store.dispatch({\n          type: '[Auth] Logout Customer Support Agent'\n        });\n        this.authStorageService.setTokenTarget(TokenTarget.User);\n        if (isCustomerEmulated && emulatedToken) {\n          this.store.dispatch(new AuthActions.Logout());\n          this.authStorageService.setToken(emulatedToken);\n          this.userIdService.setUserId(OCC_USER_ID_CURRENT);\n          this.authStorageService.clearEmulatedUserToken();\n          this.store.dispatch(new AuthActions.Login());\n        } else {\n          this.authService.logout();\n        }\n      });\n    }\n  }\n  CsAgentAuthService.ɵfac = function CsAgentAuthService_Factory(t) {\n    return new (t || CsAgentAuthService)(i0.ɵɵinject(i1$1.AuthService), i0.ɵɵinject(AsmAuthStorageService), i0.ɵɵinject(i1$1.UserIdService), i0.ɵɵinject(i1$1.OAuthLibWrapperService), i0.ɵɵinject(i3$1.Store), i0.ɵɵinject(i1$1.UserService));\n  };\n  CsAgentAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CsAgentAuthService,\n    factory: CsAgentAuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return CsAgentAuthService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Overrides `AuthHttpHeaderService` to handle asm calls as well (not only OCC)\n * in cases of normal user session and on customer emulation.\n */\nlet AsmAuthHttpHeaderService = /*#__PURE__*/(() => {\n  class AsmAuthHttpHeaderService extends AuthHttpHeaderService {\n    constructor(authService, authStorageService, csAgentAuthService, oAuthLibWrapperService, routingService, globalMessageService, occEndpointsService, authRedirectService) {\n      super(authService, authStorageService, oAuthLibWrapperService, routingService, occEndpointsService, globalMessageService, authRedirectService);\n      this.authService = authService;\n      this.authStorageService = authStorageService;\n      this.csAgentAuthService = csAgentAuthService;\n      this.oAuthLibWrapperService = oAuthLibWrapperService;\n      this.routingService = routingService;\n      this.globalMessageService = globalMessageService;\n      this.occEndpointsService = occEndpointsService;\n      this.authRedirectService = authRedirectService;\n    }\n    /**\n     * Checks if the authorization header should be added to the request\n     *\n     *  @override\n     */\n    shouldAddAuthorizationHeader(request) {\n      return super.shouldAddAuthorizationHeader(request) || this.isCSAgentTokenRequest(request);\n    }\n    /**\n     * @override\n     *\n     * Checks if particular request should be handled by this service.\n     */\n    shouldCatchError(request) {\n      return super.shouldCatchError(request) || this.isCSAgentTokenRequest(request);\n    }\n    /**\n     * @override\n     *\n     * Adds `Authorization` header to occ and CS agent requests.\n     * For CS agent requests also removes the `cx-use-csagent-token` header (to avoid problems with CORS).\n     */\n    alterRequest(request, token) {\n      const hasAuthorizationHeader = !!this.getAuthorizationHeader(request);\n      const isCSAgentRequest = this.isCSAgentTokenRequest(request);\n      let req = super.alterRequest(request, token);\n      if (!hasAuthorizationHeader && isCSAgentRequest) {\n        req = request.clone({\n          setHeaders: Object.assign({}, this.createAuthorizationHeader(token))\n        });\n        return InterceptorUtil.removeHeader(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, req);\n      }\n      return req;\n    }\n    isCSAgentTokenRequest(request) {\n      const isRequestWithCSAgentToken = InterceptorUtil.getInterceptorParam(USE_CUSTOMER_SUPPORT_AGENT_TOKEN, request.headers);\n      return Boolean(isRequestWithCSAgentToken);\n    }\n    /**\n     * @override\n     *\n     * On backend errors indicating expired `refresh_token` we need to logout\n     * currently logged in user and CS agent.\n     */\n    handleExpiredRefreshToken() {\n      this.csAgentAuthService.isCustomerSupportAgentLoggedIn().pipe(take(1)).subscribe(csAgentLoggedIn => {\n        if (csAgentLoggedIn) {\n          this.authService.setLogoutProgress(true);\n          this.csAgentAuthService.logoutCustomerSupportAgent();\n          this.globalMessageService.add({\n            key: 'asm.csagentTokenExpired'\n          }, GlobalMessageType.MSG_TYPE_ERROR);\n        } else {\n          super.handleExpiredRefreshToken();\n        }\n      });\n    }\n  }\n  AsmAuthHttpHeaderService.ɵfac = function AsmAuthHttpHeaderService_Factory(t) {\n    return new (t || AsmAuthHttpHeaderService)(i0.ɵɵinject(i1$1.AuthService), i0.ɵɵinject(i1$1.AuthStorageService), i0.ɵɵinject(CsAgentAuthService), i0.ɵɵinject(i1$1.OAuthLibWrapperService), i0.ɵɵinject(i1$1.RoutingService), i0.ɵɵinject(i1$1.GlobalMessageService), i0.ɵɵinject(i1$1.OccEndpointsService), i0.ɵɵinject(i1$1.AuthRedirectService));\n  };\n  AsmAuthHttpHeaderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmAuthHttpHeaderService,\n    factory: AsmAuthHttpHeaderService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmAuthHttpHeaderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Version of AuthService that is working for both user na CS agent.\n * Overrides AuthService when ASM module is enabled.\n */\nlet AsmAuthService = /*#__PURE__*/(() => {\n  class AsmAuthService extends AuthService {\n    constructor(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, globalMessageService, routingService) {\n      super(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, routingService);\n      this.store = store;\n      this.userIdService = userIdService;\n      this.oAuthLibWrapperService = oAuthLibWrapperService;\n      this.authStorageService = authStorageService;\n      this.authRedirectService = authRedirectService;\n      this.globalMessageService = globalMessageService;\n      this.routingService = routingService;\n    }\n    canUserLogin() {\n      let tokenTarget;\n      let token;\n      this.authStorageService.getToken().subscribe(tok => token = tok).unsubscribe();\n      this.authStorageService.getTokenTarget().subscribe(tokTarget => tokenTarget = tokTarget).unsubscribe();\n      return !(Boolean(token === null || token === void 0 ? void 0 : token.access_token) && tokenTarget === TokenTarget.CSAgent);\n    }\n    warnAboutLoggedCSAgent() {\n      this.globalMessageService.add({\n        key: 'asm.auth.agentLoggedInError'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    /**\n     * Loads a new user token with Resource Owner Password Flow when CS agent is not logged in.\n     * @param userId\n     * @param password\n     */\n    loginWithCredentials(userId, password) {\n      const _super = Object.create(null, {\n        loginWithCredentials: {\n          get: () => super.loginWithCredentials\n        }\n      });\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.canUserLogin()) {\n          yield _super.loginWithCredentials.call(this, userId, password);\n        } else {\n          this.warnAboutLoggedCSAgent();\n        }\n      });\n    }\n    /**\n     * Initialize Implicit/Authorization Code flow by redirecting to OAuth server when CS agent is not logged in.\n     */\n    loginWithRedirect() {\n      if (this.canUserLogin()) {\n        super.loginWithRedirect();\n        return true;\n      } else {\n        this.warnAboutLoggedCSAgent();\n        return false;\n      }\n    }\n    /**\n     * Revokes tokens and clears state for logged user (tokens, userId).\n     * To perform logout it is best to use `logout` method. Use this method with caution.\n     */\n    coreLogout() {\n      return this.userIdService.isEmulated().pipe(take(1), switchMap(isEmulated => {\n        if (isEmulated) {\n          this.authStorageService.clearEmulatedUserToken();\n          this.userIdService.clearUserId();\n          this.store.dispatch(new AuthActions.Logout());\n          return of(true);\n        } else {\n          return from(super.coreLogout());\n        }\n      })).toPromise();\n    }\n    /**\n     * Returns `true` if user is logged in or being emulated.\n     */\n    isUserLoggedIn() {\n      return combineLatest([this.authStorageService.getToken(), this.userIdService.isEmulated(), this.authStorageService.getTokenTarget()]).pipe(map(([token, isEmulated, tokenTarget]) => Boolean(token === null || token === void 0 ? void 0 : token.access_token) && (tokenTarget === TokenTarget.User || tokenTarget === TokenTarget.CSAgent && isEmulated)));\n    }\n  }\n  AsmAuthService.ɵfac = function AsmAuthService_Factory(t) {\n    return new (t || AsmAuthService)(i0.ɵɵinject(i3$1.Store), i0.ɵɵinject(i1$1.UserIdService), i0.ɵɵinject(i1$1.OAuthLibWrapperService), i0.ɵɵinject(AsmAuthStorageService), i0.ɵɵinject(i1$1.AuthRedirectService), i0.ɵɵinject(i1$1.GlobalMessageService), i0.ɵɵinject(i1$1.RoutingService));\n  };\n  AsmAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmAuthService,\n    factory: AsmAuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmAuthService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AsmRootModule = /*#__PURE__*/(() => {\n  class AsmRootModule {}\n  AsmRootModule.ɵfac = function AsmRootModule_Factory(t) {\n    return new (t || AsmRootModule)();\n  };\n  AsmRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AsmRootModule\n  });\n  AsmRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: AuthStorageService,\n      useExisting: AsmAuthStorageService\n    }, {\n      provide: AuthService,\n      useExisting: AsmAuthService\n    }, {\n      provide: AuthHttpHeaderService,\n      useExisting: AsmAuthHttpHeaderService\n    }],\n    imports: [[AsmLoaderModule]]\n  });\n  return AsmRootModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ASM_FEATURE = 'asm';\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ASM_ENABLED_LOCAL_STORAGE_KEY, ASM_FEATURE, AsmAuthHttpHeaderService, AsmAuthService, AsmAuthStorageService, AsmEnablerService, AsmLoaderModule, AsmRootModule, CsAgentAuthService, TokenTarget, asmFactory };\n//# sourceMappingURL=spartacus-asm-root.js.map","map":null,"metadata":{},"sourceType":"module"}