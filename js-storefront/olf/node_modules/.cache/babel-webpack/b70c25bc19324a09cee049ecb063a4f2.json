{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { inject, Injectable, InjectFlags, InjectionToken, isDevMode, PLATFORM_ID, Inject, Optional, NgModule, APP_INITIALIZER, Directive, Input, NgModuleFactory, Pipe } from '@angular/core';\nimport * as i1$2 from '@ngrx/store';\nimport { createFeatureSelector, createSelector, select, INIT, META_REDUCERS, StoreModule, combineReducers } from '@ngrx/store';\nimport { ReplaySubject, of, fromEvent, BehaviorSubject, iif, combineLatest, queueScheduler, throwError, Subscription, Observable, Subject, using, EMPTY, defer, from, zip, timer, asapScheduler, forkJoin, merge, isObservable } from 'rxjs';\nimport { take, map, debounceTime, startWith, distinctUntilChanged, filter, shareReplay, withLatestFrom, tap, switchMap, observeOn, catchError, exhaustMap, mapTo, share, pairwise, skipWhile, concatMap, mergeMap, publishReplay, switchMapTo, scan, skip, bufferCount, groupBy, distinctUntilKeyChanged, debounce, retry, finalize, pluck, audit, delay, takeUntil } from 'rxjs/operators';\nimport { __awaiter, __decorate, __rest } from 'tslib';\nimport * as i1 from 'angular-oauth2-oidc';\nimport { OAuthStorage, OAuthModule } from 'angular-oauth2-oidc';\nimport * as i6 from '@angular/common';\nimport { isPlatformBrowser, DOCUMENT, isPlatformServer, CommonModule, LOCATION_INITIALIZED, Location, DatePipe, getLocaleId, DecimalPipe } from '@angular/common';\nimport * as i1$1 from '@angular/router';\nimport { PRIMARY_OUTLET, NavigationEnd, DefaultUrlSerializer, Router, NavigationStart, NavigationError, NavigationCancel, UrlSerializer, RouterModule } from '@angular/router';\nimport * as i1$3 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HTTP_INTERCEPTORS, HttpClientModule, HttpResponse, HttpClient } from '@angular/common/http';\nimport * as i1$4 from '@ngrx/effects';\nimport { ofType, Effect, EffectsModule, createEffect } from '@ngrx/effects';\nimport { makeStateKey, TransferState, Meta } from '@angular/platform-browser';\nimport * as fromNgrxRouter from '@ngrx/router-store';\nimport { RouterStateSerializer, StoreRouterConnectingModule } from '@ngrx/router-store';\nimport i18nextHttpBackend from 'i18next-http-backend';\nimport i18next from 'i18next';\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction deepMerge(target = {}, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift() || {};\n  if (isObject(source)) {\n    for (const key in source) {\n      if (source[key] instanceof Date) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key] || !isObject(target[key])) {\n          target[key] = {};\n        }\n        deepMerge(target[key], source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return deepMerge(target, ...sources);\n}\nfunction configFactory() {\n  return deepMerge({}, inject(DefaultConfig), inject(RootConfig));\n}\n/**\n * Global Configuration, can be used to inject configuration to any part of the app\n */\nlet Config = /*#__PURE__*/(() => {\n  class Config {}\n  Config.ɵfac = function Config_Factory(t) {\n    return new (t || Config)();\n  };\n  Config.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Config,\n    factory: function () {\n      return configFactory();\n    },\n    providedIn: 'root'\n  });\n  return Config;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction defaultConfigFactory() {\n  var _a;\n  return deepMerge({}, ...((_a = inject(DefaultConfigChunk, InjectFlags.Optional)) !== null && _a !== void 0 ? _a : []));\n}\n/**\n * Default Configuration token, used to build Global Configuration, built from DefaultConfigChunks\n */\nconst DefaultConfig = new InjectionToken('DefaultConfiguration', {\n  providedIn: 'root',\n  factory: defaultConfigFactory\n});\nfunction rootConfigFactory() {\n  var _a;\n  return deepMerge({}, ...((_a = inject(ConfigChunk, InjectFlags.Optional)) !== null && _a !== void 0 ? _a : []));\n}\n/**\n * Root Configuration token, used to build Global Configuration, built from ConfigChunks\n */\nconst RootConfig = new InjectionToken('RootConfiguration', {\n  providedIn: 'root',\n  factory: rootConfigFactory\n});\n/**\n * Config chunk token, can be used to provide configuration chunk and contribute to the global configuration object.\n * Should not be used directly, use `provideConfig` or import `ConfigModule.withConfig` instead.\n */\nconst ConfigChunk = new InjectionToken('ConfigurationChunk');\n/**\n * Config chunk token, can be used to provide configuration chunk and contribute to the default configuration.\n * Should not be used directly, use `provideDefaultConfig` or `provideDefaultConfigFactory` instead.\n *\n * General rule is, that all config provided in libraries should be provided as default config.\n */\nconst DefaultConfigChunk = new InjectionToken('DefaultConfigurationChunk');\n\n/**\n * Helper function to provide configuration chunk using ConfigChunk token\n *\n * To provide default configuration in libraries provideDefaultConfig should be used instead.\n *\n * @param config Config object to merge with the global configuration\n */\nfunction provideConfig(config = {}, defaultConfig = false) {\n  return {\n    provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,\n    useValue: config,\n    multi: true\n  };\n}\n/**\n * Helper function to provide configuration with factory function, using ConfigChunk token\n *\n * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.\n *\n * @param configFactory Factory Function that will generate config object\n * @param deps Optional dependencies to a factory function\n */\nfunction provideConfigFactory(configFactory, deps, defaultConfig = false) {\n  return {\n    provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,\n    useFactory: configFactory,\n    multi: true,\n    deps: deps\n  };\n}\n/**\n * Helper function to provide default configuration chunk using DefaultConfigChunk token\n *\n * @param config Config object to merge with the default configuration\n */\nfunction provideDefaultConfig(config = {}) {\n  return {\n    provide: DefaultConfigChunk,\n    useValue: config,\n    multi: true\n  };\n}\n/**\n * Helper function to provide default configuration with factory function, using DefaultConfigChunk token\n *\n * @param configFactory Factory Function that will generate config object\n * @param deps Optional dependencies to a factory function\n */\nfunction provideDefaultConfigFactory(configFactory, deps) {\n  return {\n    provide: DefaultConfigChunk,\n    useFactory: configFactory,\n    multi: true,\n    deps: deps\n  };\n}\nconst defaultAnonymousConsentsConfig = {\n  anonymousConsents: {\n    registerConsent: 'MARKETING_NEWSLETTER',\n    showLegalDescriptionInDialog: true,\n    requiredConsents: [],\n    consentManagementPage: {\n      showAnonymousConsents: true,\n      hideConsents: []\n    }\n  }\n};\nvar CountryType = /*#__PURE__*/(() => {\n  (function (CountryType) {\n    CountryType[\"BILLING\"] = \"BILLING\";\n    CountryType[\"SHIPPING\"] = \"SHIPPING\";\n  })(CountryType || (CountryType = {}));\n  return CountryType;\n})();\nvar PromotionLocation = /*#__PURE__*/(() => {\n  (function (PromotionLocation) {\n    PromotionLocation[\"ActiveCart\"] = \"CART\";\n    PromotionLocation[\"Checkout\"] = \"CHECKOUT\";\n    PromotionLocation[\"Order\"] = \"ORDER\";\n    PromotionLocation[\"SaveForLater\"] = \"SAVE_FOR_LATER\";\n    PromotionLocation[\"SavedCart\"] = \"SAVED_CART\";\n  })(PromotionLocation || (PromotionLocation = {}));\n  return PromotionLocation;\n})();\nvar B2BPaymentTypeEnum = /*#__PURE__*/(() => {\n  (function (B2BPaymentTypeEnum) {\n    B2BPaymentTypeEnum[\"ACCOUNT_PAYMENT\"] = \"ACCOUNT\";\n    B2BPaymentTypeEnum[\"CARD_PAYMENT\"] = \"CARD\";\n  })(B2BPaymentTypeEnum || (B2BPaymentTypeEnum = {}));\n  return B2BPaymentTypeEnum;\n})();\nvar CartValidationStatusCode = /*#__PURE__*/(() => {\n  (function (CartValidationStatusCode) {\n    CartValidationStatusCode[\"NO_STOCK\"] = \"noStock\";\n    CartValidationStatusCode[\"LOW_STOCK\"] = \"lowStock\";\n    CartValidationStatusCode[\"REVIEW_CONFIGURATION\"] = \"reviewConfiguration\";\n    CartValidationStatusCode[\"PRICING_ERROR\"] = \"pricingError\";\n    CartValidationStatusCode[\"UNRESOLVABLE_ISSUES\"] = \"unresolvableIssues\";\n  })(CartValidationStatusCode || (CartValidationStatusCode = {}));\n  return CartValidationStatusCode;\n})();\nvar PageType = /*#__PURE__*/(() => {\n  (function (PageType) {\n    PageType[\"CONTENT_PAGE\"] = \"ContentPage\";\n    PageType[\"PRODUCT_PAGE\"] = \"ProductPage\";\n    PageType[\"CATEGORY_PAGE\"] = \"CategoryPage\";\n    PageType[\"CATALOG_PAGE\"] = \"CatalogPage\";\n  })(PageType || (PageType = {}));\n  return PageType;\n})();\nvar CmsBannerCarouselEffect = /*#__PURE__*/(() => {\n  (function (CmsBannerCarouselEffect) {\n    CmsBannerCarouselEffect[\"FADE\"] = \"FADE\";\n    CmsBannerCarouselEffect[\"ZOOM\"] = \"ZOOM\";\n    CmsBannerCarouselEffect[\"CURTAIN\"] = \"CURTAINX\";\n    CmsBannerCarouselEffect[\"TURNDOWN\"] = \"TURNDOWN\";\n  })(CmsBannerCarouselEffect || (CmsBannerCarouselEffect = {}));\n  return CmsBannerCarouselEffect;\n})();\nvar ANONYMOUS_CONSENT_STATUS = /*#__PURE__*/(() => {\n  (function (ANONYMOUS_CONSENT_STATUS) {\n    ANONYMOUS_CONSENT_STATUS[\"GIVEN\"] = \"GIVEN\";\n    ANONYMOUS_CONSENT_STATUS[\"WITHDRAWN\"] = \"WITHDRAWN\";\n  })(ANONYMOUS_CONSENT_STATUS || (ANONYMOUS_CONSENT_STATUS = {}));\n  return ANONYMOUS_CONSENT_STATUS;\n})();\nconst ANONYMOUS_CONSENTS_HEADER = 'X-Anonymous-Consents';\nvar ImageType = /*#__PURE__*/(() => {\n  (function (ImageType) {\n    ImageType[\"PRIMARY\"] = \"PRIMARY\";\n    ImageType[\"GALLERY\"] = \"GALLERY\";\n  })(ImageType || (ImageType = {}));\n  return ImageType;\n})();\nclass HttpErrorModel {}\nvar B2BUserRole = /*#__PURE__*/(() => {\n  (function (B2BUserRole) {\n    B2BUserRole[\"ADMIN\"] = \"b2badmingroup\";\n    B2BUserRole[\"CUSTOMER\"] = \"b2bcustomergroup\";\n    B2BUserRole[\"MANAGER\"] = \"b2bmanagergroup\";\n    B2BUserRole[\"APPROVER\"] = \"b2bapprovergroup\";\n  })(B2BUserRole || (B2BUserRole = {}));\n  return B2BUserRole;\n})();\nvar NotificationType = /*#__PURE__*/(() => {\n  (function (NotificationType) {\n    NotificationType[\"BACK_IN_STOCK\"] = \"BACK_IN_STOCK\";\n  })(NotificationType || (NotificationType = {}));\n  return NotificationType;\n})();\nvar VariantType = /*#__PURE__*/(() => {\n  (function (VariantType) {\n    VariantType[\"SIZE\"] = \"ApparelSizeVariantProduct\";\n    VariantType[\"STYLE\"] = \"ApparelStyleVariantProduct\";\n    VariantType[\"COLOR\"] = \"ElectronicsColorVariantProduct\";\n  })(VariantType || (VariantType = {}));\n  return VariantType;\n})();\nvar PriceType = /*#__PURE__*/(() => {\n  (function (PriceType) {\n    PriceType[\"BUY\"] = \"BUY\";\n    PriceType[\"FROM\"] = \"FROM\";\n  })(PriceType || (PriceType = {}));\n  return PriceType;\n})();\nvar VariantQualifier = /*#__PURE__*/(() => {\n  (function (VariantQualifier) {\n    VariantQualifier[\"SIZE\"] = \"size\";\n    VariantQualifier[\"STYLE\"] = \"style\";\n    VariantQualifier[\"COLOR\"] = \"color\";\n    VariantQualifier[\"THUMBNAIL\"] = \"thumbnail\";\n    VariantQualifier[\"PRODUCT\"] = \"product\";\n    VariantQualifier[\"ROLLUP_PROPERTY\"] = \"rollupProperty\";\n  })(VariantQualifier || (VariantQualifier = {}));\n  return VariantQualifier;\n})();\nvar DaysOfWeek = /*#__PURE__*/(() => {\n  (function (DaysOfWeek) {\n    DaysOfWeek[\"MONDAY\"] = \"MONDAY\";\n    DaysOfWeek[\"TUESDAY\"] = \"TUESDAY\";\n    DaysOfWeek[\"WEDNESDAY\"] = \"WEDNESDAY\";\n    DaysOfWeek[\"THURSDAY\"] = \"THURSDAY\";\n    DaysOfWeek[\"FRIDAY\"] = \"FRIDAY\";\n    DaysOfWeek[\"SATURDAY\"] = \"SATURDAY\";\n    DaysOfWeek[\"SUNDAY\"] = \"SUNDAY\";\n  })(DaysOfWeek || (DaysOfWeek = {}));\n  return DaysOfWeek;\n})();\nconst recurrencePeriod = {\n  DAILY: 'DAILY',\n  WEEKLY: 'WEEKLY',\n  MONTHLY: 'MONTHLY'\n};\nvar ORDER_TYPE = /*#__PURE__*/(() => {\n  (function (ORDER_TYPE) {\n    ORDER_TYPE[\"PLACE_ORDER\"] = \"PLACE_ORDER\";\n    ORDER_TYPE[\"SCHEDULE_REPLENISHMENT_ORDER\"] = \"SCHEDULE_REPLENISHMENT_ORDER\";\n  })(ORDER_TYPE || (ORDER_TYPE = {}));\n  return ORDER_TYPE;\n})();\nconst ENTITY_REMOVE_ACTION = '[ENTITY] REMOVE';\nconst ENTITY_REMOVE_ALL_ACTION = '[ENTITY] REMOVE ALL';\nfunction entityMeta(type, id) {\n  return {\n    entityType: type,\n    entityId: id\n  };\n}\nfunction entityRemoveMeta(type, id) {\n  return {\n    entityId: id,\n    entityType: type,\n    entityRemove: true\n  };\n}\nfunction entityRemoveAllMeta(type) {\n  return {\n    entityId: null,\n    entityType: type,\n    entityRemove: true\n  };\n}\nclass EntityRemoveAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_REMOVE_ACTION;\n    this.meta = entityRemoveMeta(entityType, id);\n  }\n}\nclass EntityRemoveAllAction {\n  constructor(entityType) {\n    this.type = ENTITY_REMOVE_ALL_ACTION;\n    this.meta = entityRemoveAllMeta(entityType);\n  }\n}\nconst LOADER_LOAD_ACTION = '[LOADER] LOAD';\nconst LOADER_FAIL_ACTION = '[LOADER] FAIL';\nconst LOADER_SUCCESS_ACTION = '[LOADER] SUCCESS';\nconst LOADER_RESET_ACTION = '[LOADER] RESET';\nfunction loadMeta(entityType) {\n  return {\n    entityType: entityType,\n    loader: {\n      load: true\n    }\n  };\n}\nfunction failMeta(entityType, error) {\n  return {\n    entityType: entityType,\n    loader: {\n      error: error ? error : true\n    }\n  };\n}\nfunction successMeta(entityType) {\n  return {\n    entityType: entityType,\n    loader: {\n      success: true\n    }\n  };\n}\nfunction resetMeta(entityType) {\n  return {\n    entityType: entityType,\n    loader: {}\n  };\n}\nclass LoaderLoadAction {\n  constructor(entityType) {\n    this.type = LOADER_LOAD_ACTION;\n    this.meta = loadMeta(entityType);\n  }\n}\nclass LoaderFailAction {\n  constructor(entityType, error) {\n    this.type = LOADER_FAIL_ACTION;\n    this.meta = failMeta(entityType, error);\n  }\n}\nclass LoaderSuccessAction {\n  constructor(entityType) {\n    this.type = LOADER_SUCCESS_ACTION;\n    this.meta = successMeta(entityType);\n  }\n}\nclass LoaderResetAction {\n  constructor(entityType) {\n    this.type = LOADER_RESET_ACTION;\n    this.meta = resetMeta(entityType);\n  }\n}\nconst ENTITY_LOAD_ACTION = '[ENTITY] LOAD';\nconst ENTITY_FAIL_ACTION = '[ENTITY] LOAD FAIL';\nconst ENTITY_SUCCESS_ACTION = '[ENTITY] LOAD SUCCESS';\nconst ENTITY_RESET_ACTION = '[ENTITY] RESET';\nfunction entityLoadMeta(entityType, id) {\n  return Object.assign(Object.assign({}, loadMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityFailMeta(entityType, id, error) {\n  return Object.assign(Object.assign({}, failMeta(entityType, error)), entityMeta(entityType, id));\n}\nfunction entitySuccessMeta(entityType, id) {\n  return Object.assign(Object.assign({}, successMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityResetMeta(entityType, id) {\n  return Object.assign(Object.assign({}, resetMeta(entityType)), entityMeta(entityType, id));\n}\nclass EntityLoadAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_LOAD_ACTION;\n    this.meta = entityLoadMeta(entityType, id);\n  }\n}\nclass EntityFailAction {\n  constructor(entityType, id, error) {\n    this.type = ENTITY_FAIL_ACTION;\n    this.meta = entityFailMeta(entityType, id, error);\n  }\n}\nclass EntitySuccessAction {\n  constructor(entityType, id, payload) {\n    this.payload = payload;\n    this.type = ENTITY_SUCCESS_ACTION;\n    this.meta = entitySuccessMeta(entityType, id);\n  }\n}\nclass EntityLoaderResetAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_RESET_ACTION;\n    this.meta = entityResetMeta(entityType, id);\n  }\n}\nconst initialLoaderState = {\n  loading: false,\n  error: false,\n  success: false,\n  value: undefined\n};\n/**\n * Higher order reducer that adds generic loading flag to chunk of the state\n *\n * Utilizes \"loader\" meta field of actions to set specific flags for specific\n * action (LOAD, SUCCESS, FAIL, RESET)\n */\nfunction loaderReducer(entityType, reducer) {\n  return (state = initialLoaderState, action) => {\n    if (action.meta && action.meta.loader && action.meta.entityType === entityType) {\n      const entity = action.meta.loader;\n      if (entity.load) {\n        return Object.assign(Object.assign({}, state), {\n          loading: true,\n          value: reducer ? reducer(state.value, action) : state.value\n        });\n      } else if (entity.error) {\n        return Object.assign(Object.assign({}, state), {\n          loading: false,\n          error: true,\n          success: false,\n          value: reducer ? reducer(state.value, action) : undefined\n        });\n      } else if (entity.success) {\n        return Object.assign(Object.assign({}, state), {\n          value: reducer ? reducer(state.value, action) : action.payload,\n          loading: false,\n          error: false,\n          success: true\n        });\n      } else {\n        // reset state action\n        return Object.assign(Object.assign({}, initialLoaderState), {\n          value: reducer ? reducer(initialLoaderState.value, action) : initialLoaderState.value\n        });\n      }\n    }\n    if (reducer) {\n      const newValue = reducer(state.value, action);\n      if (newValue !== state.value) {\n        return Object.assign(Object.assign({}, state), {\n          value: newValue\n        });\n      }\n    }\n    return state;\n  };\n}\nfunction loaderValueSelector(state) {\n  return state.value;\n}\nfunction loaderLoadingSelector(state) {\n  return state.loading;\n}\nfunction loaderErrorSelector(state) {\n  return state.error;\n}\nfunction loaderSuccessSelector(state) {\n  return state.success;\n}\nfunction entityLoaderStateSelector(state, id) {\n  return state.entities[id] || initialLoaderState;\n}\nfunction entityValueSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return loaderValueSelector(entityState);\n}\nfunction entityLoadingSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return loaderLoadingSelector(entityState);\n}\nfunction entityErrorSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return loaderErrorSelector(entityState);\n}\nfunction entitySuccessSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return loaderSuccessSelector(entityState);\n}\nconst initialEntityState = {\n  entities: {}\n};\n/**\n * Higher order reducer for reusing reducer logic for multiple entities\n *\n * Utilizes entityId meta field to target entity by id in actions\n */\nfunction entityReducer(entityType, reducer) {\n  return (state = initialEntityState, action) => {\n    let ids;\n    let partitionPayload = false;\n    if (action.meta && action.meta.entityType === entityType && action.meta.entityId !== undefined) {\n      ids = [].concat(action.meta.entityId);\n      // remove selected entities\n      if (action.meta.entityRemove) {\n        if (action.meta.entityId === null) {\n          return initialEntityState;\n        } else {\n          let removed = false;\n          const newEntities = Object.keys(state.entities).reduce((acc, cur) => {\n            if (ids.includes(cur)) {\n              removed = true;\n            } else {\n              acc[cur] = state.entities[cur];\n            }\n            return acc;\n          }, {});\n          return removed ? {\n            entities: newEntities\n          } : state;\n        }\n      }\n      partitionPayload = Array.isArray(action.meta.entityId) && Array.isArray(action.payload);\n    } else {\n      ids = Object.keys(state.entities);\n    }\n    const entityUpdates = {};\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const subAction = partitionPayload ? Object.assign(Object.assign({}, action), {\n        payload: action.payload[i]\n      }) : action;\n      const newState = reducer(state.entities[id], subAction);\n      if (newState) {\n        entityUpdates[id] = newState;\n      }\n    }\n    if (Object.keys(entityUpdates).length > 0) {\n      return Object.assign(Object.assign({}, state), {\n        entities: Object.assign(Object.assign({}, state.entities), entityUpdates)\n      });\n    }\n    return state;\n  };\n}\n\n/**\n * Higher order reducer that wraps LoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic loading flags\n */\nfunction entityLoaderReducer(entityType, reducer) {\n  return entityReducer(entityType, loaderReducer(entityType, reducer));\n}\nconst PROCESSES_INCREMENT_ACTION = '[PROCESSES LOADER] INCREMENT';\nconst PROCESSES_DECREMENT_ACTION = '[PROCESSES LOADER] DECREMENT';\nconst PROCESSES_LOADER_RESET_ACTION = '[PROCESSES LOADER] RESET';\nfunction processesIncrementMeta(entityType) {\n  return {\n    entityType: entityType,\n    loader: undefined,\n    processesCountDiff: 1\n  };\n}\nfunction processesDecrementMeta(entityType) {\n  return {\n    entityType: entityType,\n    loader: undefined,\n    processesCountDiff: -1\n  };\n}\nfunction processesLoaderResetMeta(entityType) {\n  // processes reset action is a reset action for loader reducer, but not the other way around\n  return Object.assign(Object.assign({}, resetMeta(entityType)), {\n    processesCountDiff: null\n  });\n}\nclass ProcessesLoaderResetAction {\n  constructor(entityType) {\n    this.type = PROCESSES_LOADER_RESET_ACTION;\n    this.meta = processesLoaderResetMeta(entityType);\n  }\n}\nclass ProcessesIncrementAction {\n  constructor(entityType) {\n    this.type = PROCESSES_INCREMENT_ACTION;\n    this.meta = processesIncrementMeta(entityType);\n  }\n}\nclass ProcessesDecrementAction {\n  constructor(entityType) {\n    this.type = PROCESSES_DECREMENT_ACTION;\n    this.meta = processesDecrementMeta(entityType);\n  }\n}\nconst ENTITY_PROCESSES_LOADER_RESET_ACTION = '[ENTITY] PROCESSES LOADER RESET';\nconst ENTITY_PROCESSES_INCREMENT_ACTION = '[ENTITY] PROCESSES INCREMENT';\nconst ENTITY_PROCESSES_DECREMENT_ACTION = '[ENTITY] PROCESSES DECREMENT';\nfunction entityProcessesLoaderResetMeta(entityType, id) {\n  return Object.assign(Object.assign({}, processesLoaderResetMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityProcessesIncrementMeta(entityType, id) {\n  return Object.assign(Object.assign({}, processesIncrementMeta(entityType)), entityMeta(entityType, id));\n}\nfunction entityProcessesDecrementMeta(entityType, id) {\n  return Object.assign(Object.assign({}, processesDecrementMeta(entityType)), entityMeta(entityType, id));\n}\nclass EntityProcessesLoaderResetAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_PROCESSES_LOADER_RESET_ACTION;\n    this.meta = entityProcessesLoaderResetMeta(entityType, id);\n  }\n}\nclass EntityProcessesIncrementAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_PROCESSES_INCREMENT_ACTION;\n    this.meta = entityProcessesIncrementMeta(entityType, id);\n  }\n}\nclass EntityProcessesDecrementAction {\n  constructor(entityType, id) {\n    this.type = ENTITY_PROCESSES_DECREMENT_ACTION;\n    this.meta = entityProcessesDecrementMeta(entityType, id);\n  }\n}\nfunction isStableSelector(state) {\n  return state.processesCount === 0 && !state.loading;\n}\nfunction hasPendingProcessesSelector(state) {\n  return state.processesCount > 0;\n}\nconst initialProcessesState = {\n  processesCount: 0\n};\n/**\n * Higher order reducer that adds processes count\n */\nfunction processesLoaderReducer(entityType, reducer) {\n  return (state = Object.assign(Object.assign({}, initialProcessesState), initialLoaderState), action) => {\n    const loaderState = loaderReducer(entityType, reducer)(state, action);\n    if (action.meta && action.meta.entityType === entityType) {\n      const processesCountDiff = action.meta.processesCountDiff;\n      if (isDevMode() && state.processesCount + processesCountDiff < 0) {\n        console.error(`Action '${action.type}' sets processesCount to value < 0!\\n` + 'Make sure to keep processesCount in sync.\\n' + 'There should always be only one decrement action for each increment action.\\n' + \"Make sure that you don't reset state in between those actions.\\n\", action);\n      }\n      if (processesCountDiff) {\n        return Object.assign(Object.assign({}, loaderState), {\n          processesCount: state.processesCount ? state.processesCount + processesCountDiff : processesCountDiff\n        });\n      } else if (processesCountDiff === null) {\n        // reset action\n        return Object.assign(Object.assign({}, loaderState), initialProcessesState);\n      }\n    }\n    return loaderState;\n  };\n}\nconst initialProcessesLoaderState = Object.assign(Object.assign({}, initialLoaderState), initialProcessesState);\nfunction entityHasPendingProcessesSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return hasPendingProcessesSelector(entityState);\n}\nfunction entityIsStableSelector(state, id) {\n  const entityState = entityLoaderStateSelector(state, id);\n  return isStableSelector(entityState);\n}\nfunction entityProcessesLoaderStateSelector(state, id) {\n  return state.entities[id] || initialProcessesLoaderState;\n}\n\n/**\n * Higher order reducer that wraps ProcessesLoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic processesCount flag\n */\nfunction entityProcessesLoaderReducer(entityType, reducer) {\n  return entityReducer(entityType, processesLoaderReducer(entityType, reducer));\n}\nfunction entitySelector(state, id) {\n  return state.entities[id] || undefined;\n}\nconst OBJECT_SEPARATOR = '.';\nfunction getStateSliceValue(keys, state) {\n  return keys.split(OBJECT_SEPARATOR).reduce((previous, current) => previous ? previous[current] : undefined, state);\n}\nfunction createShellObject(key, excludeKeys, value) {\n  if (!key || !value || Object.keys(value).length === 0) {\n    return {};\n  }\n  const shell = key.split(OBJECT_SEPARATOR).reduceRight((acc, previous) => {\n    return {\n      [previous]: acc\n    };\n  }, value);\n  return handleExclusions(key, excludeKeys, shell);\n}\nfunction getStateSlice(keys, excludeKeys, state) {\n  if (keys && keys.length === 0) {\n    return {};\n  }\n  let stateSlices = {};\n  for (const currentKey of keys) {\n    const stateValue = getStateSliceValue(currentKey, state);\n    const shell = createShellObject(currentKey, excludeKeys, stateValue);\n    stateSlices = deepMerge(stateSlices, shell);\n  }\n  return stateSlices;\n}\nfunction handleExclusions(key, excludeKeys, value) {\n  const exclusionKeys = getExclusionKeys(key, excludeKeys);\n  if (exclusionKeys.length === 0) {\n    return value;\n  }\n  const finalValue = deepMerge({}, value);\n  for (const currentExclusionKey of exclusionKeys) {\n    const exclusionChunksSplit = currentExclusionKey.split(OBJECT_SEPARATOR);\n    let nestedTemp = finalValue;\n    for (let i = 0; i < exclusionChunksSplit.length; i++) {\n      const currentChunk = exclusionChunksSplit[i];\n      // last iteration\n      if (i === exclusionChunksSplit.length - 1) {\n        if (nestedTemp && nestedTemp[currentChunk]) {\n          delete nestedTemp[currentChunk];\n        }\n      } else {\n        nestedTemp = nestedTemp[currentChunk];\n      }\n    }\n  }\n  return finalValue;\n}\nfunction getExclusionKeys(key, excludeKeys) {\n  if (!key || !excludeKeys) {\n    return [];\n  }\n  const exclusionKeys = [];\n  for (const exclusionKey of excludeKeys) {\n    if (exclusionKey.includes(key)) {\n      exclusionKeys.push(exclusionKey);\n    }\n  }\n  return exclusionKeys;\n}\nfunction filterKeysByType(keys, type) {\n  if (!keys) {\n    return [];\n  }\n  return Object.keys(keys).filter(key => keys[key] === type);\n}\nconst ALL = 'all';\nfunction serializeSearchConfig(config, id) {\n  var _a, _b, _c;\n  return `${id !== null && id !== void 0 ? id : ''}?pageSize=${(_a = config.pageSize) !== null && _a !== void 0 ? _a : ''}&currentPage=${(_b = config.currentPage) !== null && _b !== void 0 ? _b : ''}&sort=${(_c = config.sort) !== null && _c !== void 0 ? _c : ''}`;\n}\nfunction denormalizeSearch(state, params) {\n  return denormalizeCustomB2BSearch(state.list, state.entities, params);\n}\nfunction denormalizeCustomB2BSearch(list, entities, params, id) {\n  const serializedList = entityLoaderStateSelector(list, params ? serializeSearchConfig(params, id) : id !== null && id !== void 0 ? id : ALL);\n  if (!serializedList.value || !serializedList.value.ids) {\n    return serializedList;\n  }\n  const res = Object.assign({}, serializedList, {\n    value: {\n      values: serializedList.value.ids.map(code => entityLoaderStateSelector(entities, code).value)\n    }\n  });\n  if (params) {\n    res.value.pagination = serializedList.value.pagination;\n    res.value.sorts = serializedList.value.sorts;\n  }\n  return res;\n}\nfunction normalizeListPage(list, id) {\n  const values = (list === null || list === void 0 ? void 0 : list.values) || [];\n  const page = {\n    ids: values.map(data => data[id])\n  };\n  if (list.pagination) {\n    page.pagination = list.pagination;\n  }\n  if (list.sorts) {\n    page.sorts = list.sorts;\n  }\n  return {\n    values,\n    page\n  };\n}\nfunction serializeParams(params, searchConfig) {\n  return [params, serializeSearchConfig(searchConfig)].toString();\n}\nvar utilsGroup = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getStateSlice: getStateSlice,\n  ENTITY_LOAD_ACTION: ENTITY_LOAD_ACTION,\n  ENTITY_FAIL_ACTION: ENTITY_FAIL_ACTION,\n  ENTITY_SUCCESS_ACTION: ENTITY_SUCCESS_ACTION,\n  ENTITY_RESET_ACTION: ENTITY_RESET_ACTION,\n  entityLoadMeta: entityLoadMeta,\n  entityFailMeta: entityFailMeta,\n  entitySuccessMeta: entitySuccessMeta,\n  entityResetMeta: entityResetMeta,\n  EntityLoadAction: EntityLoadAction,\n  EntityFailAction: EntityFailAction,\n  EntitySuccessAction: EntitySuccessAction,\n  EntityLoaderResetAction: EntityLoaderResetAction,\n  entityLoaderStateSelector: entityLoaderStateSelector,\n  entityValueSelector: entityValueSelector,\n  entityLoadingSelector: entityLoadingSelector,\n  entityErrorSelector: entityErrorSelector,\n  entitySuccessSelector: entitySuccessSelector,\n  entityLoaderReducer: entityLoaderReducer,\n  ENTITY_PROCESSES_LOADER_RESET_ACTION: ENTITY_PROCESSES_LOADER_RESET_ACTION,\n  ENTITY_PROCESSES_INCREMENT_ACTION: ENTITY_PROCESSES_INCREMENT_ACTION,\n  ENTITY_PROCESSES_DECREMENT_ACTION: ENTITY_PROCESSES_DECREMENT_ACTION,\n  entityProcessesLoaderResetMeta: entityProcessesLoaderResetMeta,\n  entityProcessesIncrementMeta: entityProcessesIncrementMeta,\n  entityProcessesDecrementMeta: entityProcessesDecrementMeta,\n  EntityProcessesLoaderResetAction: EntityProcessesLoaderResetAction,\n  EntityProcessesIncrementAction: EntityProcessesIncrementAction,\n  EntityProcessesDecrementAction: EntityProcessesDecrementAction,\n  entityHasPendingProcessesSelector: entityHasPendingProcessesSelector,\n  entityIsStableSelector: entityIsStableSelector,\n  entityProcessesLoaderStateSelector: entityProcessesLoaderStateSelector,\n  entityProcessesLoaderReducer: entityProcessesLoaderReducer,\n  ENTITY_REMOVE_ACTION: ENTITY_REMOVE_ACTION,\n  ENTITY_REMOVE_ALL_ACTION: ENTITY_REMOVE_ALL_ACTION,\n  entityMeta: entityMeta,\n  entityRemoveMeta: entityRemoveMeta,\n  entityRemoveAllMeta: entityRemoveAllMeta,\n  EntityRemoveAction: EntityRemoveAction,\n  EntityRemoveAllAction: EntityRemoveAllAction,\n  entitySelector: entitySelector,\n  initialEntityState: initialEntityState,\n  entityReducer: entityReducer,\n  LOADER_LOAD_ACTION: LOADER_LOAD_ACTION,\n  LOADER_FAIL_ACTION: LOADER_FAIL_ACTION,\n  LOADER_SUCCESS_ACTION: LOADER_SUCCESS_ACTION,\n  LOADER_RESET_ACTION: LOADER_RESET_ACTION,\n  loadMeta: loadMeta,\n  failMeta: failMeta,\n  successMeta: successMeta,\n  resetMeta: resetMeta,\n  LoaderLoadAction: LoaderLoadAction,\n  LoaderFailAction: LoaderFailAction,\n  LoaderSuccessAction: LoaderSuccessAction,\n  LoaderResetAction: LoaderResetAction,\n  loaderValueSelector: loaderValueSelector,\n  loaderLoadingSelector: loaderLoadingSelector,\n  loaderErrorSelector: loaderErrorSelector,\n  loaderSuccessSelector: loaderSuccessSelector,\n  initialLoaderState: initialLoaderState,\n  loaderReducer: loaderReducer,\n  PROCESSES_INCREMENT_ACTION: PROCESSES_INCREMENT_ACTION,\n  PROCESSES_DECREMENT_ACTION: PROCESSES_DECREMENT_ACTION,\n  PROCESSES_LOADER_RESET_ACTION: PROCESSES_LOADER_RESET_ACTION,\n  processesIncrementMeta: processesIncrementMeta,\n  processesDecrementMeta: processesDecrementMeta,\n  processesLoaderResetMeta: processesLoaderResetMeta,\n  ProcessesLoaderResetAction: ProcessesLoaderResetAction,\n  ProcessesIncrementAction: ProcessesIncrementAction,\n  ProcessesDecrementAction: ProcessesDecrementAction,\n  isStableSelector: isStableSelector,\n  hasPendingProcessesSelector: hasPendingProcessesSelector,\n  initialProcessesState: initialProcessesState,\n  processesLoaderReducer: processesLoaderReducer,\n  serializeSearchConfig: serializeSearchConfig,\n  denormalizeSearch: denormalizeSearch,\n  denormalizeCustomB2BSearch: denormalizeCustomB2BSearch,\n  normalizeListPage: normalizeListPage,\n  serializeParams: serializeParams\n});\nconst ANONYMOUS_CONSENTS_STORE_FEATURE = 'anonymous-consents';\nconst ANONYMOUS_CONSENTS = '[Anonymous Consents] Anonymous Consents';\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Load Anonymous Consent Templates';\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS = '[Anonymous Consents] Load Anonymous Consent Templates Success';\nconst LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL = '[Anonymous Consents] Load Anonymous Consent Templates Fail';\nconst RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES = '[Anonymous Consents] Reset Load Anonymous Consent Templates';\nconst GET_ALL_ANONYMOUS_CONSENTS = '[Anonymous Consents] Get All Anonymous Consents';\nconst GET_ANONYMOUS_CONSENT = '[Anonymous Consents] Get Anonymous Consent';\nconst SET_ANONYMOUS_CONSENTS = '[Anonymous Consents] Set Anonymous Consents';\nconst GIVE_ANONYMOUS_CONSENT = '[Anonymous Consents] Give Anonymous Consent';\nconst WITHDRAW_ANONYMOUS_CONSENT = '[Anonymous Consents] Withdraw Anonymous Consent';\nconst TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED = '[Anonymous Consents] Toggle Anonymous Consents Banner Dismissed';\nconst TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED = '[Anonymous Consents] Anonymous Consent Templates Updated';\nconst ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS = '[Anonymous Consents] Check Updated Versions';\nclass LoadAnonymousConsentTemplates extends LoaderLoadAction {\n  constructor() {\n    super(ANONYMOUS_CONSENTS);\n    this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES;\n  }\n}\nclass LoadAnonymousConsentTemplatesSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(ANONYMOUS_CONSENTS);\n    this.payload = payload;\n    this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS;\n  }\n}\nclass LoadAnonymousConsentTemplatesFail extends LoaderFailAction {\n  constructor(payload) {\n    super(ANONYMOUS_CONSENTS, payload);\n    this.type = LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL;\n  }\n}\nclass ResetLoadAnonymousConsentTemplates extends LoaderResetAction {\n  constructor() {\n    super(ANONYMOUS_CONSENTS);\n    this.type = RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES;\n  }\n}\nclass GetAllAnonymousConsents {\n  constructor() {\n    this.type = GET_ALL_ANONYMOUS_CONSENTS;\n  }\n}\nclass GetAnonymousConsent {\n  constructor(templateCode) {\n    this.templateCode = templateCode;\n    this.type = GET_ANONYMOUS_CONSENT;\n  }\n}\nclass SetAnonymousConsents {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = SET_ANONYMOUS_CONSENTS;\n  }\n}\nclass GiveAnonymousConsent {\n  constructor(templateCode) {\n    this.templateCode = templateCode;\n    this.type = GIVE_ANONYMOUS_CONSENT;\n  }\n}\nclass WithdrawAnonymousConsent {\n  constructor(templateCode) {\n    this.templateCode = templateCode;\n    this.type = WITHDRAW_ANONYMOUS_CONSENT;\n  }\n}\nclass ToggleAnonymousConsentsBannerDissmissed {\n  constructor(dismissed) {\n    this.dismissed = dismissed;\n    this.type = TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED;\n  }\n}\nclass ToggleAnonymousConsentTemplatesUpdated {\n  constructor(updated) {\n    this.updated = updated;\n    this.type = TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED;\n  }\n}\nclass AnonymousConsentCheckUpdatedVersions {\n  constructor() {\n    this.type = ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS;\n  }\n}\nvar anonymousConsentsGroup = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_ANONYMOUS_CONSENT_TEMPLATES: LOAD_ANONYMOUS_CONSENT_TEMPLATES,\n  LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS: LOAD_ANONYMOUS_CONSENT_TEMPLATES_SUCCESS,\n  LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL: LOAD_ANONYMOUS_CONSENT_TEMPLATES_FAIL,\n  RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES: RESET_LOAD_ANONYMOUS_CONSENT_TEMPLATES,\n  GET_ALL_ANONYMOUS_CONSENTS: GET_ALL_ANONYMOUS_CONSENTS,\n  GET_ANONYMOUS_CONSENT: GET_ANONYMOUS_CONSENT,\n  SET_ANONYMOUS_CONSENTS: SET_ANONYMOUS_CONSENTS,\n  GIVE_ANONYMOUS_CONSENT: GIVE_ANONYMOUS_CONSENT,\n  WITHDRAW_ANONYMOUS_CONSENT: WITHDRAW_ANONYMOUS_CONSENT,\n  TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED: TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED,\n  TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED: TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED,\n  ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS: ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS,\n  LoadAnonymousConsentTemplates: LoadAnonymousConsentTemplates,\n  LoadAnonymousConsentTemplatesSuccess: LoadAnonymousConsentTemplatesSuccess,\n  LoadAnonymousConsentTemplatesFail: LoadAnonymousConsentTemplatesFail,\n  ResetLoadAnonymousConsentTemplates: ResetLoadAnonymousConsentTemplates,\n  GetAllAnonymousConsents: GetAllAnonymousConsents,\n  GetAnonymousConsent: GetAnonymousConsent,\n  SetAnonymousConsents: SetAnonymousConsents,\n  GiveAnonymousConsent: GiveAnonymousConsent,\n  WithdrawAnonymousConsent: WithdrawAnonymousConsent,\n  ToggleAnonymousConsentsBannerDissmissed: ToggleAnonymousConsentsBannerDissmissed,\n  ToggleAnonymousConsentTemplatesUpdated: ToggleAnonymousConsentTemplatesUpdated,\n  AnonymousConsentCheckUpdatedVersions: AnonymousConsentCheckUpdatedVersions\n});\nconst getAnonymousConsentState = createFeatureSelector(ANONYMOUS_CONSENTS_STORE_FEATURE);\nconst getAnonymousConsentTemplatesState = createSelector(getAnonymousConsentState, state => state.templates);\nconst getAnonymousConsentTemplatesValue = createSelector(getAnonymousConsentTemplatesState, loaderValueSelector);\nconst getAnonymousConsentTemplatesLoading = createSelector(getAnonymousConsentTemplatesState, loaderLoadingSelector);\nconst getAnonymousConsentTemplatesSuccess = createSelector(getAnonymousConsentTemplatesState, loaderSuccessSelector);\nconst getAnonymousConsentTemplatesError = createSelector(getAnonymousConsentTemplatesState, loaderErrorSelector);\nconst getAnonymousConsentTemplate = templateCode => {\n  return createSelector(getAnonymousConsentTemplatesValue, templates => {\n    return templates ? templates.find(template => template.id === templateCode) : null;\n  });\n};\nconst getAnonymousConsentTemplatesUpdate = createSelector(getAnonymousConsentState, state => state.ui.updated);\nconst getAnonymousConsentsBannerDismissed = createSelector(getAnonymousConsentState, state => state.ui.bannerDismissed);\nconst getAnonymousConsents = createSelector(getAnonymousConsentState, state => state.consents);\nconst getAnonymousConsentByTemplateCode = templateCode => createSelector(getAnonymousConsents, consents => consents.find(consent => consent.templateCode === templateCode));\nvar anonymousConsentsGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getAnonymousConsentTemplatesState: getAnonymousConsentTemplatesState,\n  getAnonymousConsentTemplatesValue: getAnonymousConsentTemplatesValue,\n  getAnonymousConsentTemplatesLoading: getAnonymousConsentTemplatesLoading,\n  getAnonymousConsentTemplatesSuccess: getAnonymousConsentTemplatesSuccess,\n  getAnonymousConsentTemplatesError: getAnonymousConsentTemplatesError,\n  getAnonymousConsentTemplate: getAnonymousConsentTemplate,\n  getAnonymousConsentTemplatesUpdate: getAnonymousConsentTemplatesUpdate,\n  getAnonymousConsentsBannerDismissed: getAnonymousConsentsBannerDismissed,\n  getAnonymousConsents: getAnonymousConsents,\n  getAnonymousConsentByTemplateCode: getAnonymousConsentByTemplateCode,\n  getAnonymousConsentState: getAnonymousConsentState\n});\nconst OCC_USER_ID_CURRENT = 'current';\nconst OCC_USER_ID_ANONYMOUS = 'anonymous';\nconst OCC_USER_ID_GUEST = 'guest';\nconst OCC_CART_ID_CURRENT = 'current';\nconst LOGIN = '[Auth] Login';\nconst LOGOUT = '[Auth] Logout';\nclass Login {\n  constructor() {\n    this.type = LOGIN;\n  }\n}\nclass Logout {\n  constructor() {\n    this.type = LOGOUT;\n  }\n}\nvar authGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOGIN: LOGIN,\n  LOGOUT: LOGOUT,\n  Login: Login,\n  Logout: Logout\n});\n\n/**\n * This implementation is OCC specific.\n * Different backend might have completely different need regarding user id.\n * It might not need user id at all and work based on access_token.\n * To implement custom solution provide your own implementation and customize services that use UserIdService\n */\nlet UserIdService = /*#__PURE__*/(() => {\n  class UserIdService {\n    constructor() {\n      this._userId = new ReplaySubject(1);\n    }\n    /**\n     * Sets current user id.\n     *\n     * @param userId\n     */\n    setUserId(userId) {\n      this._userId.next(userId);\n    }\n    /**\n     * This function provides the userId the OCC calls should use, depending\n     * on whether there is an active storefront session or not.\n     *\n     * It returns the userId of the current storefront user or 'anonymous'\n     * in the case there are no signed in user in the storefront.\n     *\n     * The user id of a regular customer session is 'current'. In the case of an\n     * asm customer emulation session, the userId will be the customerId.\n     */\n    getUserId() {\n      return this._userId;\n    }\n    /**\n     * Utility method if you need userId to perform single action (eg. dispatch call to API).\n     *\n     * @param loggedIn Set to true if you want the observable to emit id only for logged in user. Throws in case of anonymous user.\n     *\n     * @returns Observable that emits once and completes with the last userId value.\n     */\n    takeUserId(loggedIn = false) {\n      return this.getUserId().pipe(take(1), map(userId => {\n        if (loggedIn && userId === OCC_USER_ID_ANONYMOUS) {\n          throw new Error('Requested user id for logged user while user is not logged in.');\n        }\n        return userId;\n      }));\n    }\n    /**\n     * Sets user id to the default value for logged out user.\n     */\n    clearUserId() {\n      this.setUserId(OCC_USER_ID_ANONYMOUS);\n    }\n    /**\n     * Checks if the userId is of emulated user type.\n     */\n    isEmulated() {\n      return this.getUserId().pipe(map(userId => userId !== OCC_USER_ID_ANONYMOUS && userId !== OCC_USER_ID_CURRENT));\n    }\n  }\n  UserIdService.ɵfac = function UserIdService_Factory(t) {\n    return new (t || UserIdService)();\n  };\n  UserIdService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserIdService,\n    factory: UserIdService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserIdService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Supported OAuth flows.\n */\nvar OAuthFlow = /*#__PURE__*/(() => {\n  (function (OAuthFlow) {\n    /**\n     * Flow when username and password is passed to the application and then the application through API fetches tokens from OAuth server.\n     */\n    OAuthFlow[OAuthFlow[\"ResourceOwnerPasswordFlow\"] = 0] = \"ResourceOwnerPasswordFlow\";\n    /**\n     * Flow with redirect to OAuth server where user inputs credentials and the are redirected back with token.\n     */\n    OAuthFlow[OAuthFlow[\"ImplicitFlow\"] = 1] = \"ImplicitFlow\";\n    /**\n     * Similar to Implicit flow, but user is redirected with code that need to later exchange through API for a token.\n     */\n    OAuthFlow[OAuthFlow[\"AuthorizationCode\"] = 2] = \"AuthorizationCode\";\n  })(OAuthFlow || (OAuthFlow = {}));\n  return OAuthFlow;\n})();\nlet AuthConfig = /*#__PURE__*/(() => {\n  class AuthConfig {}\n  AuthConfig.ɵfac = function AuthConfig_Factory(t) {\n    return new (t || AuthConfig)();\n  };\n  AuthConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthConfig,\n    factory: function AuthConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || AuthConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return AuthConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SiteContextConfig = /*#__PURE__*/(() => {\n  class SiteContextConfig {}\n  SiteContextConfig.ɵfac = function SiteContextConfig_Factory(t) {\n    return new (t || SiteContextConfig)();\n  };\n  SiteContextConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextConfig,\n    factory: function SiteContextConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || SiteContextConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return SiteContextConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccConfig = /*#__PURE__*/(() => {\n  class OccConfig extends SiteContextConfig {}\n  OccConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵOccConfig_BaseFactory;\n    return function OccConfig_Factory(t) {\n      return (ɵOccConfig_BaseFactory || (ɵOccConfig_BaseFactory = i0.ɵɵgetInheritedFactory(OccConfig)))(t || OccConfig);\n    };\n  }();\n  OccConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccConfig,\n    factory: function OccConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || OccConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return OccConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Utility service on top of the authorization config.\n * Provides handy defaults, when not everything is set in the configuration.\n * Use this service instead of direct configuration.\n */\nlet AuthConfigService = /*#__PURE__*/(() => {\n  class AuthConfigService {\n    constructor(authConfig, occConfig) {\n      this.authConfig = authConfig;\n      this.occConfig = occConfig;\n    }\n    /**\n     * Utility to make access to authentication config easier.\n     */\n    get config() {\n      var _a, _b;\n      return (_b = (_a = this.authConfig) === null || _a === void 0 ? void 0 : _a.authentication) !== null && _b !== void 0 ? _b : {};\n    }\n    /**\n     * Get client_id\n     *\n     * @return client_id\n     */\n    getClientId() {\n      var _a;\n      return (_a = this.config.client_id) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Get client_secret. OAuth server shouldn't require it from web apps (but Hybris OAuth server requires).\n     *\n     * @return client_secret\n     */\n    getClientSecret() {\n      var _a;\n      return (_a = this.config.client_secret) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Returns base url of the authorization server\n     */\n    getBaseUrl() {\n      var _a, _b, _c, _d, _e;\n      return (_a = this.config.baseUrl) !== null && _a !== void 0 ? _a : ((_e = (_d = (_c = (_b = this.occConfig) === null || _b === void 0 ? void 0 : _b.backend) === null || _c === void 0 ? void 0 : _c.occ) === null || _d === void 0 ? void 0 : _d.baseUrl) !== null && _e !== void 0 ? _e : '') + '/authorizationserver';\n    }\n    /**\n     * Returns endpoint for getting the auth token\n     */\n    getTokenEndpoint() {\n      var _a;\n      const tokenEndpoint = (_a = this.config.tokenEndpoint) !== null && _a !== void 0 ? _a : '';\n      return this.prefixEndpoint(tokenEndpoint);\n    }\n    /**\n     * Returns url for redirect to the authorization server to get token/code\n     */\n    getLoginUrl() {\n      var _a;\n      const loginUrl = (_a = this.config.loginUrl) !== null && _a !== void 0 ? _a : '';\n      return this.prefixEndpoint(loginUrl);\n    }\n    /**\n     * Returns endpoint for token revocation (both access and refresh token).\n     */\n    getRevokeEndpoint() {\n      var _a;\n      const revokeEndpoint = (_a = this.config.revokeEndpoint) !== null && _a !== void 0 ? _a : '';\n      return this.prefixEndpoint(revokeEndpoint);\n    }\n    /**\n     * Returns logout url to redirect to on logout.\n     */\n    getLogoutUrl() {\n      var _a;\n      const logoutUrl = (_a = this.config.logoutUrl) !== null && _a !== void 0 ? _a : '';\n      return this.prefixEndpoint(logoutUrl);\n    }\n    /**\n     * Returns userinfo endpoint of the OAuth server.\n     */\n    getUserinfoEndpoint() {\n      var _a;\n      const userinfoEndpoint = (_a = this.config.userinfoEndpoint) !== null && _a !== void 0 ? _a : '';\n      return this.prefixEndpoint(userinfoEndpoint);\n    }\n    /**\n     * Returns configuration specific for the angular-oauth2-oidc library.\n     */\n    getOAuthLibConfig() {\n      var _a;\n      return (_a = this.config.OAuthLibConfig) !== null && _a !== void 0 ? _a : {};\n    }\n    prefixEndpoint(endpoint) {\n      let url = endpoint;\n      if (!url.startsWith('/')) {\n        url = '/' + url;\n      }\n      return `${this.getBaseUrl()}${url}`;\n    }\n    /**\n     * Returns the type of the OAuth flow based on auth config.\n     * Use when you have to perform particular action only in some of the OAuth flow scenarios.\n     */\n    getOAuthFlow() {\n      var _a;\n      const responseType = (_a = this.config.OAuthLibConfig) === null || _a === void 0 ? void 0 : _a.responseType;\n      if (responseType) {\n        const types = responseType.split(' ');\n        if (types.includes('code')) {\n          return OAuthFlow.AuthorizationCode;\n        } else if (types.includes('token')) {\n          return OAuthFlow.ImplicitFlow;\n        } else {\n          return OAuthFlow.ResourceOwnerPasswordFlow;\n        }\n      }\n      return OAuthFlow.ResourceOwnerPasswordFlow;\n    }\n  }\n  AuthConfigService.ɵfac = function AuthConfigService_Factory(t) {\n    return new (t || AuthConfigService)(i0.ɵɵinject(AuthConfig), i0.ɵɵinject(OccConfig));\n  };\n  AuthConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthConfigService,\n    factory: AuthConfigService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The url of the server request when running SSR\n * */\nconst SERVER_REQUEST_URL = new InjectionToken('SERVER_REQUEST_URL');\n/**\n * The url of the server request host when running SSR\n * */\nconst SERVER_REQUEST_ORIGIN = new InjectionToken('SERVER_REQUEST_ORIGIN');\nlet WindowRef = /*#__PURE__*/(() => {\n  class WindowRef {\n    constructor(\n    // https://github.com/angular/angular/issues/20351\n    document, platformId, serverUrl, serverOrigin) {\n      this.platformId = platformId;\n      this.serverUrl = serverUrl;\n      this.serverOrigin = serverOrigin;\n      this.document = document;\n    }\n    /**\n     * Returns true when invoked in browser context.\n     * Use this method to check if you can access `window` and other browser globals.\n     */\n    isBrowser() {\n      return isPlatformBrowser(this.platformId);\n    }\n    /**\n     * Exposes global `window` object. In SSR when `window` is not available it returns `undefined`.\n     * To detect if you can safely use `nativeWindow` use `isBrowser` to check execution platform.\n     */\n    get nativeWindow() {\n      // TODO(#11133): Consider throwing in SSR\n      return this.isBrowser() ? window : undefined;\n    }\n    /**\n     * Exposes global `sessionStorage` object. In SSR when `sessionStorage` is not available it returns `undefined`.\n     * To detect if you can safely use `sessionStorage` use `isBrowser` to check execution platform.\n     */\n    get sessionStorage() {\n      return this.nativeWindow ? this.nativeWindow.sessionStorage : undefined;\n    }\n    /**\n     * Exposes global `localStorage` object. In SSR when `localStorage` is not available it returns `undefined`.\n     * To detect if you can safely use `localStorage` use `isBrowser` to check execution platform.\n     */\n    get localStorage() {\n      return this.nativeWindow ? this.nativeWindow.localStorage : undefined;\n    }\n    /**\n     * Returns the window/document location, unless it's not available (i.e. SSR).\n     *\n     * When there's no access to the location object, we mimic the location partially, by resolving\n     * the request url (`SERVER_REQUEST_URL`) and origin (`SERVER_REQUEST_ORIGIN`) from the injector.\n     * These values are injected in the server implementation so that we can resolve some of the location\n     * values when we do server side rendering.\n     */\n    get location() {\n      if (this.isBrowser()) {\n        return this.document.location;\n      } else {\n        if (!this.serverUrl) {\n          throw new Error('Cannot resolve the href as the SERVER_REQUEST_URL is undefined');\n        }\n        if (!this.serverOrigin) {\n          throw new Error('Cannot resolve the origin as the SERVER_REQUEST_ORIGIN is undefined');\n        }\n        return {\n          href: this.serverUrl,\n          origin: this.serverOrigin\n        };\n      }\n    }\n    /**\n     * Returns an observable for the window resize event and emits an event\n     * every 300ms in case of resizing. An event is simulated initially.\n     *\n     * If there's no window object available (i.e. in SSR), a null value is emitted.\n     */\n    get resize$() {\n      if (!this.nativeWindow) {\n        return of(null);\n      } else {\n        return fromEvent(this.nativeWindow, 'resize').pipe(debounceTime(300), startWith({\n          target: this.nativeWindow\n        }), distinctUntilChanged());\n      }\n    }\n  }\n  WindowRef.ɵfac = function WindowRef_Factory(t) {\n    return new (t || WindowRef)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SERVER_REQUEST_URL, 8), i0.ɵɵinject(SERVER_REQUEST_ORIGIN, 8));\n  };\n  WindowRef.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WindowRef,\n    factory: WindowRef.ɵfac,\n    providedIn: 'root'\n  });\n  return WindowRef;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Wrapper service on the library OAuthService. Normalizes the lib API for services.\n * Use this service when you want to access low level OAuth library methods.\n */\nlet OAuthLibWrapperService = /*#__PURE__*/(() => {\n  class OAuthLibWrapperService {\n    // TODO: Remove platformId dependency in 4.0\n    constructor(oAuthService, authConfigService, platformId, winRef) {\n      this.oAuthService = oAuthService;\n      this.authConfigService = authConfigService;\n      this.platformId = platformId;\n      this.winRef = winRef;\n      this.events$ = this.oAuthService.events;\n      this.initialize();\n    }\n    initialize() {\n      var _a, _b, _c, _d;\n      const isSSR = !this.winRef.isBrowser();\n      this.oAuthService.configure(Object.assign({\n        tokenEndpoint: this.authConfigService.getTokenEndpoint(),\n        loginUrl: this.authConfigService.getLoginUrl(),\n        clientId: this.authConfigService.getClientId(),\n        dummyClientSecret: this.authConfigService.getClientSecret(),\n        revocationEndpoint: this.authConfigService.getRevokeEndpoint(),\n        logoutUrl: this.authConfigService.getLogoutUrl(),\n        userinfoEndpoint: this.authConfigService.getUserinfoEndpoint(),\n        issuer: (_b = (_a = this.authConfigService.getOAuthLibConfig()) === null || _a === void 0 ? void 0 : _a.issuer) !== null && _b !== void 0 ? _b : this.authConfigService.getBaseUrl(),\n        redirectUri: (_d = (_c = this.authConfigService.getOAuthLibConfig()) === null || _c === void 0 ? void 0 : _c.redirectUri) !== null && _d !== void 0 ? _d : !isSSR ?\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.winRef.nativeWindow.location.origin : ''\n      }, this.authConfigService.getOAuthLibConfig()));\n    }\n    /**\n     * Authorize with ResourceOwnerPasswordFlow.\n     *\n     * @param userId\n     * @param password\n     *\n     * @return token response from the lib\n     */\n    authorizeWithPasswordFlow(userId, password) {\n      return this.oAuthService.fetchTokenUsingPasswordFlow(userId, password);\n    }\n    /**\n     * Refresh access_token.\n     */\n    refreshToken() {\n      this.oAuthService.refreshToken();\n    }\n    /**\n     * Revoke access tokens and clear tokens in lib state.\n     */\n    revokeAndLogout() {\n      return new Promise(resolve => {\n        this.oAuthService.revokeTokenAndLogout().catch(() => {\n          // when there would be some kind of error during revocation we can't do anything else, so at least we logout user.\n          this.oAuthService.logOut();\n        }).finally(() => {\n          resolve();\n        });\n      });\n    }\n    /**\n     * Clear tokens in library state (no revocation).\n     */\n    logout() {\n      this.oAuthService.logOut();\n    }\n    /**\n     * Returns Open Id token. Might be empty, when it was not requested with the `responseType` config.\n     *\n     * @return id token\n     */\n    getIdToken() {\n      return this.oAuthService.getIdToken();\n    }\n    /**\n     * Initialize Implicit Flow or Authorization Code flows with the redirect to OAuth login url.\n     */\n    initLoginFlow() {\n      return this.oAuthService.initLoginFlow();\n    }\n    /**\n     * Tries to login user based on `code` or `token` present in the url.\n     */\n    tryLogin() {\n      return this.oAuthService.tryLogin({\n        // We don't load discovery document, because it doesn't contain revoke endpoint information\n        disableOAuth2StateCheck: true\n      });\n    }\n  }\n  OAuthLibWrapperService.ɵfac = function OAuthLibWrapperService_Factory(t) {\n    return new (t || OAuthLibWrapperService)(i0.ɵɵinject(i1.OAuthService), i0.ɵɵinject(AuthConfigService), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(WindowRef));\n  };\n  OAuthLibWrapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OAuthLibWrapperService,\n    factory: OAuthLibWrapperService.ɵfac,\n    providedIn: 'root'\n  });\n  return OAuthLibWrapperService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Storage service for AuthToken. Used as a storage for angular-oauth2-oidc library.\n */\nlet AuthStorageService = /*#__PURE__*/(() => {\n  class AuthStorageService extends OAuthStorage {\n    constructor() {\n      super(...arguments);\n      this._token$ = new BehaviorSubject({});\n    }\n    decode(key, value) {\n      if (AuthStorageService.nonStringifiedOAuthLibKeys.includes(key)) {\n        return value;\n      }\n      return JSON.stringify(value);\n    }\n    encode(key, value) {\n      if (AuthStorageService.nonStringifiedOAuthLibKeys.includes(key)) {\n        return value;\n      } else {\n        try {\n          return JSON.parse(value);\n        } catch (_a) {\n          return value;\n        }\n      }\n    }\n    /* Async API for spartacus use */\n    /**\n     * Returns complete token (all fields).\n     *\n     * @return observable emitting AuthToken\n     */\n    getToken() {\n      return this._token$;\n    }\n    /**\n     * Set current value of token.\n     *\n     * @param token\n     */\n    setToken(token) {\n      this._token$.next(token);\n    }\n    /* Sync API for OAuth lib use */\n    /**\n     * Get parameter from the token (eg. access_token)\n     *\n     * @param key\n     */\n    getItem(key) {\n      let token;\n      this.getToken().subscribe(currentToken => token = currentToken).unsubscribe();\n      return this.decode(key, token === null || token === void 0 ? void 0 : token[key]);\n    }\n    /**\n     * Removes parameter from the token (eg. access_token)\n     *\n     * @param key\n     */\n    removeItem(key) {\n      const val = Object.assign({}, this._token$.value);\n      delete val[key];\n      this._token$.next(Object.assign({}, val));\n    }\n    /**\n     * Sets parameter of the token (eg. access_token)\n     *\n     * @param key\n     */\n    setItem(key, data) {\n      if (key) {\n        this._token$.next(Object.assign(Object.assign({}, this._token$.value), {\n          [key]: this.encode(key, data)\n        }));\n      }\n    }\n  }\n  /**\n   * Extracted keys that are not `JSON.stringify` from reading the angular-oauth2-oidc source code\n   */\n  AuthStorageService.nonStringifiedOAuthLibKeys = ['PKCE_verifier', 'access_token', 'refresh_token', 'expires_at', 'access_token_stored_at', 'id_token', 'id_token_expires_at', 'id_token_stored_at', 'session_state', 'nonce'];\n  AuthStorageService.ɵfac = /* @__PURE__ */function () {\n    let ɵAuthStorageService_BaseFactory;\n    return function AuthStorageService_Factory(t) {\n      return (ɵAuthStorageService_BaseFactory || (ɵAuthStorageService_BaseFactory = i0.ɵɵgetInheritedFactory(AuthStorageService)))(t || AuthStorageService);\n    };\n  }();\n  AuthStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthStorageService,\n    factory: AuthStorageService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthStorageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CHANGE_NEXT_PAGE_CONTEXT = '[Router] Change Next PageContext';\nclass ChangeNextPageContext {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = CHANGE_NEXT_PAGE_CONTEXT;\n  }\n}\nvar routingGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CHANGE_NEXT_PAGE_CONTEXT: CHANGE_NEXT_PAGE_CONTEXT,\n  ChangeNextPageContext: ChangeNextPageContext\n});\nconst ROUTING_FEATURE = 'router';\nconst getRouterFeatureState = createFeatureSelector(ROUTING_FEATURE);\nconst getRouterState = createSelector(getRouterFeatureState, state => state.router);\nconst getSemanticRoute = createSelector(getRouterState, routingState => routingState.state && routingState.state.semanticRoute || '');\nconst getPageContext = createSelector(getRouterState, routingState => routingState.state && routingState.state.context || {\n  id: ''\n});\nconst getNextPageContext = createSelector(getRouterState, routingState => routingState.nextState && routingState.nextState.context);\nconst isNavigating = createSelector(getNextPageContext, context => !!context);\nvar routingGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getRouterFeatureState: getRouterFeatureState,\n  getRouterState: getRouterState,\n  getSemanticRoute: getSemanticRoute,\n  getPageContext: getPageContext,\n  getNextPageContext: getNextPageContext,\n  isNavigating: isNavigating\n});\nconst isParam = segment => segment.startsWith(':');\nconst getParamName = segment => segment.slice(1); // it just removes leading ':'\nconst ensureLeadingSlash = path => path.startsWith('/') ? path : '/' + path;\nconst removeLeadingSlash = path => path.startsWith('/') ? path.slice(1) : path;\nlet RoutingConfig = /*#__PURE__*/(() => {\n  class RoutingConfig {}\n  RoutingConfig.ɵfac = function RoutingConfig_Factory(t) {\n    return new (t || RoutingConfig)();\n  };\n  RoutingConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutingConfig,\n    factory: function RoutingConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || RoutingConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return RoutingConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoutingConfigService = /*#__PURE__*/(() => {\n  class RoutingConfigService {\n    constructor(config) {\n      this.config = config;\n    }\n    /**\n     * Returns the route config for the given route name.\n     */\n    getRouteConfig(routeName) {\n      var _a, _b;\n      const routeConfig = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes;\n      const result = routeConfig && routeConfig[routeName];\n      if (!routeConfig || result === undefined) {\n        this.warn(`No path was configured for the named route '${routeName}'!`);\n      }\n      return result;\n    }\n    warn(...args) {\n      if (isDevMode()) {\n        console.warn(...args);\n      }\n    }\n    /**\n     * Returns the configured route loading strategy.\n     */\n    getLoadStrategy() {\n      var _a, _b, _c;\n      return (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.loadStrategy) !== null && _c !== void 0 ? _c : \"always\" /* ALWAYS */;\n    }\n    /**\n     * Returns the route name of the configured path.\n     *\n     * For example, when the config is:\n     * ```\n     * routing: {\n     *   routes: {\n     *      addressBook: { paths: ['my-account/address-book'] }\n     *   }\n     * }\n     * ```\n     *\n     * the `getRouteName('my-account/address-book')` returns `'addressBook'`.\n     */\n    getRouteName(path) {\n      if (!this.routeNamesByPath) {\n        this.initRouteNamesByPath();\n      }\n      return this.routeNamesByPath[path];\n    }\n    /**\n     * Initializes the property `routeNamesByPath`.\n     *\n     * The original config allows for reading configured path by the route name.\n     * But this method builds up a structure with a 'reversed config'\n     * to read quickly the route name by the path.\n     */\n    initRouteNamesByPath() {\n      var _a, _b, _c;\n      this.routeNamesByPath = {};\n      for (const [routeName, routeConfig] of Object.entries((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes)) {\n        (_c = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || _c === void 0 ? void 0 : _c.forEach(path => {\n          if (isDevMode() && this.routeNamesByPath[path]) {\n            console.error(`The same path '${path}' is configured for two different route names: '${this.routeNamesByPath[path]}' and '${routeName}`);\n          }\n          this.routeNamesByPath[path] = routeName;\n        });\n      }\n    }\n  }\n  RoutingConfigService.ɵfac = function RoutingConfigService_Factory(t) {\n    return new (t || RoutingConfigService)(i0.ɵɵinject(RoutingConfig));\n  };\n  RoutingConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutingConfigService,\n    factory: RoutingConfigService.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutingConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UrlParsingService = /*#__PURE__*/(() => {\n  class UrlParsingService {\n    constructor(router) {\n      this.router = router;\n    }\n    getPrimarySegments(url) {\n      const urlTree = this.router.parseUrl(url);\n      return this._getPrimarySegmentsFromUrlTree(urlTree.root);\n    }\n    _getPrimarySegmentsFromUrlTree(tree) {\n      const segments = tree.segments.map(s => s.path);\n      const childrenSegments = tree.children[PRIMARY_OUTLET] ? this._getPrimarySegmentsFromUrlTree(tree.children[PRIMARY_OUTLET]) : [];\n      return segments.concat(childrenSegments);\n    }\n    /**\n     * Tells whether the given url matches the given path.\n     *\n     * @param urlSegments   string or array of url segments. When it's a string, the preceding\n     *                      site-context params are ignored (i.e. '/electronics-spa/en/USD/...')\n     *\n     * @param pathSegments  string or array of path segments. Dynamic params are allowed in the\n     *                      path shape, i.e. `/url/:param1/with/:param2`.\n     */\n    matchPath(urlSegments, pathSegments) {\n      urlSegments = Array.isArray(urlSegments) ? urlSegments : this.getPrimarySegments(urlSegments);\n      pathSegments = Array.isArray(pathSegments) ? pathSegments : this.getPrimarySegments(pathSegments);\n      if (urlSegments.length !== pathSegments.length) {\n        return false;\n      }\n      for (let i = 0; i < pathSegments.length; i++) {\n        const pathSeg = pathSegments[i];\n        const urlSeg = urlSegments[i];\n        // compare only static segments:\n        if (!isParam(pathSeg) && pathSeg !== urlSeg) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  UrlParsingService.ɵfac = function UrlParsingService_Factory(t) {\n    return new (t || UrlParsingService)(i0.ɵɵinject(i1$1.Router));\n  };\n  UrlParsingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlParsingService,\n    factory: UrlParsingService.ɵfac,\n    providedIn: 'root'\n  });\n  return UrlParsingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SemanticPathService = /*#__PURE__*/(() => {\n  class SemanticPathService {\n    constructor(routingConfigService, urlParser) {\n      this.routingConfigService = routingConfigService;\n      this.urlParser = urlParser;\n      this.ROOT_URL = ['/'];\n    }\n    /**\n     * Returns the first path alias configured for a given route name. It adds `/` at the beginning.\n     */\n    get(routeName) {\n      const routeConfig = this.routingConfigService.getRouteConfig(routeName);\n      return routeConfig && Array.isArray(routeConfig.paths) ? '/' + routeConfig.paths[0] : undefined;\n    }\n    /**\n     * Transforms the array of url commands. Each command can be:\n     * a) string - will be left untouched\n     * b) object { cxRoute: <route name> } - will be replaced with semantic path\n     * c) object { cxRoute: <route name>, params: { ... } } - same as above, but with passed params\n     *\n     * If the first command is the object with the `cxRoute` property, returns an absolute url (with the first element of the array `'/'`)\n     */\n    transform(commands) {\n      if (!Array.isArray(commands)) {\n        commands = [commands];\n      }\n      const result = [];\n      for (const command of commands) {\n        if (!this.isRouteCommand(command)) {\n          // don't modify segment that is not route command:\n          result.push(command);\n        } else {\n          // generate array with url segments for given route command:\n          const partialResult = this.generateUrlPart(command);\n          if (partialResult === null) {\n            return this.ROOT_URL;\n          }\n          result.push(...partialResult);\n        }\n      }\n      if (this.shouldOutputAbsolute(commands)) {\n        result.unshift('/');\n      }\n      return result;\n    }\n    isRouteCommand(command) {\n      return command && Boolean(command.cxRoute);\n    }\n    shouldOutputAbsolute(commands) {\n      return this.isRouteCommand(commands[0]);\n    }\n    generateUrlPart(command) {\n      this.standarizeRouteCommand(command);\n      if (!command.cxRoute) {\n        return null;\n      }\n      const routeConfig = this.routingConfigService.getRouteConfig(command.cxRoute);\n      // if no route translation was configured, return null:\n      if (!routeConfig || !routeConfig.paths) {\n        return null;\n      }\n      // find first path that can satisfy it's parameters with given parameters\n      const path = this.findPathWithFillableParams(routeConfig, command.params);\n      // if there is no configured path that can be satisfied with given params, return null\n      if (!path) {\n        return null;\n      }\n      const result = this.provideParamsValues(path, command.params, routeConfig.paramsMapping);\n      return result;\n    }\n    standarizeRouteCommand(command) {\n      command.params = command.params || {};\n    }\n    provideParamsValues(path, params, paramsMapping) {\n      return this.urlParser.getPrimarySegments(path).map(segment => {\n        if (isParam(segment)) {\n          const paramName = getParamName(segment);\n          const mappedParamName = this.getMappedParamName(paramName, paramsMapping);\n          return params[mappedParamName];\n        }\n        return segment;\n      });\n    }\n    findPathWithFillableParams(routeConfig, params) {\n      const foundPath = routeConfig.paths.find(path => this.getParams(path).every(paramName => {\n        const mappedParamName = this.getMappedParamName(paramName, routeConfig.paramsMapping);\n        return params[mappedParamName] !== undefined;\n      }));\n      if (foundPath === undefined || foundPath === null) {\n        return null;\n      }\n      return foundPath;\n    }\n    getParams(path) {\n      return this.urlParser.getPrimarySegments(path).filter(isParam).map(getParamName);\n    }\n    getMappedParamName(paramName, paramsMapping) {\n      if (paramsMapping) {\n        return paramsMapping[paramName] || paramName;\n      }\n      return paramName;\n    }\n  }\n  SemanticPathService.ɵfac = function SemanticPathService_Factory(t) {\n    return new (t || SemanticPathService)(i0.ɵɵinject(RoutingConfigService), i0.ɵɵinject(UrlParsingService));\n  };\n  SemanticPathService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SemanticPathService,\n    factory: SemanticPathService.ɵfac,\n    providedIn: 'root'\n  });\n  return SemanticPathService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Helper service to expose all activated routes\n */\nlet ActivatedRoutesService = /*#__PURE__*/(() => {\n  class ActivatedRoutesService {\n    constructor(router) {\n      this.router = router;\n      /**\n       * Array of currently activated routes (from the root route to the leaf route).\n       */\n      this.routes$ = this.router.events.pipe(filter(event => event instanceof NavigationEnd),\n      // eslint-disable-next-line import/no-deprecated\n      startWith(undefined),\n      // emit value for consumer who subscribed lately after NavigationEnd event\n      map(() => {\n        let route = this.router.routerState.snapshot.root;\n        const routes = [route];\n        // traverse to the leaf route:\n        while (route = route.firstChild) {\n          routes.push(route);\n        }\n        return routes;\n      }), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n  }\n  ActivatedRoutesService.ɵfac = function ActivatedRoutesService_Factory(t) {\n    return new (t || ActivatedRoutesService)(i0.ɵɵinject(i1$1.Router));\n  };\n  ActivatedRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActivatedRoutesService,\n    factory: ActivatedRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return ActivatedRoutesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service to expose all parameters for the router, including child routes.\n * This is convenient in case the parent route (component) requires awareness\n * of child routes parameters.\n */\nlet RoutingParamsService = /*#__PURE__*/(() => {\n  class RoutingParamsService {\n    constructor(router, activatedRoutesService) {\n      this.router = router;\n      this.activatedRoutesService = activatedRoutesService;\n      this.params$ = this.activatedRoutesService.routes$.pipe(map(routes => this.findAllParam(routes)), shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }));\n    }\n    /**\n     * Get the list of all parameters of the full route. This includes\n     * active child routes.\n     */\n    getParams() {\n      return this.params$;\n    }\n    findAllParam(routes) {\n      return Object.assign({}, ...routes.map(route => route.params));\n    }\n  }\n  RoutingParamsService.ɵfac = function RoutingParamsService_Factory(t) {\n    return new (t || RoutingParamsService)(i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(ActivatedRoutesService));\n  };\n  RoutingParamsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutingParamsService,\n    factory: RoutingParamsService.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutingParamsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoutingService = /*#__PURE__*/(() => {\n  class RoutingService {\n    constructor(store, winRef, semanticPathService, routingParamsService, router, location) {\n      this.store = store;\n      this.winRef = winRef;\n      this.semanticPathService = semanticPathService;\n      this.routingParamsService = routingParamsService;\n      this.router = router;\n      this.location = location;\n    }\n    /**\n     * Get the list of all parameters of the full route. This includes\n     * active child routes.\n     */\n    getParams() {\n      var _a;\n      return (_a = this.routingParamsService) === null || _a === void 0 ? void 0 : _a.getParams();\n    }\n    /**\n     * Get the current router state\n     */\n    getRouterState() {\n      return this.store.pipe(select(getRouterState));\n    }\n    /**\n     * Get the `PageContext` from the state\n     */\n    getPageContext() {\n      return this.store.pipe(select(getPageContext));\n    }\n    /**\n     * Get the next `PageContext` from the state\n     */\n    getNextPageContext() {\n      return this.store.pipe(select(getNextPageContext));\n    }\n    /**\n     * Allow to change next page context for the ongoing navigation\n     *\n     * @param pageContext\n     */\n    changeNextPageContext(pageContext) {\n      this.store.dispatch(new ChangeNextPageContext(pageContext));\n    }\n    /**\n     * Get the `isNavigating` info from the state\n     */\n    isNavigating() {\n      return this.store.pipe(select(isNavigating));\n    }\n    /**\n     * Navigation with a new state into history\n     * @param commands: url commands\n     * @param extras: Represents the extra options used during navigation.\n     *\n     * @returns Promise that resolves to `true` when navigation succeeds,\n     *          to `false` when navigation fails, or is rejected on error.\n     */\n    go(commands, extras) {\n      const path = this.semanticPathService.transform(commands);\n      return this.navigate(path, extras);\n    }\n    /**\n     * Resolves the relative url for the given `UrlCommands` and `NavigationExtras`.\n     *\n     * The absolute url can be resolved using `getFullUrl()`.\n     */\n    getUrl(commands, extras) {\n      let url = this.router.serializeUrl(this.router.createUrlTree(this.semanticPathService.transform(commands), extras));\n      if (!url.startsWith('/')) {\n        url = `/${url}`;\n      }\n      return url;\n    }\n    /**\n     * Returns the absolute url for the given `UrlCommands` and `NavigationExtras`.\n     *\n     * The absolute url uses the origin of the current location.\n     */\n    getFullUrl(commands, extras) {\n      return `${this.winRef.document.location.origin}${this.getUrl(commands, extras)}`;\n    }\n    /**\n     * Navigation using absolute route path\n     * @param url\n     * @param extras: Represents the extra options used during navigation.\n     *\n     * @returns Promise that resolves to `true` when navigation succeeds,\n     *          to `false` when navigation fails, or is rejected on error.\n     */\n    goByUrl(url, extras) {\n      return this.router.navigateByUrl(url, extras);\n    }\n    /**\n     * Navigating back\n     */\n    back() {\n      const isLastPageInApp = this.winRef.document.referrer.includes(this.winRef.nativeWindow.location.origin);\n      if (isLastPageInApp) {\n        this.location.back();\n        return;\n      }\n      this.go(['/']);\n      return;\n    }\n    /**\n     * Navigating forward\n     */\n    forward() {\n      this.location.forward();\n    }\n    /**\n     * Navigation with a new state into history\n     * @param path\n     * @param extras: Represents the extra options used during navigation.\n     *\n     * @returns Promise that resolves to `true` when navigation succeeds,\n     *          to `false` when navigation fails, or is rejected on error.\n     */\n    navigate(path, extras) {\n      return this.router.navigate(path, extras);\n    }\n  }\n  RoutingService.ɵfac = function RoutingService_Factory(t) {\n    return new (t || RoutingService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(WindowRef), i0.ɵɵinject(SemanticPathService), i0.ɵɵinject(RoutingParamsService), i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(i6.Location));\n  };\n  RoutingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutingService,\n    factory: RoutingService.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service serves storage role for AuthRedirectService.\n * Used by AuthStatePersistenceService to store redirect url for OAuth flows that rely on redirects.\n */\nlet AuthRedirectStorageService = /*#__PURE__*/(() => {\n  class AuthRedirectStorageService {\n    constructor() {\n      this.redirectUrl$ = new BehaviorSubject(undefined);\n    }\n    /**\n     * Get redirect url after logging in.\n     *\n     * @returns observable with the redirect url as string\n     */\n    getRedirectUrl() {\n      return this.redirectUrl$;\n    }\n    /**\n     * Set url to redirect to after login.\n     *\n     * @param redirectUrl\n     */\n    setRedirectUrl(redirectUrl) {\n      this.redirectUrl$.next(redirectUrl);\n    }\n  }\n  AuthRedirectStorageService.ɵfac = function AuthRedirectStorageService_Factory(t) {\n    return new (t || AuthRedirectStorageService)();\n  };\n  AuthRedirectStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthRedirectStorageService,\n    factory: AuthRedirectStorageService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthRedirectStorageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthFlowRoutesService = /*#__PURE__*/(() => {\n  class AuthFlowRoutesService {\n    constructor(config, urlParsingService) {\n      this.config = config;\n      this.urlParsingService = urlParsingService;\n    }\n    /**\n     * List of paths that are part user auth flow\n     */\n    get authFlowPaths() {\n      var _a, _b;\n      if (!this._authFlowPaths) {\n        // extract from the routing config the paths that are part of the user auth flow\n        this._authFlowPaths = Object.values(((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes) || {}).reduce((acc, routeConfig) => {\n          var _a;\n          return routeConfig.authFlow === true && ((_a = routeConfig.paths) === null || _a === void 0 ? void 0 : _a.length) ? acc.concat(routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) : acc;\n        }, []);\n      }\n      return this._authFlowPaths;\n    }\n    /**\n     * Tells whether the given URL is a part of the user auth flow\n     */\n    isAuthFlow(url) {\n      return this.authFlowPaths.some(path => this.urlParsingService.matchPath(url, path));\n    }\n  }\n  AuthFlowRoutesService.ɵfac = function AuthFlowRoutesService_Factory(t) {\n    return new (t || AuthFlowRoutesService)(i0.ɵɵinject(RoutingConfig), i0.ɵɵinject(UrlParsingService));\n  };\n  AuthFlowRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthFlowRoutesService,\n    factory: AuthFlowRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthFlowRoutesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Responsible for saving last accessed page (or attempted) before login and for redirecting to that page after login.\n */\nlet AuthRedirectService = /*#__PURE__*/(() => {\n  class AuthRedirectService {\n    /**\n     * This service is responsible for remembering the last page before the authentication. \"The last page\" can be:\n     * 1. Just the previously opened page; or\n     * 2. The page that we just tried to open, but AuthGuard cancelled it\n     *\n     * Then, after successful authentication it allows for redirecting to that remembered page via the `redirect()` method.\n     *\n     * For example:\n     * 1. The user opens the product page, then clicks /login link and signs in\n     *    -> Then we should redirect to the product page; or\n     * 2. The user opens the product page, then he clicks /my-account link,\n     *    but is automatically redirected to the login page by the AuthGuard, and he signs in\n     *    -> Then we should redirect to the my-account page, not the product page\n     */\n    constructor(routing, router, authRedirectStorageService, authFlowRoutesService) {\n      this.routing = routing;\n      this.router = router;\n      this.authRedirectStorageService = authRedirectStorageService;\n      this.authFlowRoutesService = authFlowRoutesService;\n      this.init();\n    }\n    init() {\n      this.subscription = this.router.events.subscribe(event => {\n        if (event instanceof NavigationEnd) {\n          this.setRedirectUrl(event.urlAfterRedirects);\n        }\n      });\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n    /**\n     * Redirect to saved url (homepage if nothing is saved).\n     */\n    redirect() {\n      this.authRedirectStorageService.getRedirectUrl().pipe(take(1)).subscribe(redirectUrl => {\n        if (redirectUrl === undefined) {\n          this.routing.go('/');\n        } else {\n          this.routing.goByUrl(redirectUrl);\n        }\n        this.clearRedirectUrl();\n      });\n    }\n    /**\n     * Saves url of a page that user wanted to access, but wasn't yet logged in.\n     *\n     * @deprecated since 4.0 - use `saveCurrentNavigationUrl` method instead\n     */\n    reportAuthGuard() {\n      this.saveCurrentNavigationUrl();\n    }\n    /**\n     * Saves the url of the current navigation as the redirect url, unless\n     * the url is a part of the user login flow.\n     */\n    saveCurrentNavigationUrl() {\n      const navigation = this.router.getCurrentNavigation();\n      if (!(navigation === null || navigation === void 0 ? void 0 : navigation.finalUrl)) {\n        return;\n      }\n      const url = this.router.serializeUrl(navigation.finalUrl);\n      this.setRedirectUrl(url);\n    }\n    /**\n     * @deprecated since 4.0 - method not needed anymore. Every visited URL is now\n     *                         remembered automatically as redirect URL on NavigationEnd event.\n     */\n    reportNotAuthGuard() {}\n    /**\n     * Save the url as the redirect url, unless it's a part of the user login flow.\n     */\n    setRedirectUrl(url) {\n      if (!this.authFlowRoutesService.isAuthFlow(url)) {\n        this.authRedirectStorageService.setRedirectUrl(url);\n      }\n    }\n    /**\n     * Sets the redirect URL to undefined.\n     */\n    clearRedirectUrl() {\n      this.authRedirectStorageService.setRedirectUrl(undefined);\n    }\n  }\n  AuthRedirectService.ɵfac = function AuthRedirectService_Factory(t) {\n    return new (t || AuthRedirectService)(i0.ɵɵinject(RoutingService), i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(AuthRedirectStorageService), i0.ɵɵinject(AuthFlowRoutesService));\n  };\n  AuthRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthRedirectService,\n    factory: AuthRedirectService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthRedirectService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Auth service for normal user authentication.\n * Use to check auth status, login/logout with different OAuth flows.\n */\nlet AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    constructor(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, routingService) {\n      this.store = store;\n      this.userIdService = userIdService;\n      this.oAuthLibWrapperService = oAuthLibWrapperService;\n      this.authStorageService = authStorageService;\n      this.authRedirectService = authRedirectService;\n      this.routingService = routingService;\n      /**\n       * Indicates whether the access token is being refreshed\n       */\n      this.refreshInProgress$ = new BehaviorSubject(false);\n      /**\n       * Indicates whether the logout is being performed\n       */\n      this.logoutInProgress$ = new BehaviorSubject(false);\n    }\n    /**\n     * Check params in url and if there is an code/token then try to login with those.\n     */\n    checkOAuthParamsInUrl() {\n      return __awaiter(this, void 0, void 0, function* () {\n        // We use the 'token_received' event to check if we have returned\n        // from the auth server.\n        let tokenReceivedEvent;\n        const subscription = this.oAuthLibWrapperService.events$.pipe(filter(event => event.type === 'token_received'), take(1)).subscribe(event => tokenReceivedEvent = event);\n        // The method `oAuthLibWrapperService.tryLogin()` obtains the token either from the URL params\n        // or from the storage. To distinguish those 2 cases, we observe the event `token_received`.\n        //\n        // The event 'token_received' is emitted, when the method `oAuthLibWrapperService.tryLogin()`\n        // can derive the token from the URL params (which means we've just returned from\n        // an external authorization page to Spartacus).\n        //\n        // But the event 'token_received' is not emitted when the method `oAuthLibWrapperService.tryLogin()`\n        // can obtain the token from the storage (e.g. on refresh of the Spartacus page).\n        try {\n          const result = yield this.oAuthLibWrapperService.tryLogin();\n          const token = this.authStorageService.getItem('access_token');\n          // We get the result in the code flow even if we did not logged in that why we also need to check if we have access_token\n          if (result && token) {\n            this.userIdService.setUserId(OCC_USER_ID_CURRENT);\n            this.store.dispatch(new Login());\n            // Only redirect if we have received a token,\n            // otherwise we are not returning from authentication server.\n            if (tokenReceivedEvent) {\n              this.authRedirectService.redirect();\n            }\n          }\n        } catch (_a) {}\n        subscription.unsubscribe();\n      });\n    }\n    /**\n     * Initialize Implicit/Authorization Code flow by redirecting to OAuth server.\n     */\n    loginWithRedirect() {\n      this.oAuthLibWrapperService.initLoginFlow();\n      return true;\n    }\n    /**\n     * Loads a new user token with Resource Owner Password Flow.\n     * @param userId\n     * @param password\n     */\n    loginWithCredentials(userId, password) {\n      return __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password);\n          // OCC specific user id handling. Customize when implementing different backend\n          this.userIdService.setUserId(OCC_USER_ID_CURRENT);\n          this.store.dispatch(new Login());\n          this.authRedirectService.redirect();\n        } catch (_a) {}\n      });\n    }\n    /**\n     * Revokes tokens and clears state for logged user (tokens, userId).\n     * To perform logout it is best to use `logout` method. Use this method with caution.\n     */\n    coreLogout() {\n      this.setLogoutProgress(true);\n      this.userIdService.clearUserId();\n      return new Promise(resolve => {\n        this.oAuthLibWrapperService.revokeAndLogout().finally(() => {\n          this.store.dispatch(new Logout());\n          resolve();\n        });\n      });\n    }\n    /**\n     * Returns `true` if the user is logged in; and `false` if the user is anonymous.\n     */\n    isUserLoggedIn() {\n      return this.authStorageService.getToken().pipe(map(userToken => Boolean(userToken === null || userToken === void 0 ? void 0 : userToken.access_token)), distinctUntilChanged());\n    }\n    /**\n     * Logout a storefront customer. It will initialize logout procedure by redirecting to the `logout` endpoint.\n     */\n    logout() {\n      this.routingService.go({\n        cxRoute: 'logout'\n      });\n    }\n    /**\n     * Start or stop the refresh process\n     */\n    setRefreshProgress(progress) {\n      this.refreshInProgress$.next(progress);\n    }\n    /**\n     * Start or stop the logout process\n     */\n    setLogoutProgress(progress) {\n      this.logoutInProgress$.next(progress);\n    }\n  }\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService), i0.ɵɵinject(OAuthLibWrapperService), i0.ɵɵinject(AuthStorageService), i0.ɵɵinject(AuthRedirectService), i0.ɵɵinject(RoutingService));\n  };\n  AuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthService,\n    factory: AuthService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentsService = /*#__PURE__*/(() => {\n  class AnonymousConsentsService {\n    constructor(store, authService) {\n      this.store = store;\n      this.authService = authService;\n    }\n    /**\n     * Retrieves the anonymous consent templates.\n     */\n    loadTemplates() {\n      this.store.dispatch(new LoadAnonymousConsentTemplates());\n    }\n    /**\n     * Conditionally triggers the load of the anonymous consent templates if:\n     *   - `loadIfMissing` parameter is set to `true`\n     *   - the `templates` in the store are `undefined`\n     *\n     * Otherwise it just returns the value from the store.\n     *\n     * @param loadIfMissing setting to `true` will trigger the load of the templates if the currently stored templates are `undefined`\n     */\n    getTemplates(loadIfMissing = false) {\n      return iif(() => loadIfMissing, this.store.pipe(select(getAnonymousConsentTemplatesValue), withLatestFrom(this.getLoadTemplatesLoading()), filter(([_templates, loading]) => !loading), tap(([templates, _loading]) => {\n        if (!Boolean(templates)) {\n          this.loadTemplates();\n        }\n      }), filter(([templates, _loading]) => Boolean(templates)), map(([templates, _loading]) => templates)), this.store.pipe(select(getAnonymousConsentTemplatesValue)));\n    }\n    /**\n     * Returns the anonymous consent templates with the given template code.\n     * @param templateCode a template code by which to filter anonymous consent templates.\n     */\n    getTemplate(templateCode) {\n      return this.store.pipe(select(getAnonymousConsentTemplate(templateCode)));\n    }\n    /**\n     * Returns an indicator for the loading status for the anonymous consent templates.\n     */\n    getLoadTemplatesLoading() {\n      return this.store.pipe(select(getAnonymousConsentTemplatesLoading));\n    }\n    /**\n     * Returns an indicator for the success status for the anonymous consent templates.\n     */\n    getLoadTemplatesSuccess() {\n      return this.store.pipe(select(getAnonymousConsentTemplatesSuccess));\n    }\n    /**\n     * Returns an indicator for the error status for the anonymous consent templates.\n     */\n    getLoadTemplatesError() {\n      return this.store.pipe(select(getAnonymousConsentTemplatesError));\n    }\n    /**\n     * Resets the loading, success and error indicators for the anonymous consent templates.\n     */\n    resetLoadTemplatesState() {\n      this.store.dispatch(new ResetLoadAnonymousConsentTemplates());\n    }\n    /**\n     * Returns all the anonymous consents.\n     */\n    getConsents() {\n      return this.store.pipe(select(getAnonymousConsents));\n    }\n    /**\n     * Puts the provided anonymous consents into the store.\n     */\n    setConsents(consents) {\n      return this.store.dispatch(new SetAnonymousConsents(consents));\n    }\n    /**\n     * Returns the anonymous consent for the given template ID.\n     *\n     * As a side-effect, the method will call `getTemplates(true)` to load the templates if those are not present.\n     *\n     * @param templateId a template ID by which to filter anonymous consent templates.\n     */\n    getConsent(templateId) {\n      return this.authService.isUserLoggedIn().pipe(filter(authenticated => !authenticated), tap(() => this.getTemplates(true)), switchMap(() => this.store.pipe(select(getAnonymousConsentByTemplateCode(templateId)))));\n    }\n    /**\n     * Give a consent for the given `templateCode`\n     * @param templateCode for which to give the consent\n     */\n    giveConsent(templateCode) {\n      this.store.dispatch(new GiveAnonymousConsent(templateCode));\n    }\n    /**\n     * Sets all the anonymous consents' state to given.\n     */\n    giveAllConsents() {\n      return this.getTemplates(true).pipe(tap(templates => templates.forEach(template => this.giveConsent(template.id))));\n    }\n    /**\n     * Returns `true` if the provided `consent` is given.\n     * @param consent a consent to test\n     */\n    isConsentGiven(consent) {\n      return consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.GIVEN;\n    }\n    /**\n     * Withdraw a consent for the given `templateCode`\n     * @param templateCode for which to withdraw the consent\n     */\n    withdrawConsent(templateCode) {\n      this.store.dispatch(new WithdrawAnonymousConsent(templateCode));\n    }\n    /**\n     * Sets all the anonymous consents' state to withdrawn.\n     */\n    withdrawAllConsents() {\n      return this.getTemplates(true).pipe(tap(templates => templates.forEach(template => this.withdrawConsent(template.id))));\n    }\n    /**\n     * Returns `true` if the provided `consent` is withdrawn.\n     * @param consent a consent to test\n     */\n    isConsentWithdrawn(consent) {\n      return consent && consent.consentState === ANONYMOUS_CONSENT_STATUS.WITHDRAWN;\n    }\n    /**\n     * Toggles the dismissed state of the anonymous consents banner.\n     * @param dismissed the banner will be dismissed if `true` is passed, otherwise it will be visible.\n     */\n    toggleBannerDismissed(dismissed) {\n      this.store.dispatch(new ToggleAnonymousConsentsBannerDissmissed(dismissed));\n      if (dismissed) {\n        this.toggleTemplatesUpdated(false);\n      }\n    }\n    /**\n     * Returns `true` if the banner was dismissed, `false` otherwise.\n     */\n    isBannerDismissed() {\n      return this.store.pipe(select(getAnonymousConsentsBannerDismissed));\n    }\n    /**\n     * Returns `true` if the consent templates were updated on the back-end.\n     * If the templates are not present in the store, it triggers the load.\n     */\n    getTemplatesUpdated() {\n      return this.getTemplates(true).pipe(switchMap(() => this.store.pipe(select(getAnonymousConsentTemplatesUpdate))));\n    }\n    /**\n     * Toggles the `updated` slice of the state\n     * @param updated\n     */\n    toggleTemplatesUpdated(updated) {\n      this.store.dispatch(new ToggleAnonymousConsentTemplatesUpdated(updated));\n    }\n    /**\n     * Returns `true` if either the banner is not dismissed or if the templates were updated on the back-end.\n     * Otherwise, it returns `false`.\n     */\n    isBannerVisible() {\n      return combineLatest([this.isBannerDismissed(), this.getTemplatesUpdated()]).pipe(tap(() => this.checkConsentVersions()), map(([dismissed, updated]) => !dismissed || updated));\n    }\n    /**\n     * Dispatches an action to trigger the check\n     * whether the anonymous consent version have been updated\n     */\n    checkConsentVersions() {\n      this.store.dispatch(new AnonymousConsentCheckUpdatedVersions());\n    }\n    /**\n     * Returns `true` if there's a mismatch in template versions between the provided `currentTemplates` and `newTemplates`\n     * @param currentTemplates current templates to check\n     * @param newTemplates new templates to check\n     */\n    detectUpdatedTemplates(currentTemplates, newTemplates) {\n      if (newTemplates.length !== currentTemplates.length) {\n        return true;\n      }\n      for (let i = 0; i < newTemplates.length; i++) {\n        const newTemplate = newTemplates[i];\n        const currentTemplate = currentTemplates[i];\n        if (newTemplate.version !== currentTemplate.version) {\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Serializes using `JSON.stringify()` and encodes using `encodeURIComponent()` methods\n     * @param consents to serialize and encode\n     */\n    serializeAndEncode(consents) {\n      if (!consents) {\n        return '';\n      }\n      const serialized = JSON.stringify(consents);\n      const encoded = encodeURIComponent(serialized);\n      return encoded;\n    }\n    /**\n     * Decodes using `decodeURIComponent()` and deserializes using `JSON.parse()`\n     * @param rawConsents to decode an deserialize\n     */\n    decodeAndDeserialize(rawConsents) {\n      const decoded = decodeURIComponent(rawConsents);\n      const unserialized = JSON.parse(decoded);\n      return unserialized;\n    }\n    /**\n     *\n     * Compares the given `newConsents` and `previousConsents` and returns `true` if there are differences (the `newConsents` are updates).\n     * Otherwise it returns `false`.\n     *\n     * @param newConsents new consents to compare\n     * @param previousConsents old consents to compare\n     */\n    consentsUpdated(newConsents, previousConsents) {\n      const newRawConsents = this.serializeAndEncode(newConsents);\n      const previousRawConsents = this.serializeAndEncode(previousConsents);\n      return newRawConsents !== previousRawConsents;\n    }\n  }\n  AnonymousConsentsService.ɵfac = function AnonymousConsentsService_Factory(t) {\n    return new (t || AnonymousConsentsService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(AuthService));\n  };\n  AnonymousConsentsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentsService,\n    factory: AnonymousConsentsService.ɵfac,\n    providedIn: 'root'\n  });\n  return AnonymousConsentsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst USE_CLIENT_TOKEN = 'cx-use-client-token';\nconst USE_CUSTOMER_SUPPORT_AGENT_TOKEN = 'cx-use-csagent-token';\nclass InterceptorUtil {\n  static createHeader(headerName, interceptorParam, headers) {\n    if (headers) {\n      return headers.append(headerName, JSON.stringify(interceptorParam));\n    }\n    headers = new HttpHeaders().set(headerName, JSON.stringify(interceptorParam));\n    return headers;\n  }\n  static removeHeader(headerName, request) {\n    const updatedHeaders = request.headers.delete(headerName);\n    return request.clone({\n      headers: updatedHeaders\n    });\n  }\n  static getInterceptorParam(headerName, headers) {\n    const rawValue = headers.get(headerName);\n    if (rawValue) {\n      return JSON.parse(rawValue);\n    }\n    return undefined;\n  }\n}\nconst CLIENT_AUTH_FEATURE = 'client-auth';\nconst CLIENT_TOKEN_DATA = '[Client auth] Client Token Data';\nconst LOAD_CLIENT_TOKEN = '[Token] Load Client Token';\nconst LOAD_CLIENT_TOKEN_FAIL = '[Token] Load Client Token Fail';\nconst LOAD_CLIENT_TOKEN_SUCCESS = '[Token] Load Client Token Success';\nclass LoadClientToken extends LoaderLoadAction {\n  constructor() {\n    super(CLIENT_TOKEN_DATA);\n    this.type = LOAD_CLIENT_TOKEN;\n  }\n}\nclass LoadClientTokenFail extends LoaderFailAction {\n  constructor(payload) {\n    super(CLIENT_TOKEN_DATA, payload);\n    this.payload = payload;\n    this.type = LOAD_CLIENT_TOKEN_FAIL;\n  }\n}\nclass LoadClientTokenSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(CLIENT_TOKEN_DATA);\n    this.payload = payload;\n    this.type = LOAD_CLIENT_TOKEN_SUCCESS;\n  }\n}\nvar clientTokenGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_CLIENT_TOKEN: LOAD_CLIENT_TOKEN,\n  LOAD_CLIENT_TOKEN_FAIL: LOAD_CLIENT_TOKEN_FAIL,\n  LOAD_CLIENT_TOKEN_SUCCESS: LOAD_CLIENT_TOKEN_SUCCESS,\n  LoadClientToken: LoadClientToken,\n  LoadClientTokenFail: LoadClientTokenFail,\n  LoadClientTokenSuccess: LoadClientTokenSuccess\n});\nconst getClientAuthState = createFeatureSelector(CLIENT_AUTH_FEATURE);\nconst getClientTokenState = createSelector(getClientAuthState, state => state.clientToken);\nvar clientTokenGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getClientTokenState: getClientTokenState,\n  getClientAuthState: getClientAuthState\n});\n\n/**\n * Serves a role of a facade on client token store.\n */\nlet ClientTokenService = /*#__PURE__*/(() => {\n  class ClientTokenService {\n    constructor(store) {\n      this.store = store;\n    }\n    /**\n     * Returns a client token. The client token from the store is returned if there is one.\n     * Otherwise a new token is fetched from the backend and saved in the store.\n     */\n    getClientToken() {\n      return this.store.pipe(select(getClientTokenState), observeOn(queueScheduler), filter(state => {\n        if (this.isClientTokenLoaded(state)) {\n          return true;\n        } else {\n          if (!state.loading) {\n            this.store.dispatch(new LoadClientToken());\n          }\n          return false;\n        }\n      }), map(state => state.value));\n    }\n    /**\n     * Fetches a clientToken from the backend and saves it in the store where getClientToken can use it.\n     * The new clientToken is returned.\n     */\n    refreshClientToken() {\n      this.store.dispatch(new LoadClientToken());\n      return this.store.pipe(select(getClientTokenState), filter(state => this.isClientTokenLoaded(state)), map(state => state.value));\n    }\n    isClientTokenLoaded(state) {\n      return (state.success || state.error) && !state.loading;\n    }\n  }\n  ClientTokenService.ɵfac = function ClientTokenService_Factory(t) {\n    return new (t || ClientTokenService)(i0.ɵɵinject(i1$2.Store));\n  };\n  ClientTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClientTokenService,\n    factory: ClientTokenService.ɵfac,\n    providedIn: 'root'\n  });\n  return ClientTokenService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service for handling `Authorization` header and errors for requests that\n * require client token (eg. user registration).\n */\nlet ClientErrorHandlingService = /*#__PURE__*/(() => {\n  class ClientErrorHandlingService {\n    constructor(clientTokenService) {\n      this.clientTokenService = clientTokenService;\n    }\n    /**\n     * Refreshes client token and retries the request with the new token.\n     *\n     * @param request\n     * @param httpHandler\n     */\n    handleExpiredClientToken(request, next) {\n      return this.clientTokenService.refreshClientToken().pipe(take(1), switchMap(token => {\n        return next.handle(this.createNewRequestWithNewToken(request, token));\n      }));\n    }\n    /**\n     * Clones the requests and provided `Authorization` header.\n     *\n     * @param request\n     * @param token\n     */\n    createNewRequestWithNewToken(request, token) {\n      request = request.clone({\n        setHeaders: {\n          Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`\n        }\n      });\n      return request;\n    }\n  }\n  ClientErrorHandlingService.ɵfac = function ClientErrorHandlingService_Factory(t) {\n    return new (t || ClientErrorHandlingService)(i0.ɵɵinject(ClientTokenService));\n  };\n  ClientErrorHandlingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClientErrorHandlingService,\n    factory: ClientErrorHandlingService.ɵfac,\n    providedIn: 'root'\n  });\n  return ClientErrorHandlingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass StringTemplate {\n  /**\n   * Populates the given template with the variables provided\n   *\n   * @param templateString template of the OCC endpoint\n   * @param templateVariables variables to replace in the template\n   * @param encodeVariable encode variable before placing it in the template\n   */\n  static resolve(templateString, templateVariables, encodeVariable) {\n    for (const variableLabel of Object.keys(templateVariables)) {\n      const placeholder = new RegExp('\\\\${' + variableLabel + '}', 'g');\n      templateString = templateString.replace(placeholder,\n      // TODO 4.0: default to encodeVariable = true\n      encodeVariable ? encodeURIComponent(templateVariables[variableLabel]) : templateVariables[variableLabel]);\n    }\n    return templateString;\n  }\n}\n\n/**\n * Helper function for safely getting context parameter config\n *\n * @param config\n * @param parameter\n */\nfunction getContextParameterValues(config, parameter) {\n  return config.context && config.context[parameter] || [];\n}\n/**\n * Helper function for calculating default value for context parameter from config\n *\n * @param config\n * @param parameter\n */\nfunction getContextParameterDefault(config, parameter) {\n  const param = getContextParameterValues(config, parameter);\n  return param && param.length ? param[0] : undefined;\n}\nconst LANGUAGE_CONTEXT_ID = 'language';\nconst CURRENCY_CONTEXT_ID = 'currency';\nconst BASE_SITE_CONTEXT_ID = 'baseSite';\nconst THEME_CONTEXT_ID = 'theme';\nclass HttpParamsURIEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n}\nconst DEFAULT_SCOPE = 'default';\n\n/**\n * Joins the multiple parts with '/' to create a url\n *\n * @param parts the distinct parts of the url to join\n */\nfunction urlPathJoin(...parts) {\n  var _a, _b;\n  const paths = [];\n  parts = parts.filter(part => Boolean(part));\n  for (const part of parts) {\n    paths.push(cleanSlashes(part));\n  }\n  if ((_a = parts[0]) === null || _a === void 0 ? void 0 : _a.startsWith('/')) {\n    paths[0] = '/' + paths[0];\n  }\n  if ((_b = parts[parts.length - 1]) === null || _b === void 0 ? void 0 : _b.endsWith('/')) {\n    paths[paths.length - 1] = paths[paths.length - 1] + '/';\n  }\n  return paths.join('/');\n}\nfunction cleanSlashes(path) {\n  path = path.startsWith('/') ? path.slice(1) : path;\n  path = path.endsWith('/') ? path.slice(0, -1) : path;\n  return path;\n}\nconst LOAD_BASE_SITE = '[Site-context] Load BaseSite';\nconst LOAD_BASE_SITE_FAIL = '[Site-context] Load BaseSite Fail';\nconst LOAD_BASE_SITE_SUCCESS = '[Site-context] Load BaseSite Success';\nconst LOAD_BASE_SITES = '[Site-context] Load BaseSites';\nconst LOAD_BASE_SITES_FAIL = '[Site-context] Load BaseSites Fail';\nconst LOAD_BASE_SITES_SUCCESS = '[Site-context] Load BaseSites Success';\nconst SET_ACTIVE_BASE_SITE = '[Site-context] Set Active BaseSite';\nconst BASE_SITE_CHANGE = '[Site-context] BaseSite Change';\nclass LoadBaseSite {\n  constructor() {\n    this.type = LOAD_BASE_SITE;\n  }\n}\nclass LoadBaseSiteFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BASE_SITE_FAIL;\n  }\n}\nclass LoadBaseSiteSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BASE_SITE_SUCCESS;\n  }\n}\nclass LoadBaseSites {\n  constructor() {\n    this.type = LOAD_BASE_SITES;\n  }\n}\nclass LoadBaseSitesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BASE_SITES_FAIL;\n  }\n}\nclass LoadBaseSitesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BASE_SITES_SUCCESS;\n  }\n}\nclass SetActiveBaseSite {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = SET_ACTIVE_BASE_SITE;\n  }\n}\nclass BaseSiteChange {\n  constructor() {\n    this.type = BASE_SITE_CHANGE;\n  }\n}\nconst LOAD_CURRENCIES = '[Site-context] Load Currencies';\nconst LOAD_CURRENCIES_FAIL = '[Site-context] Load Currencies Fail';\nconst LOAD_CURRENCIES_SUCCESS = '[Site-context] Load Currencies Success';\nconst SET_ACTIVE_CURRENCY = '[Site-context] Set Active Currency';\nconst CURRENCY_CHANGE = '[Site-context] Currency Change';\nclass LoadCurrencies {\n  constructor() {\n    this.type = LOAD_CURRENCIES;\n  }\n}\nclass LoadCurrenciesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_CURRENCIES_FAIL;\n  }\n}\nclass LoadCurrenciesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_CURRENCIES_SUCCESS;\n  }\n}\nclass SetActiveCurrency {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = SET_ACTIVE_CURRENCY;\n  }\n}\nclass CurrencyChange {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = CURRENCY_CHANGE;\n  }\n}\nconst LOAD_LANGUAGES = '[Site-context] Load Languages';\nconst LOAD_LANGUAGES_FAIL = '[Site-context] Load Languages Fail';\nconst LOAD_LANGUAGES_SUCCESS = '[Site-context] Load Languages Success';\nconst SET_ACTIVE_LANGUAGE = '[Site-context] Set Active Language';\nconst LANGUAGE_CHANGE = '[Site-context] Language Change';\nclass LoadLanguages {\n  constructor() {\n    this.type = LOAD_LANGUAGES;\n  }\n}\nclass LoadLanguagesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_LANGUAGES_FAIL;\n  }\n}\nclass LoadLanguagesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_LANGUAGES_SUCCESS;\n  }\n}\nclass SetActiveLanguage {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = SET_ACTIVE_LANGUAGE;\n  }\n}\nclass LanguageChange {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LANGUAGE_CHANGE;\n  }\n}\nvar siteContextGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_BASE_SITE: LOAD_BASE_SITE,\n  LOAD_BASE_SITE_FAIL: LOAD_BASE_SITE_FAIL,\n  LOAD_BASE_SITE_SUCCESS: LOAD_BASE_SITE_SUCCESS,\n  LOAD_BASE_SITES: LOAD_BASE_SITES,\n  LOAD_BASE_SITES_FAIL: LOAD_BASE_SITES_FAIL,\n  LOAD_BASE_SITES_SUCCESS: LOAD_BASE_SITES_SUCCESS,\n  SET_ACTIVE_BASE_SITE: SET_ACTIVE_BASE_SITE,\n  BASE_SITE_CHANGE: BASE_SITE_CHANGE,\n  LoadBaseSite: LoadBaseSite,\n  LoadBaseSiteFail: LoadBaseSiteFail,\n  LoadBaseSiteSuccess: LoadBaseSiteSuccess,\n  LoadBaseSites: LoadBaseSites,\n  LoadBaseSitesFail: LoadBaseSitesFail,\n  LoadBaseSitesSuccess: LoadBaseSitesSuccess,\n  SetActiveBaseSite: SetActiveBaseSite,\n  BaseSiteChange: BaseSiteChange,\n  LOAD_CURRENCIES: LOAD_CURRENCIES,\n  LOAD_CURRENCIES_FAIL: LOAD_CURRENCIES_FAIL,\n  LOAD_CURRENCIES_SUCCESS: LOAD_CURRENCIES_SUCCESS,\n  SET_ACTIVE_CURRENCY: SET_ACTIVE_CURRENCY,\n  CURRENCY_CHANGE: CURRENCY_CHANGE,\n  LoadCurrencies: LoadCurrencies,\n  LoadCurrenciesFail: LoadCurrenciesFail,\n  LoadCurrenciesSuccess: LoadCurrenciesSuccess,\n  SetActiveCurrency: SetActiveCurrency,\n  CurrencyChange: CurrencyChange,\n  LOAD_LANGUAGES: LOAD_LANGUAGES,\n  LOAD_LANGUAGES_FAIL: LOAD_LANGUAGES_FAIL,\n  LOAD_LANGUAGES_SUCCESS: LOAD_LANGUAGES_SUCCESS,\n  SET_ACTIVE_LANGUAGE: SET_ACTIVE_LANGUAGE,\n  LANGUAGE_CHANGE: LANGUAGE_CHANGE,\n  LoadLanguages: LoadLanguages,\n  LoadLanguagesFail: LoadLanguagesFail,\n  LoadLanguagesSuccess: LoadLanguagesSuccess,\n  SetActiveLanguage: SetActiveLanguage,\n  LanguageChange: LanguageChange\n});\nconst SITE_CONTEXT_FEATURE = 'siteContext';\nconst getSiteContextState = createFeatureSelector(SITE_CONTEXT_FEATURE);\nconst sitesEntitiesSelector = state => state.entities;\nconst getBaseSiteState = createSelector(getSiteContextState, state => state.baseSite);\nconst getActiveBaseSite = createSelector(getSiteContextState, state => state && state.baseSite && state.baseSite.activeSite);\nconst getBaseSiteData = createSelector(getSiteContextState, state => state && state.baseSite && state.baseSite.details);\nconst getBaseSitesEntities = createSelector(getBaseSiteState, sitesEntitiesSelector);\nconst getAllBaseSites = createSelector(getBaseSitesEntities, entities => {\n  return entities ? Object.keys(entities).map(uid => entities[uid]) : null;\n});\nconst currenciesEntitiesSelector = state => state.entities;\nconst activeCurrencySelector = state => state.activeCurrency;\nconst getCurrenciesState = createSelector(getSiteContextState, state => state.currencies);\nconst getCurrenciesEntities = createSelector(getCurrenciesState, currenciesEntitiesSelector);\nconst getActiveCurrency = createSelector(getCurrenciesState, activeCurrencySelector);\nconst getAllCurrencies = createSelector(getCurrenciesEntities, entities => {\n  return entities ? Object.keys(entities).map(isocode => entities[isocode]) : null;\n});\nconst activeLanguageSelector = state => state.activeLanguage;\nconst languagesEntitiesSelector = state => state.entities;\nconst getLanguagesState = createSelector(getSiteContextState, state => state.languages);\nconst getLanguagesEntities = createSelector(getLanguagesState, languagesEntitiesSelector);\nconst getActiveLanguage = createSelector(getLanguagesState, activeLanguageSelector);\nconst getAllLanguages = createSelector(getLanguagesEntities, entities => {\n  return entities ? Object.keys(entities).map(isocode => entities[isocode]) : null;\n});\nvar siteContextGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getBaseSiteState: getBaseSiteState,\n  getActiveBaseSite: getActiveBaseSite,\n  getBaseSiteData: getBaseSiteData,\n  getBaseSitesEntities: getBaseSitesEntities,\n  getAllBaseSites: getAllBaseSites,\n  getCurrenciesState: getCurrenciesState,\n  getCurrenciesEntities: getCurrenciesEntities,\n  getActiveCurrency: getActiveCurrency,\n  getAllCurrencies: getAllCurrencies,\n  getLanguagesState: getLanguagesState,\n  getLanguagesEntities: getLanguagesEntities,\n  getActiveLanguage: getActiveLanguage,\n  getAllLanguages: getAllLanguages,\n  getSiteContextState: getSiteContextState\n});\nlet BaseSiteService = /*#__PURE__*/(() => {\n  class BaseSiteService {\n    constructor(store, config) {\n      this.store = store;\n      this.config = config;\n    }\n    /**\n     * Represents the current baseSite uid.\n     */\n    getActive() {\n      return this.store.pipe(select(getActiveBaseSite), filter(active => Boolean(active)));\n    }\n    /**\n     * Get all base sites data\n     */\n    getAll() {\n      return this.store.pipe(select(getAllBaseSites), tap(sites => {\n        if (!sites) {\n          this.store.dispatch(new LoadBaseSites());\n        }\n      }), filter(sites => Boolean(sites)));\n    }\n    /**\n     * Get base site data based on site uid\n     */\n    get(siteUid) {\n      if (siteUid) {\n        return this.getAll().pipe(map(sites => sites.find(site => site.uid === siteUid)));\n      }\n      return this.getActive().pipe(switchMap(activeSiteUid => this.getAll().pipe(map(sites => sites.find(site => site.uid === activeSiteUid)))));\n    }\n    setActive(baseSite) {\n      this.store.pipe(select(getActiveBaseSite), take(1)).subscribe(activeBaseSite => {\n        if (baseSite && activeBaseSite !== baseSite) {\n          this.store.dispatch(new SetActiveBaseSite(baseSite));\n        }\n      });\n    }\n    /**\n     * Tells whether the value of the base site has been already initialized\n     */\n    isInitialized() {\n      let valueInitialized = false;\n      this.getActive().subscribe(() => valueInitialized = true).unsubscribe();\n      return valueInitialized;\n    }\n    /**\n     * Tells whether the given iso code is allowed.\n     *\n     * The list of allowed iso codes can be configured in the `context` config of Spartacus.\n     */\n    isValid(value) {\n      return !!value && getContextParameterValues(this.config, BASE_SITE_CONTEXT_ID).includes(value);\n    }\n  }\n  BaseSiteService.ɵfac = function BaseSiteService_Factory(t) {\n    return new (t || BaseSiteService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(SiteContextConfig));\n  };\n  BaseSiteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BaseSiteService,\n    factory: BaseSiteService.ɵfac\n  });\n  return BaseSiteService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccEndpointsService = /*#__PURE__*/(() => {\n  class OccEndpointsService {\n    constructor(config, baseSiteService) {\n      this.config = config;\n      this.baseSiteService = baseSiteService;\n      if (this.baseSiteService) {\n        this.baseSiteService.getActive().subscribe(value => this._activeBaseSite = value);\n      }\n    }\n    get activeBaseSite() {\n      var _a;\n      return (_a = this._activeBaseSite) !== null && _a !== void 0 ? _a : getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID);\n    }\n    /**\n     * Returns the value configured for a specific endpoint\n     *\n     * @param endpointKey the configuration key for the endpoint to return\n     * @param scope endpoint configuration scope\n     */\n    getRawEndpointValue(endpoint, scope) {\n      const endpointValue = this.getEndpointForScope(endpoint, scope);\n      return endpointValue;\n    }\n    /**\n     * Returns true when the endpoint is configured\n     *\n     * @param endpointKey the configuration key for the endpoint to return\n     * @param scope endpoint configuration scope\n     */\n    isConfigured(endpoint, scope) {\n      return !(typeof this.getEndpointFromConfig(endpoint, scope) === 'undefined');\n    }\n    /**\n     * Returns base OCC endpoint (baseUrl + prefix + baseSite) base on provided values\n     *\n     * @param baseUrlProperties Specify properties to not add to the url (baseUrl, prefix, baseSite)\n     */\n    getBaseUrl(baseUrlProperties = {\n      baseUrl: true,\n      prefix: true,\n      baseSite: true\n    }) {\n      var _a, _b, _c, _d;\n      const baseUrl = baseUrlProperties.baseUrl === false ? '' : (_d = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.baseUrl) !== null && _d !== void 0 ? _d : '';\n      const prefix = baseUrlProperties.prefix === false ? '' : this.getPrefix();\n      const baseSite = baseUrlProperties.baseSite === false ? '' : this.activeBaseSite;\n      return urlPathJoin(baseUrl, prefix, baseSite);\n    }\n    /**\n     * Returns a fully qualified OCC Url\n     *\n     * @param endpoint Name of the OCC endpoint key\n     * @param attributes Dynamic attributes used to build the url\n     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)\n     */\n    buildUrl(endpoint, attributes, propertiesToOmit) {\n      let url = this.getEndpointForScope(endpoint, attributes === null || attributes === void 0 ? void 0 : attributes.scope);\n      if (attributes) {\n        const {\n          urlParams,\n          queryParams\n        } = attributes;\n        if (urlParams) {\n          url = StringTemplate.resolve(url, attributes.urlParams, true);\n        }\n        if (queryParams) {\n          let httpParamsOptions = {\n            encoder: new HttpParamsURIEncoder()\n          };\n          if (url.includes('?')) {\n            let queryParamsFromEndpoint;\n            [url, queryParamsFromEndpoint] = url.split('?');\n            httpParamsOptions = Object.assign(Object.assign({}, httpParamsOptions), {\n              fromString: queryParamsFromEndpoint\n            });\n          }\n          let httpParams = new HttpParams(httpParamsOptions);\n          Object.keys(queryParams).forEach(key => {\n            const value = queryParams[key];\n            if (value !== undefined) {\n              if (value === null) {\n                httpParams = httpParams.delete(key);\n              } else {\n                httpParams = httpParams.set(key, value);\n              }\n            }\n          });\n          const params = httpParams.toString();\n          if (params.length) {\n            url += '?' + params;\n          }\n        }\n      }\n      return this.buildUrlFromEndpointString(url, propertiesToOmit);\n    }\n    getEndpointFromConfig(endpoint, scope) {\n      var _a, _b;\n      const endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;\n      if (!endpointsConfig) {\n        return undefined;\n      }\n      const endpointConfig = endpointsConfig[endpoint];\n      if (scope) {\n        if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {\n          return endpointConfig;\n        }\n        return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];\n      }\n      return typeof endpointConfig === 'string' ? endpointConfig : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE];\n    }\n    // TODO: Can we reuse getEndpointFromConfig in this method? Should we change behavior of this function?\n    getEndpointForScope(endpoint, scope) {\n      var _a, _b;\n      const endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;\n      if (!Boolean(endpointsConfig)) {\n        return '';\n      }\n      const endpointConfig = endpointsConfig[endpoint];\n      if (scope) {\n        if (endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope]) {\n          return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];\n        }\n        if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {\n          return endpointConfig;\n        }\n        if (isDevMode()) {\n          console.warn(`${endpoint} endpoint configuration missing for scope \"${scope}\"`);\n        }\n      }\n      return (typeof endpointConfig === 'string' ? endpointConfig : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE]) || endpoint;\n    }\n    /**\n     * Add the base OCC url properties to the specified endpoint string\n     *\n     * @param endpointString String value for the url endpoint\n     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)\n     */\n    buildUrlFromEndpointString(endpointString, propertiesToOmit) {\n      return urlPathJoin(this.getBaseUrl(propertiesToOmit), endpointString);\n    }\n    getPrefix() {\n      var _a, _b, _c, _d, _e, _f, _g;\n      if (((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.prefix) && !this.config.backend.occ.prefix.startsWith('/')) {\n        return '/' + this.config.backend.occ.prefix;\n      }\n      return (_g = (_f = (_e = (_d = this.config) === null || _d === void 0 ? void 0 : _d.backend) === null || _e === void 0 ? void 0 : _e.occ) === null || _f === void 0 ? void 0 : _f.prefix) !== null && _g !== void 0 ? _g : '';\n    }\n  }\n  OccEndpointsService.ɵfac = function OccEndpointsService_Factory(t) {\n    return new (t || OccEndpointsService)(i0.ɵɵinject(OccConfig), i0.ɵɵinject(BaseSiteService, 8));\n  };\n  OccEndpointsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccEndpointsService,\n    factory: OccEndpointsService.ɵfac,\n    providedIn: 'root'\n  });\n  return OccEndpointsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Interceptor for handling requests with `USE_CLIENT_TOKEN` header.\n * Provides `Authorization` header with client token and handles errors related to client auth.\n */\nlet ClientTokenInterceptor = /*#__PURE__*/(() => {\n  class ClientTokenInterceptor {\n    constructor(clientTokenService, clientErrorHandlingService, occEndpoints) {\n      this.clientTokenService = clientTokenService;\n      this.clientErrorHandlingService = clientErrorHandlingService;\n      this.occEndpoints = occEndpoints;\n    }\n    intercept(request, next) {\n      const isClientTokenRequest = this.isClientTokenRequest(request);\n      if (isClientTokenRequest) {\n        request = InterceptorUtil.removeHeader(USE_CLIENT_TOKEN, request);\n      }\n      return this.getClientToken(isClientTokenRequest).pipe(take(1), switchMap(token => {\n        if ((token === null || token === void 0 ? void 0 : token.access_token) && request.url.includes(this.occEndpoints.getBaseUrl())) {\n          request = request.clone({\n            setHeaders: {\n              Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`\n            }\n          });\n        }\n        return next.handle(request).pipe(catchError(errResponse => {\n          if (errResponse instanceof HttpErrorResponse) {\n            if (errResponse.status === 401) {\n              if (isClientTokenRequest) {\n                if (this.isExpiredToken(errResponse)) {\n                  return this.clientErrorHandlingService.handleExpiredClientToken(request, next);\n                }\n              }\n            }\n          }\n          return throwError(errResponse);\n        }));\n      }));\n    }\n    getClientToken(isClientTokenRequest) {\n      if (isClientTokenRequest) {\n        return this.clientTokenService.getClientToken();\n      }\n      return of(null);\n    }\n    isClientTokenRequest(request) {\n      const isRequestMapping = InterceptorUtil.getInterceptorParam(USE_CLIENT_TOKEN, request.headers);\n      return Boolean(isRequestMapping);\n    }\n    isExpiredToken(resp) {\n      var _a, _b, _c;\n      return ((_c = (_b = (_a = resp.error) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === 'InvalidTokenError';\n    }\n  }\n  ClientTokenInterceptor.ɵfac = function ClientTokenInterceptor_Factory(t) {\n    return new (t || ClientTokenInterceptor)(i0.ɵɵinject(ClientTokenService), i0.ɵɵinject(ClientErrorHandlingService), i0.ɵɵinject(OccEndpointsService));\n  };\n  ClientTokenInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClientTokenInterceptor,\n    factory: ClientTokenInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return ClientTokenInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst interceptors$2 = [{\n  provide: HTTP_INTERCEPTORS,\n  useExisting: ClientTokenInterceptor,\n  multi: true\n}];\nvar StorageSyncType = /*#__PURE__*/(() => {\n  (function (StorageSyncType) {\n    StorageSyncType[\"NO_STORAGE\"] = \"NO_STORAGE\";\n    StorageSyncType[\"LOCAL_STORAGE\"] = \"LOCAL_STORAGE\";\n    StorageSyncType[\"SESSION_STORAGE\"] = \"SESSION_STORAGE\";\n  })(StorageSyncType || (StorageSyncType = {}));\n  return StorageSyncType;\n})();\nvar StateTransferType = /*#__PURE__*/(() => {\n  (function (StateTransferType) {\n    StateTransferType[\"TRANSFER_STATE\"] = \"SSR\";\n  })(StateTransferType || (StateTransferType = {}));\n  return StateTransferType;\n})();\nlet StateConfig = /*#__PURE__*/(() => {\n  class StateConfig {}\n  StateConfig.ɵfac = function StateConfig_Factory(t) {\n    return new (t || StateConfig)();\n  };\n  StateConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateConfig,\n    factory: function StateConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || StateConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return StateConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getStorage(storageType, winRef) {\n  let storage;\n  switch (storageType) {\n    case StorageSyncType.LOCAL_STORAGE:\n      {\n        storage = winRef.localStorage;\n        break;\n      }\n    case StorageSyncType.SESSION_STORAGE:\n      {\n        storage = winRef.sessionStorage;\n        break;\n      }\n    case StorageSyncType.NO_STORAGE:\n      {\n        storage = undefined;\n        break;\n      }\n    default:\n      {\n        storage = winRef.sessionStorage;\n      }\n  }\n  return storage;\n}\nfunction persistToStorage(configKey, value, storage) {\n  if (!isSsr(storage) && value) {\n    storage.setItem(configKey, JSON.stringify(value));\n  }\n}\nfunction readFromStorage(storage, key) {\n  if (isSsr(storage)) {\n    return;\n  }\n  const storageValue = storage.getItem(key);\n  if (!storageValue) {\n    return;\n  }\n  return JSON.parse(storageValue);\n}\nfunction isSsr(storage) {\n  return !Boolean(storage);\n}\nlet StatePersistenceService = /*#__PURE__*/(() => {\n  class StatePersistenceService {\n    constructor(winRef) {\n      this.winRef = winRef;\n    }\n    /**\n     * Helper to synchronize state to more persistent storage (localStorage, sessionStorage).\n     * It is context aware, so you can keep different state for te same feature based on specified context.\n     *\n     * Eg. cart is valid only under the same base site. So you want to synchronize cart only with the same base site.\n     * Usage for that case: `syncWithStorage({ key: 'cart', state$: activeCartSelector$, context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]), onRead: (state) => setCorrectStateInStore(state) })`.\n     * Active cart for the `electronics` base site will be stored under `spartacus⚿electronics⚿cart` and for apparel under `spartacus⚿apparel⚿cart`.\n     *\n     * On each context change onRead function will be executed with state from storage provided as a parameter.\n     *\n     * Omitting context$ will trigger onRead only once at initialization.\n     *\n     * @param key Key to use in storage for the synchronized state. Should be unique for each feature.\n     * @param state$ State to be saved and later restored.\n     * @param context$ Context for state\n     * @param storageType Storage type to be used to persist state\n     * @param onRead Function to be executed on each storage read after context change\n     *\n     * @returns Subscriptions for reading/writing in storage on context/state change\n     */\n    syncWithStorage({\n      key,\n      state$,\n      context$ = of(''),\n      storageType = StorageSyncType.LOCAL_STORAGE,\n      onRead = () => {}\n    }) {\n      const storage = getStorage(storageType, this.winRef);\n      const subscriptions = new Subscription();\n      // Do not change order of subscription! Read should happen before write on context change.\n      subscriptions.add(context$.pipe(map(context => {\n        return readFromStorage(storage, this.generateKeyWithContext(context, key));\n      }), tap(state => onRead(state))).subscribe());\n      subscriptions.add(state$.pipe(withLatestFrom(context$)).subscribe(([state, context]) => {\n        persistToStorage(this.generateKeyWithContext(context, key), state, storage);\n      }));\n      return subscriptions;\n    }\n    /**\n     * Helper to read state from persistent storage (localStorage, sessionStorage).\n     * It is useful if you need synchronously access state saved with `syncWithStorage`.\n     *\n     * @param key Key to use in storage for state. Should be unique for each feature.\n     * @param context Context value for state\n     * @param storageType Storage type from to read state\n     *\n     * @returns State from the storage\n     */\n    readStateFromStorage({\n      key,\n      context = '',\n      storageType = StorageSyncType.LOCAL_STORAGE\n    }) {\n      const storage = getStorage(storageType, this.winRef);\n      return readFromStorage(storage, this.generateKeyWithContext(context, key));\n    }\n    generateKeyWithContext(context, key) {\n      return `spartacus⚿${[].concat(context).join('⚿')}⚿${key}`;\n    }\n  }\n  StatePersistenceService.ɵfac = function StatePersistenceService_Factory(t) {\n    return new (t || StatePersistenceService)(i0.ɵɵinject(WindowRef));\n  };\n  StatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StatePersistenceService,\n    factory: StatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return StatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Responsible for saving the authorization data (userId, token, redirectUrl) in browser storage.\n */\nlet AuthStatePersistenceService = /*#__PURE__*/(() => {\n  class AuthStatePersistenceService {\n    constructor(statePersistenceService, userIdService, authStorageService, authRedirectStorageService) {\n      this.statePersistenceService = statePersistenceService;\n      this.userIdService = userIdService;\n      this.authStorageService = authStorageService;\n      this.authRedirectStorageService = authRedirectStorageService;\n      this.subscription = new Subscription();\n      /**\n       * Identifier used for storage key.\n       */\n      this.key = 'auth';\n    }\n    /**\n     * Initializes the synchronization between state and browser storage.\n     */\n    initSync() {\n      this.subscription.add(this.statePersistenceService.syncWithStorage({\n        key: this.key,\n        state$: this.getAuthState(),\n        onRead: state => this.onRead(state)\n      }));\n    }\n    /**\n     * Gets and transforms state from different sources into the form that should\n     * be saved in storage.\n     */\n    getAuthState() {\n      return combineLatest([this.authStorageService.getToken().pipe(filter(state => !!state), map(state => {\n        return Object.assign({}, state);\n      })), this.userIdService.getUserId(), this.authRedirectStorageService.getRedirectUrl()]).pipe(map(([authToken, userId, redirectUrl]) => {\n        let token = authToken;\n        if (token) {\n          token = Object.assign({}, token);\n          // To minimize risk of user account hijacking we don't persist user refresh_token\n          delete token.refresh_token;\n        }\n        return {\n          token,\n          userId,\n          redirectUrl\n        };\n      }));\n    }\n    /**\n     * Function called on each browser storage read.\n     * Used to update state from browser -> state.\n     */\n    onRead(state) {\n      if (state === null || state === void 0 ? void 0 : state.token) {\n        this.authStorageService.setToken(state.token);\n      }\n      if (state === null || state === void 0 ? void 0 : state.redirectUrl) {\n        this.authRedirectStorageService.setRedirectUrl(state.redirectUrl);\n      }\n      if (state === null || state === void 0 ? void 0 : state.userId) {\n        this.userIdService.setUserId(state.userId);\n      } else {\n        this.userIdService.clearUserId();\n      }\n    }\n    /**\n     * Reads synchronously state from storage and returns it.\n     */\n    readStateFromStorage() {\n      return this.statePersistenceService.readStateFromStorage({\n        key: this.key\n      });\n    }\n    /**\n     * Check synchronously in browser storage if user is logged in (required by transfer state reducer).\n     * For most cases `isUserLoggedIn` from the `AuthService` should be used instead of this.\n     */\n    isUserLoggedIn() {\n      var _a, _b;\n      return Boolean((_b = (_a = this.readStateFromStorage()) === null || _a === void 0 ? void 0 : _a.token) === null || _b === void 0 ? void 0 : _b.access_token);\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  AuthStatePersistenceService.ɵfac = function AuthStatePersistenceService_Factory(t) {\n    return new (t || AuthStatePersistenceService)(i0.ɵɵinject(StatePersistenceService), i0.ɵɵinject(UserIdService), i0.ɵɵinject(AuthStorageService), i0.ɵɵinject(AuthRedirectStorageService));\n  };\n  AuthStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthStatePersistenceService,\n    factory: AuthStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CX_KEY = makeStateKey('cx-state');\nfunction getTransferStateReducer(platformId, transferState, config, authStatePersistenceService) {\n  var _a, _b;\n  if (transferState && ((_b = (_a = config === null || config === void 0 ? void 0 : config.state) === null || _a === void 0 ? void 0 : _a.ssrTransfer) === null || _b === void 0 ? void 0 : _b.keys)) {\n    if (isPlatformBrowser(platformId)) {\n      return getBrowserTransferStateReducer(transferState, config.state.ssrTransfer.keys, Boolean(authStatePersistenceService === null || authStatePersistenceService === void 0 ? void 0 : authStatePersistenceService.isUserLoggedIn()));\n    } else if (isPlatformServer(platformId)) {\n      return getServerTransferStateReducer(transferState, config.state.ssrTransfer.keys);\n    }\n  }\n  return reducer => reducer;\n}\nfunction getServerTransferStateReducer(transferState, keys) {\n  const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);\n  return function (reducer) {\n    return function (state, action) {\n      const newState = reducer(state, action);\n      if (newState) {\n        const stateSlice = getStateSlice(transferStateKeys, [], newState);\n        transferState.set(CX_KEY, stateSlice);\n      }\n      return newState;\n    };\n  };\n}\nfunction getBrowserTransferStateReducer(transferState, keys, isLoggedIn) {\n  const transferStateKeys = filterKeysByType(keys, StateTransferType.TRANSFER_STATE);\n  return function (reducer) {\n    return function (state, action) {\n      if (action.type === INIT) {\n        if (!state) {\n          state = reducer(state, action);\n        }\n        if (!isLoggedIn && transferState.hasKey(CX_KEY)) {\n          const cxKey = transferState.get(CX_KEY, {});\n          const transferredStateSlice = getStateSlice(transferStateKeys, [], cxKey);\n          state = deepMerge({}, state, transferredStateSlice);\n        }\n        return state;\n      }\n      return reducer(state, action);\n    };\n  };\n}\nconst TRANSFER_STATE_META_REDUCER = new InjectionToken('TransferStateMetaReducer');\nconst stateMetaReducers = [{\n  provide: TRANSFER_STATE_META_REDUCER,\n  useFactory: getTransferStateReducer,\n  deps: [PLATFORM_ID, [new Optional(), TransferState], [new Optional(), Config], [new Optional(), AuthStatePersistenceService]]\n}, {\n  provide: META_REDUCERS,\n  useExisting: TRANSFER_STATE_META_REDUCER,\n  multi: true\n}];\nlet StateModule = /*#__PURE__*/(() => {\n  class StateModule {\n    static forRoot() {\n      return {\n        ngModule: StateModule,\n        providers: [...stateMetaReducers]\n      };\n    }\n  }\n  StateModule.ɵfac = function StateModule_Factory(t) {\n    return new (t || StateModule)();\n  };\n  StateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StateModule\n  });\n  StateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StateModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Normalizes HttpErrorResponse to HttpErrorModel.\n *\n * Can be used as a safe and generic way for embodying http errors into\n * NgRx Action payload, as it will strip potentially unserializable parts from\n * it and warn in debug mode if passed error is not instance of HttpErrorModel\n * (which usually happens when logic in NgRx Effect is not sealed correctly)\n */\nfunction normalizeHttpError(error) {\n  if (error instanceof HttpErrorResponse) {\n    const normalizedError = new HttpErrorModel();\n    normalizedError.message = error.message;\n    normalizedError.status = error.status;\n    normalizedError.statusText = error.statusText;\n    normalizedError.url = error.url;\n    // include backend's error details\n    if (Array.isArray(error.error.errors)) {\n      normalizedError.details = error.error.errors;\n    } else if (typeof error.error.error === 'string') {\n      normalizedError.details = [{\n        type: error.error.error,\n        message: error.error.error_description\n      }];\n    }\n    return normalizedError;\n  }\n  if (isDevMode()) {\n    console.error('Error passed to normalizeHttpError is not HttpErrorResponse instance', error);\n  }\n  return undefined;\n}\n\n/**\n * Responsible for requesting from OAuth server `ClientToken` for a particular\n * auth client.\n */\nlet ClientAuthenticationTokenService = /*#__PURE__*/(() => {\n  class ClientAuthenticationTokenService {\n    constructor(http, authConfigService) {\n      this.http = http;\n      this.authConfigService = authConfigService;\n    }\n    /**\n     * Loads token with client authentication flow.\n     *\n     * @returns observable with ClientToken\n     */\n    loadClientAuthenticationToken() {\n      const url = this.authConfigService.getTokenEndpoint();\n      const params = new HttpParams().set('client_id', encodeURIComponent(this.authConfigService.getClientId())).set('client_secret', encodeURIComponent(this.authConfigService.getClientSecret())).set('grant_type', 'client_credentials');\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      return this.http.post(url, params, {\n        headers\n      });\n    }\n  }\n  ClientAuthenticationTokenService.ɵfac = function ClientAuthenticationTokenService_Factory(t) {\n    return new (t || ClientAuthenticationTokenService)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(AuthConfigService));\n  };\n  ClientAuthenticationTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClientAuthenticationTokenService,\n    factory: ClientAuthenticationTokenService.ɵfac,\n    providedIn: 'root'\n  });\n  return ClientAuthenticationTokenService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClientTokenEffect = /*#__PURE__*/(() => {\n  class ClientTokenEffect {\n    constructor(actions$, clientAuthenticationTokenService) {\n      this.actions$ = actions$;\n      this.clientAuthenticationTokenService = clientAuthenticationTokenService;\n      this.loadClientToken$ = this.actions$.pipe(ofType(LOAD_CLIENT_TOKEN), exhaustMap(() => {\n        return this.clientAuthenticationTokenService.loadClientAuthenticationToken().pipe(map(token => {\n          return new LoadClientTokenSuccess(token);\n        }), catchError(error => of(new LoadClientTokenFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  ClientTokenEffect.ɵfac = function ClientTokenEffect_Factory(t) {\n    return new (t || ClientTokenEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(ClientAuthenticationTokenService));\n  };\n  ClientTokenEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClientTokenEffect,\n    factory: ClientTokenEffect.ɵfac\n  });\n  __decorate([Effect()], ClientTokenEffect.prototype, \"loadClientToken$\", void 0);\n  return ClientTokenEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$6 = [ClientTokenEffect];\nfunction getReducers$8() {\n  return {\n    clientToken: loaderReducer(CLIENT_TOKEN_DATA)\n  };\n}\nconst reducerToken$8 = new InjectionToken('ClientAuthReducers');\nconst reducerProvider$8 = {\n  provide: reducerToken$8,\n  useFactory: getReducers$8\n};\nlet ClientAuthStoreModule = /*#__PURE__*/(() => {\n  class ClientAuthStoreModule {}\n  ClientAuthStoreModule.ɵfac = function ClientAuthStoreModule_Factory(t) {\n    return new (t || ClientAuthStoreModule)();\n  };\n  ClientAuthStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ClientAuthStoreModule\n  });\n  ClientAuthStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerProvider$8],\n    imports: [[CommonModule, HttpClientModule, StateModule, StoreModule.forFeature(CLIENT_AUTH_FEATURE, reducerToken$8), EffectsModule.forFeature(effects$6)]]\n  });\n  return ClientAuthStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Some of the OCC endpoints require Authorization header with the client token (eg. user registration).\n * This pattern should not be used in the frontend apps, but until OCC changes this requirement\n * we provide this module to support using those endpoints.\n *\n * After OCC improvements regarding client authentication this module can be safely removed.\n */\nlet ClientAuthModule = /*#__PURE__*/(() => {\n  class ClientAuthModule {\n    static forRoot() {\n      return {\n        ngModule: ClientAuthModule,\n        providers: [...interceptors$2]\n      };\n    }\n  }\n  ClientAuthModule.ɵfac = function ClientAuthModule_Factory(t) {\n    return new (t || ClientAuthModule)();\n  };\n  ClientAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ClientAuthModule\n  });\n  ClientAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, ClientAuthStoreModule]]\n  });\n  return ClientAuthModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CONFIG_INITIALIZER = new InjectionToken('ConfigInitializer');\nconst CONFIG_INITIALIZER_FORROOT_GUARD = new InjectionToken('CONFIG_INITIALIZER_FORROOT_GUARD');\n\n/**\n * Provides support for CONFIG_INITIALIZERS\n */\nlet ConfigInitializerService = /*#__PURE__*/(() => {\n  class ConfigInitializerService {\n    constructor(config, initializerGuard, rootConfig) {\n      this.config = config;\n      this.initializerGuard = initializerGuard;\n      this.rootConfig = rootConfig;\n      this.ongoingScopes$ = new BehaviorSubject(undefined);\n    }\n    /**\n     * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly\n     */\n    get isStable() {\n      var _a;\n      return !this.initializerGuard || ((_a = this.ongoingScopes$.value) === null || _a === void 0 ? void 0 : _a.length) === 0;\n    }\n    /**\n     * Recommended way to get config for code that can run before app will finish\n     * initialization (APP_INITIALIZERS, selected service constructors)\n     *\n     * Used without parameters waits for the whole config to become stable\n     *\n     * Parameters allow to describe which part of the config should be stable using\n     * string describing config part, e.g.:\n     * 'siteContext', 'siteContext.language', etc.\n     *\n     * @param scopes String describing parts of the config we want to be sure are stable\n     */\n    getStable(...scopes) {\n      if (this.isStable) {\n        return of(this.config);\n      }\n      return this.ongoingScopes$.pipe(filter(ongoingScopes => !!ongoingScopes && this.areReady(scopes, ongoingScopes)), take(1), mapTo(this.config));\n    }\n    /**\n     * Removes provided scopes from currently ongoingScopes\n     *\n     * @param scopes\n     */\n    finishScopes(scopes) {\n      var _a;\n      const newScopes = [...((_a = this.ongoingScopes$.value) !== null && _a !== void 0 ? _a : [])];\n      for (const scope of scopes) {\n        newScopes.splice(newScopes.indexOf(scope), 1);\n      }\n      this.ongoingScopes$.next(newScopes);\n    }\n    /**\n     * Return true if provided scopes are not part of ongoingScopes\n     *\n     * @param scopes\n     * @param ongoingScopes\n     */\n    areReady(scopes, ongoingScopes) {\n      if (!scopes.length) {\n        return !ongoingScopes.length;\n      }\n      for (const scope of scopes) {\n        for (const ongoingScope of ongoingScopes) {\n          if (this.scopesOverlap(scope, ongoingScope)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    /**\n     * Check if two scopes overlap.\n     *\n     * Example of scopes that overlap:\n     * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'\n     *\n     * Example of scopes that do not overlap:\n     * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'\n     *\n     * @param a ScopeA\n     * @param b ScopeB\n     */\n    scopesOverlap(a, b) {\n      if (b.length > a.length) {\n        [a, b] = [b, a];\n      }\n      return a.startsWith(b) && (a[b.length] || '.') === '.';\n    }\n    /**\n     * @internal\n     *\n     * Not a part of a public API, used by APP_INITIALIZER to initialize all provided CONFIG_INITIALIZERS\n     *\n     */\n    initialize(initializers) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (this.ongoingScopes$.value) {\n          // guard for double initialization\n          return;\n        }\n        const ongoingScopes = [];\n        const asyncConfigs = [];\n        for (const initializer of initializers || []) {\n          if (!initializer) {\n            continue;\n          }\n          if (!initializer.scopes || !initializer.scopes.length) {\n            throw new Error('CONFIG_INITIALIZER should provide scope!');\n          }\n          if (isDevMode() && !this.areReady(initializer.scopes, ongoingScopes)) {\n            console.warn('More than one CONFIG_INITIALIZER is initializing the same config scope.');\n          }\n          ongoingScopes.push(...initializer.scopes);\n          asyncConfigs.push((() => __awaiter(this, void 0, void 0, function* () {\n            const initializerConfig = yield initializer.configFactory();\n            // contribute configuration to rootConfig\n            deepMerge(this.rootConfig, initializerConfig);\n            // contribute configuration to global config\n            deepMerge(this.config, initializerConfig);\n            this.finishScopes(initializer.scopes);\n          }))());\n        }\n        this.ongoingScopes$.next(ongoingScopes);\n        if (asyncConfigs.length) {\n          yield Promise.all(asyncConfigs);\n        }\n      });\n    }\n  }\n  ConfigInitializerService.ɵfac = function ConfigInitializerService_Factory(t) {\n    return new (t || ConfigInitializerService)(i0.ɵɵinject(Config), i0.ɵɵinject(CONFIG_INITIALIZER_FORROOT_GUARD, 8), i0.ɵɵinject(RootConfig));\n  };\n  ConfigInitializerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigInitializerService,\n    factory: ConfigInitializerService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConfigInitializerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ConfigValidatorToken = new InjectionToken('ConfigurationValidator');\n/**\n * Use to probide config validation at app bootstrap (when all config chunks are merged)\n *\n * @param configValidator\n */\nfunction provideConfigValidator(configValidator) {\n  return {\n    provide: ConfigValidatorToken,\n    useValue: configValidator,\n    multi: true\n  };\n}\nfunction validateConfig(config, configValidators) {\n  for (const validate of configValidators) {\n    const warning = validate(config);\n    if (warning) {\n      console.warn(warning);\n    }\n  }\n}\nfunction baseUrlConfigValidator(config) {\n  var _a, _b, _c, _d, _e;\n  if (typeof ((_a = config === null || config === void 0 ? void 0 : config.authentication) === null || _a === void 0 ? void 0 : _a.baseUrl) === 'undefined' && typeof ((_c = (_b = config === null || config === void 0 ? void 0 : config.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.baseUrl) === 'undefined' &&\n  // Don't show warning when user tries to work around the issue.\n  ((_e = (_d = config === null || config === void 0 ? void 0 : config.authentication) === null || _d === void 0 ? void 0 : _d.OAuthLibConfig) === null || _e === void 0 ? void 0 : _e.requireHttps) !== false) {\n    return 'Authentication might not work correctly without setting either authentication.baseUrl or backend.occ.baseUrl configuration option! Workaround: To support relative urls in angular-oauth2-oidc library you can try setting authentication.OAuthLibConfig.requireHttps to false.';\n  }\n}\nconst defaultAuthConfig = {\n  authentication: {\n    client_id: 'mobile_android',\n    client_secret: 'secret',\n    tokenEndpoint: '/oauth/token',\n    revokeEndpoint: '/oauth/revoke',\n    loginUrl: '/oauth/authorize',\n    OAuthLibConfig: {\n      scope: '',\n      customTokenParameters: ['token_type'],\n      strictDiscoveryDocumentValidation: false,\n      skipIssuerCheck: true,\n      disablePKCE: true,\n      oidc: false,\n      clearHashAfterLogin: false\n    }\n  }\n};\n\n/**\n * Creates an instance of the given class and fills its properties with the given data.\n *\n * @param type reference to the class\n * @param data object with properties to be copied to the class\n */\nfunction createFrom(type, data) {\n  return Object.assign(new type(), data);\n}\n\n/**\n * Intended to be inherited by all other Spartacus' events.\n *\n * \"One event to rule them all\".\n */\nlet CxEvent = /*#__PURE__*/(() => {\n  class CxEvent {}\n  /**\n   * Event's type\n   */\n  CxEvent.type = 'CxEvent';\n\n  /**\n   * Indicates that the user has logged out\n   *\n   * * The event is fired even for customer emulation\n   * * The event is NOT fired for a ASM support agent authentication\n   */\n  return CxEvent;\n})();\nlet LogoutEvent = /*#__PURE__*/(() => {\n  class LogoutEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  LogoutEvent.type = 'LogoutEvent';\n  /**\n   * Indicates that the user has logged in\n   *\n   * * The event is fired even for customer emulation\n   * * The event is NOT fired for a ASM support agent authentication\n   */\n  return LogoutEvent;\n})();\nlet LoginEvent = /*#__PURE__*/(() => {\n  class LoginEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  LoginEvent.type = 'LoginEvent';\n\n  // PRIVATE API\n  /**\n   * Allows for dynamic adding and removing source observables\n   * and exposes them as one merged observable at a property `output$`.\n   *\n   * Thanks to the `share()` operator used inside, it subscribes to source observables\n   * only when someone subscribes to it. And it unsubscribes from source observables\n   * when the counter of consumers drops to 0.\n   *\n   * **To avoid memory leaks**, all manually added sources should be manually removed\n   * when not plan to emit values anymore. In particular closed event sources won't be\n   * automatically removed.\n   */\n  return LoginEvent;\n})();\nclass MergingSubject {\n  constructor() {\n    /**\n     * List of already added sources (but not removed yet)\n     */\n    this.sources = [];\n    /**\n     * For each source: it stores a subscription responsible for\n     * passing all values from source to the consumer\n     */\n    this.subscriptionsToSources = new Map();\n    /**\n     * Observable with all sources merged.\n     *\n     * Only after subscribing to it, under the hood it subscribes to the source observables.\n     * When the number of subscribers drops to 0, it unsubscribes from all source observables.\n     * But if later on something subscribes to it again, it subscribes to the source observables again.\n     *\n     * It multicasts the emissions for each subscriber.\n     */\n    this.output$ = new Observable(consumer => {\n      // There can be only 0 or 1 consumer of this observable coming from the `share()` operator\n      // that is piped right after this observable.\n      // `share()` not only multicasts the results but also  When all end-subscribers unsubscribe from `share()` operator, it will unsubscribe\n      // from this observable (by the nature `refCount`-nature of the `share()` operator).\n      this.consumer = consumer;\n      this.bindAllSourcesToConsumer(consumer);\n      return () => {\n        this.consumer = null;\n        this.unbindAllSourcesFromConsumer();\n      };\n    }).pipe(share());\n    /**\n     * Reference to the subscriber coming from the `share()` operator piped to the `output$` observable.\n     * For more, see docs of the `output$` observable;\n     */\n    this.consumer = null;\n  }\n  /**\n   * Registers the given source to pass its values to the `output$` observable.\n   *\n   * It does nothing, when the source has been already added (but not removed yet).\n   */\n  add(source) {\n    if (this.has(source)) {\n      return;\n    }\n    if (this.consumer) {\n      this.bindSourceToConsumer(source, this.consumer);\n    }\n    this.sources.push(source);\n  }\n  /**\n   * Starts passing all values from already added sources to consumer\n   */\n  bindAllSourcesToConsumer(consumer) {\n    this.sources.forEach(source => this.bindSourceToConsumer(source, consumer));\n  }\n  /**\n   * Stops passing all values from already added sources to consumer\n   * (if any consumer is active at the moment)\n   */\n  unbindAllSourcesFromConsumer() {\n    this.sources.forEach(source => this.unbindSourceFromConsumer(source));\n  }\n  /**\n   * Starts passing all values from a single source to consumer\n   */\n  bindSourceToConsumer(source, consumer) {\n    const subscriptionToSource = source.subscribe(val => consumer.next(val)); // passes all emissions from source to consumer\n    this.subscriptionsToSources.set(source, subscriptionToSource);\n  }\n  /**\n   * Stops passing all values from a single source to consumer\n   * (if any consumer is active at the moment)\n   */\n  unbindSourceFromConsumer(source) {\n    const subscriptionToSource = this.subscriptionsToSources.get(source);\n    if (subscriptionToSource !== undefined) {\n      subscriptionToSource.unsubscribe();\n      this.subscriptionsToSources.delete(source);\n    }\n  }\n  /**\n   * Unregisters the given source so it stops passing its values to `output$` observable.\n   *\n   * Should be used when a source is no longer maintained **to avoid memory leaks**.\n   */\n  remove(source) {\n    // clear binding from source to consumer (if any consumer exists at the moment)\n    this.unbindSourceFromConsumer(source);\n    // remove source from array\n    let i;\n    if ((i = this.sources.findIndex(s => s === source)) !== -1) {\n      this.sources.splice(i, 1);\n    }\n  }\n  /**\n   * Returns whether the given source has been already addded\n   */\n  has(source) {\n    return this.sources.includes(source);\n  }\n}\n\n/**\n * A service to register and observe event sources. Events are driven by event types, which are class signatures\n * for the given event.\n *\n * It is possible to register multiple sources to a single event, even without\n * knowing as multiple decoupled features can attach sources to the same\n * event type.\n */\nlet EventService = /*#__PURE__*/(() => {\n  class EventService {\n    constructor() {\n      /**\n       * The various events meta are collected in a map, stored by the event type class\n       */\n      this.eventsMeta = new Map();\n    }\n    /**\n     * Register an event source for the given event type.\n     *\n     * CAUTION: To avoid memory leaks, the returned teardown function should be called\n     *  when the event source is no longer maintained by its creator\n     * (i.e. in `ngOnDestroy` if the event source was registered in the component).\n     *\n     * @since 3.1 - registers the given `source$` for the parent classes of the given `eventType`.\n     *\n     * @param eventType the event type\n     * @param source$ an observable that represents the source\n     *\n     * @returns a teardown function which unregisters the given event source\n     */\n    register(eventType, source$) {\n      const eventMeta = this.getEventMeta(eventType);\n      if (eventMeta.mergingSubject.has(source$)) {\n        if (isDevMode()) {\n          console.warn(`EventService: the event source`, source$, `has been already registered for the type`, eventType);\n        }\n      } else {\n        eventMeta.mergingSubject.add(source$);\n      }\n      return () => eventMeta.mergingSubject.remove(source$);\n    }\n    /**\n     * Returns a stream of events for the given event type\n     * @param eventTypes event type\n     */\n    get(eventType) {\n      let output$ = this.getEventMeta(eventType).mergingSubject.output$;\n      if (isDevMode()) {\n        output$ = this.getValidatedEventStream(output$, eventType);\n      }\n      return output$;\n    }\n    /**\n     * Dispatches an instance of an individual event.\n     * If the eventType is provided a new event will be created for that type and with the event data.\n     *\n     * @param event an event\n     * @param eventType (optional) - type of event\n     */\n    dispatch(event, eventType) {\n      if (!eventType) {\n        eventType = event.constructor;\n      } else if (!(event instanceof eventType)) {\n        event = createFrom(eventType, event);\n      }\n      const inputSubject$ = this.getInputSubject(eventType);\n      inputSubject$.next(event);\n    }\n    /**\n     * Returns the input subject used to dispatch a single event.\n     * The subject is created on demand, when it's needed for the first time.\n     * @param eventType type of event\n     */\n    getInputSubject(eventType) {\n      const eventMeta = this.getEventMeta(eventType);\n      if (!eventMeta.inputSubject$) {\n        eventMeta.inputSubject$ = new Subject();\n        this.register(eventType, eventMeta.inputSubject$);\n      }\n      return eventMeta.inputSubject$;\n    }\n    /**\n     * Returns the event meta object for the given event type\n     */\n    getEventMeta(eventType) {\n      if (!this.eventsMeta.get(eventType)) {\n        if (isDevMode()) {\n          this.validateEventType(eventType);\n        }\n        this.createEventMeta(eventType);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.eventsMeta.get(eventType);\n    }\n    createEventMeta(eventType) {\n      const eventMeta = {\n        inputSubject$: null,\n        mergingSubject: new MergingSubject()\n      };\n      this.eventsMeta.set(eventType, eventMeta);\n      let parentEvent = Object.getPrototypeOf(eventType);\n      while (parentEvent !== null && Object.getPrototypeOf(parentEvent) !== Object.getPrototypeOf({})) {\n        this.register(parentEvent, eventMeta.mergingSubject.output$);\n        parentEvent = Object.getPrototypeOf(parentEvent);\n      }\n    }\n    /**\n     * Checks if the event type is a valid type (is a class with constructor).\n     *\n     * Should be used only in dev mode.\n     */\n    validateEventType(eventType) {\n      if (!(eventType === null || eventType === void 0 ? void 0 : eventType.constructor)) {\n        throw new Error(`EventService:  ${eventType} is not a valid event type. Please provide a class reference.`);\n      }\n      this.validateCxEvent(eventType);\n    }\n    /**\n     * Validates if the given type (or its prototype chain) extends from the CxEvent.\n     *\n     * Should be used only in the dev mode.\n     */\n    validateCxEvent(eventType) {\n      let parentType = eventType;\n      while (parentType !== null && Object.getPrototypeOf(parentType) !== Object.getPrototypeOf({})) {\n        if (parentType.type === CxEvent.type) {\n          return;\n        }\n        parentType = Object.getPrototypeOf(parentType);\n      }\n      console.warn(`The ${eventType.name} (or one of its parent classes) does not inherit from the ${CxEvent.type}`);\n    }\n    /**\n     * Returns the given event source with runtime validation whether the emitted values are instances of given event type.\n     *\n     * Should be used only in dev mode.\n     */\n    getValidatedEventStream(source$, eventType) {\n      return source$.pipe(tap(event => {\n        if (!(event instanceof eventType)) {\n          console.warn(`EventService: The stream`, source$, `emitted the event`, event, `that is not an instance of the declared type`, eventType.name);\n        }\n      }));\n    }\n  }\n  EventService.ɵfac = function EventService_Factory(t) {\n    return new (t || EventService)();\n  };\n  EventService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: EventService,\n    factory: EventService.ɵfac,\n    providedIn: 'root'\n  });\n  return EventService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Registers streams of ngrx actions as events source streams\n */\nlet StateEventService = /*#__PURE__*/(() => {\n  class StateEventService {\n    constructor(actionsSubject, eventService) {\n      this.actionsSubject = actionsSubject;\n      this.eventService = eventService;\n    }\n    /**\n     * Registers an event source stream of specific events\n     * mapped from a given action type.\n     *\n     * @param mapping mapping from action to event\n     *\n     * @returns a teardown function that unregisters the event source\n     */\n    register(mapping) {\n      return this.eventService.register(mapping.event, this.getFromAction(mapping));\n    }\n    /**\n     * Returns a stream of specific events mapped from a specific action.\n     * @param mapping mapping from action to event\n     */\n    getFromAction(mapping) {\n      return this.actionsSubject.pipe(ofType(...[].concat(mapping.action))).pipe(map(action => this.createEvent(action, mapping.event, mapping.factory)));\n    }\n    /**\n     * Creates an event instance for given class out from the action object.\n     * Unless the `factory` parameter is given, the action's `payload` is used\n     * as the argument for the event's constructor.\n     *\n     * @param action instance of an Action\n     * @param mapping mapping from action to event\n     * @param factory optional function getting an action instance and returning an event instance\n     *\n     * @returns instance of an Event\n     */\n    createEvent(action, eventType, factory) {\n      var _a;\n      return factory ? factory(action) : createFrom(eventType, (_a = action.payload) !== null && _a !== void 0 ? _a : {});\n    }\n  }\n  StateEventService.ɵfac = function StateEventService_Factory(t) {\n    return new (t || StateEventService)(i0.ɵɵinject(i1$2.ActionsSubject), i0.ɵɵinject(EventService));\n  };\n  StateEventService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateEventService,\n    factory: StateEventService.ɵfac,\n    providedIn: 'root'\n  });\n  return StateEventService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserAuthEventBuilder = /*#__PURE__*/(() => {\n  class UserAuthEventBuilder {\n    constructor(stateEventService, eventService, authService) {\n      this.stateEventService = stateEventService;\n      this.eventService = eventService;\n      this.authService = authService;\n      this.register();\n    }\n    /**\n     * Registers user auth events\n     */\n    register() {\n      this.registerLoginEvent();\n      this.registerLogoutEvent();\n    }\n    /**\n     * Register a login event\n     */\n    registerLoginEvent() {\n      this.stateEventService.register({\n        action: LOGIN,\n        event: LoginEvent\n      });\n    }\n    /**\n     * Register a logout event\n     */\n    registerLogoutEvent() {\n      this.eventService.register(LogoutEvent, this.buildLogoutEvent());\n    }\n    /**\n     * Returns logout event stream\n     */\n    buildLogoutEvent() {\n      return this.authService.isUserLoggedIn().pipe(pairwise(), filter(([prev, curr]) => prev && !curr), map(() => createFrom(LogoutEvent, {})));\n    }\n  }\n  UserAuthEventBuilder.ɵfac = function UserAuthEventBuilder_Factory(t) {\n    return new (t || UserAuthEventBuilder)(i0.ɵɵinject(StateEventService), i0.ɵɵinject(EventService), i0.ɵɵinject(AuthService));\n  };\n  UserAuthEventBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserAuthEventBuilder,\n    factory: UserAuthEventBuilder.ɵfac,\n    providedIn: 'root'\n  });\n  return UserAuthEventBuilder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserAuthEventModule = /*#__PURE__*/(() => {\n  class UserAuthEventModule {\n    constructor(_userAuthEventBuilder) {}\n  }\n  UserAuthEventModule.ɵfac = function UserAuthEventModule_Factory(t) {\n    return new (t || UserAuthEventModule)(i0.ɵɵinject(UserAuthEventBuilder));\n  };\n  UserAuthEventModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserAuthEventModule\n  });\n  UserAuthEventModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return UserAuthEventModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar GlobalMessageType = /*#__PURE__*/(() => {\n  (function (GlobalMessageType) {\n    GlobalMessageType[\"MSG_TYPE_CONFIRMATION\"] = \"[GlobalMessage] Confirmation\";\n    GlobalMessageType[\"MSG_TYPE_ERROR\"] = \"[GlobalMessage] Error\";\n    GlobalMessageType[\"MSG_TYPE_INFO\"] = \"[GlobalMessage] Information\";\n    GlobalMessageType[\"MSG_TYPE_WARNING\"] = \"[GlobalMessage] Warning\";\n  })(GlobalMessageType || (GlobalMessageType = {}));\n  return GlobalMessageType;\n})();\nfunction isNotUndefined(value) {\n  return typeof value !== 'undefined';\n}\nfunction isNotNullable(value) {\n  return isNotUndefined(value) && value !== null;\n}\nconst ADD_MESSAGE = '[Global-message] Add a Message';\nconst REMOVE_MESSAGE = '[Global-message] Remove a Message';\nconst REMOVE_MESSAGES_BY_TYPE = '[Global-message] Remove messages by type';\nclass AddMessage {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = ADD_MESSAGE;\n  }\n}\nclass RemoveMessage {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = REMOVE_MESSAGE;\n  }\n}\nclass RemoveMessagesByType {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = REMOVE_MESSAGES_BY_TYPE;\n  }\n}\nvar globalMessageGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ADD_MESSAGE: ADD_MESSAGE,\n  REMOVE_MESSAGE: REMOVE_MESSAGE,\n  REMOVE_MESSAGES_BY_TYPE: REMOVE_MESSAGES_BY_TYPE,\n  AddMessage: AddMessage,\n  RemoveMessage: RemoveMessage,\n  RemoveMessagesByType: RemoveMessagesByType\n});\nconst GLOBAL_MESSAGE_FEATURE = 'global-message';\nconst getGlobalMessageState = createFeatureSelector(GLOBAL_MESSAGE_FEATURE);\nconst getGlobalMessageEntities = createSelector(getGlobalMessageState, state => state.entities);\nconst getGlobalMessageEntitiesByType = type => {\n  return createSelector(getGlobalMessageEntities, entities => entities && entities[type]);\n};\nconst getGlobalMessageCountByType = type => {\n  return createSelector(getGlobalMessageEntitiesByType(type), entities => entities && entities.length);\n};\nvar globalMessageGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getGlobalMessageState: getGlobalMessageState,\n  getGlobalMessageEntities: getGlobalMessageEntities,\n  getGlobalMessageEntitiesByType: getGlobalMessageEntitiesByType,\n  getGlobalMessageCountByType: getGlobalMessageCountByType\n});\nlet GlobalMessageService = /*#__PURE__*/(() => {\n  class GlobalMessageService {\n    constructor(store) {\n      this.store = store;\n    }\n    /**\n     * Get all global messages\n     */\n    get() {\n      return this.store.pipe(select(getGlobalMessageEntities), filter(isNotUndefined));\n    }\n    /**\n     * Add one message into store\n     * @param text: string | Translatable\n     * @param type: GlobalMessageType object\n     * @param timeout: number\n     */\n    add(text, type, timeout) {\n      this.store.dispatch(new AddMessage({\n        text: typeof text === 'string' ? {\n          raw: text\n        } : text,\n        type,\n        timeout\n      }));\n    }\n    /**\n     * Remove message(s) from store\n     * @param type: GlobalMessageType\n     * @param index:optional. Without it, messages will be removed by type; otherwise,\n     * message will be removed from list by index.\n     */\n    remove(type, index) {\n      this.store.dispatch(index !== undefined ? new RemoveMessage({\n        type: type,\n        index: index\n      }) : new RemoveMessagesByType(type));\n    }\n  }\n  GlobalMessageService.ɵfac = function GlobalMessageService_Factory(t) {\n    return new (t || GlobalMessageService)(i0.ɵɵinject(i1$2.Store));\n  };\n  GlobalMessageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GlobalMessageService,\n    factory: GlobalMessageService.ɵfac,\n    providedIn: 'root'\n  });\n  return GlobalMessageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Extendable service for `AuthInterceptor`.\n */\nlet AuthHttpHeaderService = /*#__PURE__*/(() => {\n  class AuthHttpHeaderService {\n    constructor(authService, authStorageService, oAuthLibWrapperService, routingService, occEndpoints, globalMessageService, authRedirectService) {\n      this.authService = authService;\n      this.authStorageService = authStorageService;\n      this.oAuthLibWrapperService = oAuthLibWrapperService;\n      this.routingService = routingService;\n      this.occEndpoints = occEndpoints;\n      this.globalMessageService = globalMessageService;\n      this.authRedirectService = authRedirectService;\n      /**\n       * Indicates whether the access token is being refreshed\n       *\n       * @deprecated will be removed in the next major. Use `AuthService.refreshInProgress$` instead.\n       */\n      // TODO:#13421 - legacy, remove this flag\n      this.refreshInProgress = false;\n      /**\n       * Starts the refresh of the access token\n       */\n      this.refreshTokenTrigger$ = new Subject();\n      /**\n       * Internal token streams which reads the latest from the storage.\n       * Emits the token or `undefined`\n       */\n      this.token$ = this.authStorageService.getToken().pipe(map(token => (token === null || token === void 0 ? void 0 : token.access_token) ? token : undefined));\n      /**\n       * Compares the previous and the new token in order to stop the refresh or logout processes\n       */\n      this.stopProgress$ = this.token$.pipe(\n      // Keeps the previous and the new token\n      pairwise(), tap(([oldToken, newToken]) => {\n        // if we got the new token we know that either the refresh or logout finished\n        if ((oldToken === null || oldToken === void 0 ? void 0 : oldToken.access_token) !== (newToken === null || newToken === void 0 ? void 0 : newToken.access_token)) {\n          this.authService.setLogoutProgress(false);\n          this.authService.setRefreshProgress(false);\n        }\n      }));\n      /**\n       * Refreshes the token only if currently there's no refresh nor logout in progress.\n       * If the refresh token is not present, it triggers the logout process\n       */\n      this.refreshToken$ = this.refreshTokenTrigger$.pipe(withLatestFrom(this.authService.refreshInProgress$, this.authService.logoutInProgress$), filter(([, refreshInProgress, logoutInProgress]) => !refreshInProgress && !logoutInProgress), tap(([token]) => {\n        if (token === null || token === void 0 ? void 0 : token.refresh_token) {\n          this.oAuthLibWrapperService.refreshToken();\n          this.authService.setRefreshProgress(true);\n        } else {\n          this.handleExpiredRefreshToken();\n        }\n      }));\n      /**\n       * Kicks of the process by listening to the new token and refresh token processes.\n       * This token should be used when retrying the failed http request.\n       */\n      this.tokenToRetryRequest$ = using(() => this.refreshToken$.subscribe(), () => this.getStableToken()).pipe(shareReplay({\n        refCount: true,\n        bufferSize: 1\n      }));\n      this.subscriptions = new Subscription();\n      // We need to have stopProgress$ stream active for the whole time,\n      // so when the logout finishes we finish it's process.\n      // It could happen when retryToken$ is not active.\n      this.subscriptions.add(this.stopProgress$.subscribe());\n    }\n    /**\n     * Checks if request should be handled by this service (if it's OCC call).\n     */\n    shouldCatchError(request) {\n      return this.isOccUrl(request.url);\n    }\n    shouldAddAuthorizationHeader(request) {\n      const hasAuthorizationHeader = !!this.getAuthorizationHeader(request);\n      const isOccUrl = this.isOccUrl(request.url);\n      return !hasAuthorizationHeader && isOccUrl;\n    }\n    /**\n     * Adds `Authorization` header for OCC calls.\n     */\n    alterRequest(request, token) {\n      const hasAuthorizationHeader = !!this.getAuthorizationHeader(request);\n      const isOccUrl = this.isOccUrl(request.url);\n      if (!hasAuthorizationHeader && isOccUrl) {\n        return request.clone({\n          setHeaders: Object.assign({}, this.createAuthorizationHeader(token))\n        });\n      }\n      return request;\n    }\n    isOccUrl(url) {\n      return url.includes(this.occEndpoints.getBaseUrl());\n    }\n    getAuthorizationHeader(request) {\n      const rawValue = request.headers.get('Authorization');\n      return rawValue;\n    }\n    createAuthorizationHeader(token) {\n      if (token === null || token === void 0 ? void 0 : token.access_token) {\n        return {\n          Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`\n        };\n      }\n      let currentToken;\n      this.authStorageService.getToken().subscribe(token => currentToken = token).unsubscribe();\n      if (currentToken === null || currentToken === void 0 ? void 0 : currentToken.access_token) {\n        return {\n          Authorization: `${currentToken.token_type || 'Bearer'} ${currentToken.access_token}`\n        };\n      }\n      return {};\n    }\n    /**\n     * Refreshes access_token and then retries the call with the new token.\n     */\n    handleExpiredAccessToken(request, next,\n    // TODO:#13421 make required\n    initialToken) {\n      // TODO:#13421 remove this if-statement, and just return the stream.\n      if (initialToken) {\n        return this.getValidToken(initialToken).pipe(switchMap(token =>\n        // we break the stream with EMPTY when we don't have the token. This prevents sending the requests with `Authorization: bearer undefined` header\n        token ? next.handle(this.createNewRequestWithNewToken(request, token)) : EMPTY));\n      }\n      // TODO:#13421 legacy - remove in 5.0\n      return this.handleExpiredToken().pipe(switchMap(token => {\n        return token ? next.handle(this.createNewRequestWithNewToken(request, token)) : EMPTY;\n      }));\n    }\n    /**\n     * Logout user, redirected to login page and informs about expired session.\n     */\n    handleExpiredRefreshToken() {\n      // There might be 2 cases:\n      // 1. when user is already on some page (router is stable) and performs an UI action\n      // that triggers http call (i.e. button click to save data in backend)\n      // 2. when user is navigating to some page and a route guard triggers the http call\n      // (i.e. guard loading cms page data)\n      //\n      // In the second case, we want to remember the anticipated url before we navigate to\n      // the login page, so we can redirect back to that URL after user authenticates.\n      this.authRedirectService.saveCurrentNavigationUrl();\n      // Logout user\n      // TODO(#9638): Use logout route when it will support passing redirect url\n      this.authService.coreLogout().finally(() => {\n        this.routingService.go({\n          cxRoute: 'login'\n        });\n        this.globalMessageService.add({\n          key: 'httpHandlers.sessionExpired'\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    // TODO:#13421 - remove this method\n    /**\n     * Attempts to refresh token if possible.\n     * If it is not possible calls `handleExpiredRefreshToken`.\n     *\n     * @return observable which omits new access_token. (Warn: might never emit!).\n     *\n     * @deprecated will be removed in the next major. Use `getValidToken()` instead\n     */\n    handleExpiredToken() {\n      const stream = this.authStorageService.getToken();\n      let oldToken;\n      return stream.pipe(tap(token => {\n        if (token.access_token && token.refresh_token && !oldToken && !this.refreshInProgress) {\n          this.refreshInProgress = true;\n          this.oAuthLibWrapperService.refreshToken();\n        } else if (!token.refresh_token) {\n          this.handleExpiredRefreshToken();\n        }\n        oldToken = oldToken || token;\n      }), filter(token => oldToken.access_token !== token.access_token), tap(() => {\n        this.refreshInProgress = false;\n      }), map(token => (token === null || token === void 0 ? void 0 : token.access_token) ? token : undefined), take(1));\n    }\n    /**\n     * Emits the token or `undefined` only when the refresh or the logout processes are finished.\n     */\n    getStableToken() {\n      return combineLatest([this.token$, this.authService.refreshInProgress$, this.authService.logoutInProgress$]).pipe(observeOn(queueScheduler), filter(([_, refreshInProgress, logoutInProgress]) => !refreshInProgress && !logoutInProgress), switchMap(() => this.token$));\n    }\n    /**\n     * Returns a valid access token.\n     * It will attempt to refresh it if the current one expired; emits after the new one is retrieved.\n     */\n    getValidToken(requestToken) {\n      return defer(() => {\n        // flag to only refresh token only on first emission\n        let refreshTriggered = false;\n        return this.tokenToRetryRequest$.pipe(tap(token => {\n          // we want to refresh the access token only when it is old.\n          // this is a guard for the case when there are multiple parallel http calls\n          if ((token === null || token === void 0 ? void 0 : token.access_token) === (requestToken === null || requestToken === void 0 ? void 0 : requestToken.access_token) && !refreshTriggered) {\n            this.refreshTokenTrigger$.next(token);\n          }\n          refreshTriggered = true;\n        }), skipWhile(token => (token === null || token === void 0 ? void 0 : token.access_token) === requestToken.access_token), take(1));\n      });\n    }\n    createNewRequestWithNewToken(request, token) {\n      request = request.clone({\n        setHeaders: {\n          Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`\n        }\n      });\n      return request;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  AuthHttpHeaderService.ɵfac = function AuthHttpHeaderService_Factory(t) {\n    return new (t || AuthHttpHeaderService)(i0.ɵɵinject(AuthService), i0.ɵɵinject(AuthStorageService), i0.ɵɵinject(OAuthLibWrapperService), i0.ɵɵinject(RoutingService), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(GlobalMessageService), i0.ɵɵinject(AuthRedirectService));\n  };\n  AuthHttpHeaderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthHttpHeaderService,\n    factory: AuthHttpHeaderService.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthHttpHeaderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Responsible for catching auth errors and providing `Authorization` header for API calls.\n * Uses AuthHttpHeaderService for request manipulation and error handling. Interceptor only hooks into request send/received events.\n */\nlet AuthInterceptor = /*#__PURE__*/(() => {\n  class AuthInterceptor {\n    constructor(authHttpHeaderService, authConfigService) {\n      this.authHttpHeaderService = authHttpHeaderService;\n      this.authConfigService = authConfigService;\n    }\n    intercept(request, next) {\n      const shouldCatchError = this.authHttpHeaderService.shouldCatchError(request);\n      const shouldAddAuthorizationHeader = this.authHttpHeaderService.shouldAddAuthorizationHeader(request);\n      const token$ = shouldAddAuthorizationHeader ?\n      // emits sync, unless there is refresh or logout in progress, in which case it emits async\n      this.authHttpHeaderService.getStableToken().pipe(take(1)) : of(undefined);\n      const requestAndToken$ = token$.pipe(map(token => ({\n        token,\n        request: this.authHttpHeaderService.alterRequest(request, token)\n      })));\n      return requestAndToken$.pipe(switchMap(({\n        request,\n        token\n      }) => next.handle(request).pipe(catchError(errResponse => {\n        var _a, _b;\n        if (errResponse instanceof HttpErrorResponse) {\n          switch (errResponse.status) {\n            case 401:\n              // Unauthorized\n              if (this.isExpiredToken(errResponse) && shouldCatchError) {\n                // request failed because of the expired access token\n                // we should get refresh the token and retry the request, or logout if the refresh is missing / expired\n                return this.authHttpHeaderService.handleExpiredAccessToken(request, next, token);\n              } else if (\n              // Refresh the expired token\n              // Check if the OAuth endpoint was called and the error is because the refresh token expired\n              ((_a = errResponse.url) === null || _a === void 0 ? void 0 : _a.includes(this.authConfigService.getTokenEndpoint())) && errResponse.error.error === 'invalid_token') {\n                this.authHttpHeaderService.handleExpiredRefreshToken();\n                return of();\n              }\n              break;\n            case 400:\n              // Bad Request\n              if (((_b = errResponse.url) === null || _b === void 0 ? void 0 : _b.includes(this.authConfigService.getTokenEndpoint())) && errResponse.error.error === 'invalid_grant') {\n                if (request.body.get('grant_type') === 'refresh_token') {\n                  this.authHttpHeaderService.handleExpiredRefreshToken();\n                }\n              }\n              break;\n          }\n        }\n        return throwError(errResponse);\n      }))));\n    }\n    isExpiredToken(resp) {\n      var _a, _b, _c;\n      return ((_c = (_b = (_a = resp.error) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) === 'InvalidTokenError';\n    }\n  }\n  AuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n    return new (t || AuthInterceptor)(i0.ɵɵinject(AuthHttpHeaderService), i0.ɵɵinject(AuthConfigService));\n  };\n  AuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthInterceptor,\n    factory: AuthInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This interceptor is dedicated for Hybris OAuth server which requires `Authorization` header for revoke token calls.\n */\nlet TokenRevocationInterceptor = /*#__PURE__*/(() => {\n  class TokenRevocationInterceptor {\n    constructor(authStorageService, authConfigService) {\n      this.authStorageService = authStorageService;\n      this.authConfigService = authConfigService;\n    }\n    intercept(request, next) {\n      const isTokenRevocationRequest = this.isTokenRevocationRequest(request);\n      return this.authStorageService.getToken().pipe(take(1), switchMap(token => {\n        if (isTokenRevocationRequest) {\n          request = request.clone({\n            setHeaders: {\n              Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`\n            }\n          });\n        }\n        return next.handle(request);\n      }));\n    }\n    isTokenRevocationRequest(request) {\n      return request.url === this.authConfigService.getRevokeEndpoint();\n    }\n  }\n  TokenRevocationInterceptor.ɵfac = function TokenRevocationInterceptor_Factory(t) {\n    return new (t || TokenRevocationInterceptor)(i0.ɵɵinject(AuthStorageService), i0.ɵɵinject(AuthConfigService));\n  };\n  TokenRevocationInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TokenRevocationInterceptor,\n    factory: TokenRevocationInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return TokenRevocationInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst interceptors$1 = [{\n  provide: HTTP_INTERCEPTORS,\n  useExisting: AuthInterceptor,\n  multi: true\n}, {\n  provide: HTTP_INTERCEPTORS,\n  useExisting: TokenRevocationInterceptor,\n  multi: true\n}];\n\n/**\n * Initialize the check for `token` or `code` in the url returned from the OAuth server.\n */\nfunction checkOAuthParamsInUrl(authService, configInit) {\n  const result = () => configInit.getStable().pipe(switchMap(() =>\n  // Wait for stable config is used, because with auth redirect would kick so quickly that the page would not be loaded correctly\n  authService.checkOAuthParamsInUrl())).toPromise();\n  return result;\n}\nfunction authStatePersistenceFactory(authStatePersistenceService) {\n  const result = () => authStatePersistenceService.initSync();\n  return result;\n}\n/**\n * Authentication module for a user. Handlers requests for logged in users,\n * provides authorization services and storage for tokens.\n */\nlet UserAuthModule = /*#__PURE__*/(() => {\n  class UserAuthModule {\n    static forRoot() {\n      return {\n        ngModule: UserAuthModule,\n        providers: [provideDefaultConfig(defaultAuthConfig), provideConfigValidator(baseUrlConfigValidator), ...interceptors$1, {\n          provide: OAuthStorage,\n          useExisting: AuthStorageService\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: authStatePersistenceFactory,\n          deps: [AuthStatePersistenceService],\n          multi: true\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: checkOAuthParamsInUrl,\n          deps: [AuthService, ConfigInitializerService],\n          multi: true\n        }]\n      };\n    }\n  }\n  UserAuthModule.ɵfac = function UserAuthModule_Factory(t) {\n    return new (t || UserAuthModule)();\n  };\n  UserAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserAuthModule\n  });\n  UserAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, OAuthModule.forRoot(), UserAuthEventModule]]\n  });\n  return UserAuthModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthModule = /*#__PURE__*/(() => {\n  class AuthModule {\n    static forRoot() {\n      return {\n        ngModule: AuthModule\n      };\n    }\n  }\n  AuthModule.ɵfac = function AuthModule_Factory(t) {\n    return new (t || AuthModule)();\n  };\n  AuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AuthModule\n  });\n  AuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule, UserAuthModule.forRoot(), ClientAuthModule.forRoot()]]\n  });\n  return AuthModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Checks if there is currently logged in user.\n * Use to protect pages dedicated only for logged in users.\n */\nlet AuthGuard = /*#__PURE__*/(() => {\n  class AuthGuard {\n    constructor(authService, authRedirectService, router, semanticPathService) {\n      this.authService = authService;\n      this.authRedirectService = authRedirectService;\n      this.router = router;\n      this.semanticPathService = semanticPathService;\n    }\n    canActivate() {\n      return this.authService.isUserLoggedIn().pipe(map(isLoggedIn => {\n        if (!isLoggedIn) {\n          this.authRedirectService.saveCurrentNavigationUrl();\n          return this.router.parseUrl(this.semanticPathService.get('login'));\n        }\n        return isLoggedIn;\n      }));\n    }\n  }\n  AuthGuard.ɵfac = function AuthGuard_Factory(t) {\n    return new (t || AuthGuard)(i0.ɵɵinject(AuthService), i0.ɵɵinject(AuthRedirectService), i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(SemanticPathService));\n  };\n  AuthGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AuthGuard,\n    factory: AuthGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Checks if there isn't any logged in user.\n * Use to protect pages dedicated only for guests (eg. login page).\n */\nlet NotAuthGuard = /*#__PURE__*/(() => {\n  class NotAuthGuard {\n    constructor(authService, authRedirectService, semanticPathService, router) {\n      this.authService = authService;\n      this.authRedirectService = authRedirectService;\n      this.semanticPathService = semanticPathService;\n      this.router = router;\n    }\n    canActivate() {\n      this.authRedirectService.reportNotAuthGuard();\n      // redirect, if user is already logged in:\n      return this.authService.isUserLoggedIn().pipe(map(isLoggedIn => {\n        if (isLoggedIn) {\n          return this.router.parseUrl(this.semanticPathService.get('home'));\n        }\n        return !isLoggedIn;\n      }));\n    }\n  }\n  NotAuthGuard.ɵfac = function NotAuthGuard_Factory(t) {\n    return new (t || NotAuthGuard)(i0.ɵɵinject(AuthService), i0.ɵɵinject(AuthRedirectService), i0.ɵɵinject(SemanticPathService), i0.ɵɵinject(i1$1.Router));\n  };\n  NotAuthGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NotAuthGuard,\n    factory: NotAuthGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return NotAuthGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentsConfig = /*#__PURE__*/(() => {\n  class AnonymousConsentsConfig extends OccConfig {}\n  AnonymousConsentsConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵAnonymousConsentsConfig_BaseFactory;\n    return function AnonymousConsentsConfig_Factory(t) {\n      return (ɵAnonymousConsentsConfig_BaseFactory || (ɵAnonymousConsentsConfig_BaseFactory = i0.ɵɵgetInheritedFactory(AnonymousConsentsConfig)))(t || AnonymousConsentsConfig);\n    };\n  }();\n  AnonymousConsentsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentsConfig,\n    factory: function AnonymousConsentsConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || AnonymousConsentsConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return AnonymousConsentsConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentsInterceptor = /*#__PURE__*/(() => {\n  class AnonymousConsentsInterceptor {\n    constructor(anonymousConsentsService, authService, occEndpoints, config) {\n      this.anonymousConsentsService = anonymousConsentsService;\n      this.authService = authService;\n      this.occEndpoints = occEndpoints;\n      this.config = config;\n    }\n    intercept(request, next) {\n      return combineLatest([this.anonymousConsentsService.getConsents(), this.authService.isUserLoggedIn()]).pipe(take(1), switchMap(([consents, isUserLoggedIn]) => {\n        if (!this.isOccUrl(request.url)) {\n          return next.handle(request);\n        }\n        const clonedRequest = this.handleRequest(consents, request);\n        return next.handle(clonedRequest).pipe(tap(event => {\n          var _a;\n          if (event instanceof HttpResponse && ((_a = event.url) !== null && _a !== void 0 ? _a : '').startsWith(this.occEndpoints.buildUrl('anonymousConsentTemplates'))) {\n            this.handleResponse(isUserLoggedIn, event.headers.get(ANONYMOUS_CONSENTS_HEADER), consents);\n          }\n        }));\n      }));\n    }\n    handleResponse(isUserLoggedIn, newRawConsents, previousConsents) {\n      if (!isUserLoggedIn && newRawConsents) {\n        let newConsents = [];\n        newConsents = this.anonymousConsentsService.decodeAndDeserialize(newRawConsents);\n        newConsents = this.giveRequiredConsents(newConsents);\n        if (this.anonymousConsentsService.consentsUpdated(newConsents, previousConsents)) {\n          this.anonymousConsentsService.setConsents(newConsents);\n        }\n      }\n    }\n    handleRequest(consents, request) {\n      if (!consents) {\n        return request;\n      }\n      const rawConsents = this.anonymousConsentsService.serializeAndEncode(consents);\n      return request.clone({\n        setHeaders: {\n          [ANONYMOUS_CONSENTS_HEADER]: rawConsents\n        }\n      });\n    }\n    isOccUrl(url) {\n      return url.includes(this.occEndpoints.getBaseUrl());\n    }\n    giveRequiredConsents(consents) {\n      const givenConsents = [...consents];\n      if (Boolean(this.config.anonymousConsents) && Boolean(this.config.anonymousConsents.requiredConsents)) {\n        for (const consent of givenConsents) {\n          if (this.config.anonymousConsents.requiredConsents.includes(consent.templateCode)) {\n            consent.consentState = ANONYMOUS_CONSENT_STATUS.GIVEN;\n          }\n        }\n      }\n      return givenConsents;\n    }\n  }\n  AnonymousConsentsInterceptor.ɵfac = function AnonymousConsentsInterceptor_Factory(t) {\n    return new (t || AnonymousConsentsInterceptor)(i0.ɵɵinject(AnonymousConsentsService), i0.ɵɵinject(AuthService), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(AnonymousConsentsConfig));\n  };\n  AnonymousConsentsInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentsInterceptor,\n    factory: AnonymousConsentsInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return AnonymousConsentsInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst interceptors = [{\n  provide: HTTP_INTERCEPTORS,\n  useExisting: AnonymousConsentsInterceptor,\n  multi: true\n}];\nconst LOAD_BILLING_COUNTRIES = '[User] Load Billing Countries';\nconst LOAD_BILLING_COUNTRIES_FAIL = '[User] Load Billing Countries Fail';\nconst LOAD_BILLING_COUNTRIES_SUCCESS = '[User] Load Billing Countries Success';\nclass LoadBillingCountries {\n  constructor() {\n    this.type = LOAD_BILLING_COUNTRIES;\n  }\n}\nclass LoadBillingCountriesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BILLING_COUNTRIES_FAIL;\n  }\n}\nclass LoadBillingCountriesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_BILLING_COUNTRIES_SUCCESS;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_CONSIGNMENT_TRACKING = '[User] Load Consignment Tracking';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_CONSIGNMENT_TRACKING_FAIL = '[User] Load Consignment Tracking Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_CONSIGNMENT_TRACKING_SUCCESS = '[User] Load Consignment Tracking Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_CONSIGNMENT_TRACKING = '[User] Clear Consignment Tracking';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadConsignmentTracking {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_CONSIGNMENT_TRACKING;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadConsignmentTrackingFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_CONSIGNMENT_TRACKING_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadConsignmentTrackingSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_CONSIGNMENT_TRACKING_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearConsignmentTracking {\n  constructor() {\n    this.type = CLEAR_CONSIGNMENT_TRACKING;\n  }\n}\nconst USER_FEATURE = 'user';\nconst REGISTER_USER_PROCESS_ID = 'registerUser';\nconst GIVE_CONSENT_PROCESS_ID = 'giveConsent';\nconst WITHDRAW_CONSENT_PROCESS_ID = 'withdrawConsent';\nconst UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID = 'updateNotificationPreferences';\nconst ADD_PRODUCT_INTEREST_PROCESS_ID = 'addProductInterests';\nconst REMOVE_PRODUCT_INTERESTS_PROCESS_ID = 'removeProductInterests';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_PROCESS_ID = 'cancelOrder';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_RETURN_PROCESS_ID = 'cancelReturn';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_REPLENISHMENT_ORDER_PROCESS_ID = 'cancelReplenishmentOrder';\nconst USER_CONSENTS = '[User] User Consents';\nconst USER_PAYMENT_METHODS = '[User] User Payment Methods';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_ORDERS = '[User] User Orders';\nconst USER_ADDRESSES = '[User] User Addresses';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_RETURN_REQUESTS = '[User] Order Return Requests';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_RETURN_REQUEST_DETAILS = '[User] Return Request Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_ORDER_DETAILS = '[User] User Order Details';\nconst USER_COST_CENTERS = '[User] User Cost Centers';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_REPLENISHMENT_ORDERS = '[User] User Replenishment Orders';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst USER_REPLENISHMENT_ORDER_DETAILS = '[User] User Replenishment Order Details';\nconst REGIONS = '[User] Regions';\nconst CUSTOMER_COUPONS = '[User] Customer Coupons';\nconst SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'subscribeCustomerCoupon';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID = 'unsubscribeCustomerCoupon';\nconst CLAIM_CUSTOMER_COUPON_PROCESS_ID = 'claimCustomerCoupon';\nconst NOTIFICATION_PREFERENCES = '[User] Notification Preferences';\nconst PRODUCT_INTERESTS = '[User] Product Interests';\nconst PROCESS_FEATURE = 'process';\nfunction getProcessState() {\n  return createFeatureSelector(PROCESS_FEATURE);\n}\nfunction getProcessStateFactory(processId) {\n  return createSelector(getProcessState(), entityState => entityLoaderStateSelector(entityState, processId));\n}\nfunction getProcessLoadingFactory(processId) {\n  return createSelector(getProcessStateFactory(processId), loaderState => loaderLoadingSelector(loaderState));\n}\nfunction getProcessSuccessFactory(processId) {\n  return createSelector(getProcessStateFactory(processId), loaderState => loaderSuccessSelector(loaderState));\n}\nfunction getProcessErrorFactory(processId) {\n  return createSelector(getProcessStateFactory(processId), loaderState => loaderErrorSelector(loaderState));\n}\nvar process_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getProcessStateFactory: getProcessStateFactory,\n  getProcessLoadingFactory: getProcessLoadingFactory,\n  getProcessSuccessFactory: getProcessSuccessFactory,\n  getProcessErrorFactory: getProcessErrorFactory\n});\nconst LOAD_CUSTOMER_COUPONS = '[User] Load Customer Coupons';\nconst LOAD_CUSTOMER_COUPONS_FAIL = '[User] Load Customer Coupons Fail';\nconst LOAD_CUSTOMER_COUPONS_SUCCESS = '[User] Load Customer Coupons Success';\nconst RESET_LOAD_CUSTOMER_COUPONS = '[User] Reset Load Customer Coupons';\nconst SUBSCRIBE_CUSTOMER_COUPON = '[User] Subscribe Customer Notification Coupon';\nconst SUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Subscribe Customer Coupon Notification Fail';\nconst SUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Subscribe Customer Coupon Notification Success';\nconst RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Subscribe Customer Coupon Process';\nconst UNSUBSCRIBE_CUSTOMER_COUPON = '[User] Unsubscribe Customer Notification Coupon';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_FAIL = '[User] Unsubscribe Customer Coupon Notification Fail';\nconst UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS = '[User] Unsubscribe Customer Coupon Notification Success';\nconst RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS = '[User] Reset Unsubscribe Customer Coupon Process';\nconst CLAIM_CUSTOMER_COUPON = '[User] Claim Customer';\nconst CLAIM_CUSTOMER_COUPON_FAIL = '[User] Claim Customer Fail';\nconst CLAIM_CUSTOMER_COUPON_SUCCESS = '[User] Claim Customer Success';\nclass LoadCustomerCoupons extends LoaderLoadAction {\n  constructor(payload) {\n    super(CUSTOMER_COUPONS);\n    this.payload = payload;\n    this.type = LOAD_CUSTOMER_COUPONS;\n  }\n}\nclass LoadCustomerCouponsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(CUSTOMER_COUPONS, payload);\n    this.payload = payload;\n    this.type = LOAD_CUSTOMER_COUPONS_FAIL;\n  }\n}\nclass LoadCustomerCouponsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(CUSTOMER_COUPONS);\n    this.payload = payload;\n    this.type = LOAD_CUSTOMER_COUPONS_SUCCESS;\n  }\n}\nclass ResetLoadCustomerCoupons extends LoaderResetAction {\n  constructor() {\n    super(CUSTOMER_COUPONS);\n    this.type = RESET_LOAD_CUSTOMER_COUPONS;\n  }\n}\n// Subscribe coupon notification actions\nclass SubscribeCustomerCoupon extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n    this.payload = payload;\n    this.type = SUBSCRIBE_CUSTOMER_COUPON;\n  }\n}\nclass SubscribeCustomerCouponFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = SUBSCRIBE_CUSTOMER_COUPON_FAIL;\n  }\n}\nclass SubscribeCustomerCouponSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = SUBSCRIBE_CUSTOMER_COUPON_SUCCESS;\n  }\n}\nclass ResetSubscribeCustomerCouponProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n    this.type = RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS;\n  }\n}\nclass UnsubscribeCustomerCoupon extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n    this.payload = payload;\n    this.type = UNSUBSCRIBE_CUSTOMER_COUPON;\n  }\n}\nclass UnsubscribeCustomerCouponFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = UNSUBSCRIBE_CUSTOMER_COUPON_FAIL;\n  }\n}\nclass UnsubscribeCustomerCouponSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS;\n  }\n}\nclass ResetUnsubscribeCustomerCouponProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID);\n    this.type = RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS;\n  }\n}\nclass ClaimCustomerCoupon extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID);\n    this.payload = payload;\n    this.type = CLAIM_CUSTOMER_COUPON;\n  }\n}\nclass ClaimCustomerCouponFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = CLAIM_CUSTOMER_COUPON_FAIL;\n  }\n}\nclass ClaimCustomerCouponSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CLAIM_CUSTOMER_COUPON_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = CLAIM_CUSTOMER_COUPON_SUCCESS;\n  }\n}\nconst LOAD_DELIVERY_COUNTRIES = '[User] Load Delivery Countries';\nconst LOAD_DELIVERY_COUNTRIES_FAIL = '[User] Load Delivery Countries Fail';\nconst LOAD_DELIVERY_COUNTRIES_SUCCESS = '[User] Load Delivery Countries Success';\nclass LoadDeliveryCountries {\n  constructor() {\n    this.type = LOAD_DELIVERY_COUNTRIES;\n  }\n}\nclass LoadDeliveryCountriesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_DELIVERY_COUNTRIES_FAIL;\n  }\n}\nclass LoadDeliveryCountriesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_DELIVERY_COUNTRIES_SUCCESS;\n  }\n}\nconst LOAD_NOTIFICATION_PREFERENCES = '[User] Load Notification Preferences';\nconst LOAD_NOTIFICATION_PREFERENCES_FAIL = '[User] Load Notification Preferences Fail';\nconst LOAD_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Load Notification Preferences Success';\nconst UPDATE_NOTIFICATION_PREFERENCES = '[User] Update Notification Preferences';\nconst UPDATE_NOTIFICATION_PREFERENCES_FAIL = '[User] Update Notification Preferences Fail';\nconst UPDATE_NOTIFICATION_PREFERENCES_SUCCESS = '[User] Update Notification Preferences Success';\nconst RESET_NOTIFICATION_PREFERENCES = '[User] Reset Notification Preferences';\nconst CLEAR_NOTIFICATION_PREFERENCES = '[User] Clear Notification Preferences';\nclass LoadNotificationPreferences extends LoaderLoadAction {\n  constructor(payload) {\n    super(NOTIFICATION_PREFERENCES);\n    this.payload = payload;\n    this.type = LOAD_NOTIFICATION_PREFERENCES;\n  }\n}\nclass LoadNotificationPreferencesFail extends LoaderFailAction {\n  constructor(payload) {\n    super(NOTIFICATION_PREFERENCES, payload);\n    this.payload = payload;\n    this.type = LOAD_NOTIFICATION_PREFERENCES_FAIL;\n  }\n}\nclass LoadNotificationPreferencesSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(NOTIFICATION_PREFERENCES);\n    this.payload = payload;\n    this.type = LOAD_NOTIFICATION_PREFERENCES_SUCCESS;\n  }\n}\nclass UpdateNotificationPreferences extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n    this.payload = payload;\n    this.type = UPDATE_NOTIFICATION_PREFERENCES;\n  }\n}\nclass UpdateNotificationPreferencesFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = UPDATE_NOTIFICATION_PREFERENCES_FAIL;\n  }\n}\nclass UpdateNotificationPreferencesSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n    this.payload = payload;\n    this.type = UPDATE_NOTIFICATION_PREFERENCES_SUCCESS;\n  }\n}\nclass ResetNotificationPreferences extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID);\n    this.type = RESET_NOTIFICATION_PREFERENCES;\n  }\n}\nclass ClearNotificationPreferences extends LoaderResetAction {\n  constructor() {\n    super(NOTIFICATION_PREFERENCES);\n    this.type = CLEAR_NOTIFICATION_PREFERENCES;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_DETAILS = '[User] Load Order Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_DETAILS_FAIL = '[User] Load Order Details Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_DETAILS_SUCCESS = '[User] Load Order Details Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_ORDER_DETAILS = '[User] Clear Order Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER = '[User] Cancel Order';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_FAIL = '[User] Cancel Order Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_SUCCESS = '[User] Cancel Order Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst RESET_CANCEL_ORDER_PROCESS = '[User] Reset Cancel Order Process';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderDetails extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ORDER_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_DETAILS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderDetailsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ORDER_DETAILS, payload);\n    this.payload = payload;\n    this.type = LOAD_ORDER_DETAILS_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderDetailsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ORDER_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_DETAILS_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearOrderDetails extends LoaderResetAction {\n  constructor() {\n    super(USER_ORDER_DETAILS);\n    this.type = CLEAR_ORDER_DETAILS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrder extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n    this.payload = payload;\n    this.type = CANCEL_ORDER;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrderFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = CANCEL_ORDER_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrderSuccess extends EntitySuccessAction {\n  constructor() {\n    super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n    this.type = CANCEL_ORDER_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ResetCancelOrderProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, CANCEL_ORDER_PROCESS_ID);\n    this.type = RESET_CANCEL_ORDER_PROCESS;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CREATE_ORDER_RETURN_REQUEST = '[User] Create Order Return Request';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CREATE_ORDER_RETURN_REQUEST_FAIL = '[User] Create Order Return Request Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CREATE_ORDER_RETURN_REQUEST_SUCCESS = '[User] Create Order Return Request Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST = '[User] Load Order Return Request details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST_FAIL = '[User] Load Order Return Request details Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST_SUCCESS = '[User] Load Order Return Request details Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_RETURN_REQUEST = '[User] Cancel Order Return Request';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_RETURN_REQUEST_FAIL = '[User] Cancel Order Return Request Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_ORDER_RETURN_REQUEST_SUCCESS = '[User] Cancel Order Return Request Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST_LIST = '[User] Load User Order Return Request List';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST_LIST_FAIL = '[User] Load User Order Return Request List Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS = '[User] Load User Order Return Request List Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_ORDER_RETURN_REQUEST = '[User] Clear Order Return Request Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_ORDER_RETURN_REQUEST_LIST = '[User] Clear Order Return Request List';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst RESET_CANCEL_RETURN_PROCESS = '[User] Reset Cancel Return Request Process';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CreateOrderReturnRequest extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS);\n    this.payload = payload;\n    this.type = CREATE_ORDER_RETURN_REQUEST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CreateOrderReturnRequestFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS, payload);\n    this.payload = payload;\n    this.type = CREATE_ORDER_RETURN_REQUEST_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CreateOrderReturnRequestSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS);\n    this.payload = payload;\n    this.type = CREATE_ORDER_RETURN_REQUEST_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequest extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequestFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS, payload);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequestSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUEST_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrderReturnRequest extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n    this.payload = payload;\n    this.type = CANCEL_ORDER_RETURN_REQUEST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrderReturnRequestFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = CANCEL_ORDER_RETURN_REQUEST_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelOrderReturnRequestSuccess extends EntitySuccessAction {\n  constructor() {\n    super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n    this.type = CANCEL_ORDER_RETURN_REQUEST_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequestList extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUESTS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST_LIST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequestListFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUESTS, payload);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST_LIST_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadOrderReturnRequestListSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_RETURN_REQUESTS);\n    this.payload = payload;\n    this.type = LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearOrderReturnRequest extends LoaderResetAction {\n  constructor() {\n    super(USER_RETURN_REQUEST_DETAILS);\n    this.type = CLEAR_ORDER_RETURN_REQUEST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearOrderReturnRequestList extends LoaderResetAction {\n  constructor() {\n    super(USER_RETURN_REQUESTS);\n    this.type = CLEAR_ORDER_RETURN_REQUEST_LIST;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ResetCancelReturnProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, CANCEL_RETURN_PROCESS_ID);\n    this.type = RESET_CANCEL_RETURN_PROCESS;\n  }\n}\nconst LOAD_USER_PAYMENT_METHODS = '[User] Load User Payment Methods';\nconst LOAD_USER_PAYMENT_METHODS_FAIL = '[User] Load User Payment Methods Fail';\nconst LOAD_USER_PAYMENT_METHODS_SUCCESS = '[User] Load User Payment Methods Success';\nconst SET_DEFAULT_USER_PAYMENT_METHOD = '[User] Set Default User Payment Method';\nconst SET_DEFAULT_USER_PAYMENT_METHOD_FAIL = '[User] Set Default User Payment Method Fail';\nconst SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS = '[User] Set Default User Payment Method Success';\nconst DELETE_USER_PAYMENT_METHOD = '[User] Delete User Payment Method';\nconst DELETE_USER_PAYMENT_METHOD_FAIL = '[User] Delete User Payment Method Fail';\nconst DELETE_USER_PAYMENT_METHOD_SUCCESS = '[User] Delete User  Payment Method Success';\nclass LoadUserPaymentMethods extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = LOAD_USER_PAYMENT_METHODS;\n  }\n}\nclass LoadUserPaymentMethodsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS, payload);\n    this.payload = payload;\n    this.type = LOAD_USER_PAYMENT_METHODS_FAIL;\n  }\n}\nclass LoadUserPaymentMethodsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = LOAD_USER_PAYMENT_METHODS_SUCCESS;\n  }\n}\nclass SetDefaultUserPaymentMethod extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = SET_DEFAULT_USER_PAYMENT_METHOD;\n  }\n}\nclass SetDefaultUserPaymentMethodFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS, payload);\n    this.payload = payload;\n    this.type = SET_DEFAULT_USER_PAYMENT_METHOD_FAIL;\n  }\n}\nclass SetDefaultUserPaymentMethodSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS;\n  }\n}\nclass DeleteUserPaymentMethod extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = DELETE_USER_PAYMENT_METHOD;\n  }\n}\nclass DeleteUserPaymentMethodFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS, payload);\n    this.payload = payload;\n    this.type = DELETE_USER_PAYMENT_METHOD_FAIL;\n  }\n}\nclass DeleteUserPaymentMethodSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_PAYMENT_METHODS);\n    this.payload = payload;\n    this.type = DELETE_USER_PAYMENT_METHOD_SUCCESS;\n  }\n}\nconst LOAD_PRODUCT_INTERESTS = 'Load Product Interests';\nconst LOAD_PRODUCT_INTERESTS_FAIL = 'Load Product Interests Fail';\nconst LOAD_PRODUCT_INTERESTS_SUCCESS = 'Load Product Interests Success';\nconst REMOVE_PRODUCT_INTEREST = 'Remove Product Interest';\nconst REMOVE_PRODUCT_INTEREST_SUCCESS = 'Remove Product Interest Success';\nconst REMOVE_PRODUCT_INTEREST_FAIL = 'Remove Product Interest Fail';\nconst ADD_PRODUCT_INTEREST = 'Add Product Interest';\nconst ADD_PRODUCT_INTEREST_FAIL = 'Add Product Interest Fail';\nconst ADD_PRODUCT_INTEREST_SUCCESS = 'Add Product Interest Success';\nconst ADD_PRODUCT_INTEREST_RESET = 'Add Product Interest Reset';\nconst REMOVE_PRODUCT_INTEREST_RESET = 'Remove Product Interest Reset';\nconst CLEAR_PRODUCT_INTERESTS = 'Clear Product Interests';\nclass LoadProductInterests extends LoaderLoadAction {\n  constructor(payload) {\n    super(PRODUCT_INTERESTS);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_INTERESTS;\n  }\n}\nclass LoadProductInterestsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(PRODUCT_INTERESTS, payload);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_INTERESTS_FAIL;\n  }\n}\nclass LoadProductInterestsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(PRODUCT_INTERESTS);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_INTERESTS_SUCCESS;\n  }\n}\nclass RemoveProductInterest extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n    this.payload = payload;\n    this.type = REMOVE_PRODUCT_INTEREST;\n  }\n}\nclass RemoveProductInterestSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n    this.payload = payload;\n    this.type = REMOVE_PRODUCT_INTEREST_SUCCESS;\n  }\n}\nclass RemoveProductInterestFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = REMOVE_PRODUCT_INTEREST_FAIL;\n  }\n}\nclass AddProductInterest extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n    this.payload = payload;\n    this.type = ADD_PRODUCT_INTEREST;\n  }\n}\nclass AddProductInterestSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n    this.payload = payload;\n    this.type = ADD_PRODUCT_INTEREST_SUCCESS;\n  }\n}\nclass AddProductInterestFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = ADD_PRODUCT_INTEREST_FAIL;\n  }\n}\nclass ResetAddInterestState extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, ADD_PRODUCT_INTEREST_PROCESS_ID);\n    this.type = ADD_PRODUCT_INTEREST_RESET;\n  }\n}\nclass ResetRemoveInterestState extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, REMOVE_PRODUCT_INTERESTS_PROCESS_ID);\n    this.type = REMOVE_PRODUCT_INTEREST_RESET;\n  }\n}\nclass ClearProductInterests extends LoaderResetAction {\n  constructor() {\n    super(PRODUCT_INTERESTS);\n    this.type = CLEAR_PRODUCT_INTERESTS;\n  }\n}\nconst LOAD_REGIONS = '[User] Load Regions';\nconst LOAD_REGIONS_SUCCESS = '[User] Load Regions Success';\nconst LOAD_REGIONS_FAIL = '[User] Load Regions Fail';\nconst CLEAR_REGIONS = '[User] Clear Regions';\nclass LoadRegions extends LoaderLoadAction {\n  constructor(payload) {\n    super(REGIONS);\n    this.payload = payload;\n    this.type = LOAD_REGIONS;\n  }\n}\nclass LoadRegionsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(REGIONS, payload);\n    this.payload = payload;\n    this.type = LOAD_REGIONS_FAIL;\n  }\n}\nclass LoadRegionsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(REGIONS);\n    this.payload = payload;\n    this.type = LOAD_REGIONS_SUCCESS;\n  }\n}\nclass ClearRegions {\n  constructor() {\n    this.type = CLEAR_REGIONS;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_REPLENISHMENT_ORDER_DETAILS = '[User] Load Replenishment Order Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS = '[User] Load Replenishment Order Details Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL = '[User] Load Replenishment Order Details Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst ClEAR_REPLENISHMENT_ORDER_DETAILS = '[User] Clear Replenishment Order Details';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_REPLENISHMENT_ORDER = '[User] Cancel Replenishment Order';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_REPLENISHMENT_ORDER_SUCCESS = '[User] Cancel Replenishment Order Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CANCEL_REPLENISHMENT_ORDER_FAIL = '[User] Cancel Replenishment Order Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_CANCEL_REPLENISHMENT_ORDER = '[User] Clear Cancel Replenishment Order';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadReplenishmentOrderDetails extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDER_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_REPLENISHMENT_ORDER_DETAILS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadReplenishmentOrderDetailsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDER_DETAILS);\n    this.payload = payload;\n    this.type = LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadReplenishmentOrderDetailsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDER_DETAILS, payload);\n    this.payload = payload;\n    this.type = LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearReplenishmentOrderDetails extends LoaderResetAction {\n  constructor() {\n    super(USER_REPLENISHMENT_ORDER_DETAILS);\n    this.type = ClEAR_REPLENISHMENT_ORDER_DETAILS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelReplenishmentOrder extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID);\n    this.payload = payload;\n    this.type = CANCEL_REPLENISHMENT_ORDER;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelReplenishmentOrderSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID);\n    this.payload = payload;\n    this.type = CANCEL_REPLENISHMENT_ORDER_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass CancelReplenishmentOrderFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID, payload);\n    this.payload = payload;\n    this.type = CANCEL_REPLENISHMENT_ORDER_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearCancelReplenishmentOrder extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID);\n    this.type = CLEAR_CANCEL_REPLENISHMENT_ORDER;\n  }\n}\nconst LOAD_USER_ADDRESSES = '[User] Load User Addresses';\nconst LOAD_USER_ADDRESSES_FAIL = '[User] Load User Addresses Fail';\nconst LOAD_USER_ADDRESSES_SUCCESS = '[User] Load User Addresses Success';\nconst ADD_USER_ADDRESS = '[User] Add User Address';\nconst ADD_USER_ADDRESS_FAIL = '[User] Add User Address Fail';\nconst ADD_USER_ADDRESS_SUCCESS = '[User] Add User Address Success';\nconst UPDATE_USER_ADDRESS = '[User] Update User Address';\nconst UPDATE_USER_ADDRESS_FAIL = '[User] Update User Address Fail';\nconst UPDATE_USER_ADDRESS_SUCCESS = '[User] Update User Address Success';\nconst DELETE_USER_ADDRESS = '[User] Delete User Address';\nconst DELETE_USER_ADDRESS_FAIL = '[User] Delete User Address Fail';\nconst DELETE_USER_ADDRESS_SUCCESS = '[User] Delete User Address Success';\nclass LoadUserAddresses extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = LOAD_USER_ADDRESSES;\n  }\n}\nclass LoadUserAddressesFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ADDRESSES, payload);\n    this.payload = payload;\n    this.type = LOAD_USER_ADDRESSES_FAIL;\n  }\n}\nclass LoadUserAddressesSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = LOAD_USER_ADDRESSES_SUCCESS;\n  }\n}\n// Adding address actions\nclass AddUserAddress extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = ADD_USER_ADDRESS;\n  }\n}\nclass AddUserAddressFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ADDRESSES, payload);\n    this.payload = payload;\n    this.type = ADD_USER_ADDRESS_FAIL;\n  }\n}\nclass AddUserAddressSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = ADD_USER_ADDRESS_SUCCESS;\n  }\n}\n// Updating address actions\nclass UpdateUserAddress extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = UPDATE_USER_ADDRESS;\n  }\n}\nclass UpdateUserAddressFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ADDRESSES, payload);\n    this.payload = payload;\n    this.type = UPDATE_USER_ADDRESS_FAIL;\n  }\n}\nclass UpdateUserAddressSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = UPDATE_USER_ADDRESS_SUCCESS;\n  }\n}\n// Deleting address actions\nclass DeleteUserAddress extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = DELETE_USER_ADDRESS;\n  }\n}\nclass DeleteUserAddressFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ADDRESSES, payload);\n    this.payload = payload;\n    this.type = DELETE_USER_ADDRESS_FAIL;\n  }\n}\nclass DeleteUserAddressSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ADDRESSES);\n    this.payload = payload;\n    this.type = DELETE_USER_ADDRESS_SUCCESS;\n  }\n}\nconst LOAD_USER_CONSENTS = '[User] Load User Consents';\nconst LOAD_USER_CONSENTS_SUCCESS = '[User] Load User Consents Success';\nconst LOAD_USER_CONSENTS_FAIL = '[User] Load User Consents Fail';\nconst RESET_LOAD_USER_CONSENTS = '[User] Reset Load User Consents';\nconst GIVE_USER_CONSENT = '[User] Give User Consent';\nconst GIVE_USER_CONSENT_FAIL = '[User] Give User Consent Fail';\nconst GIVE_USER_CONSENT_SUCCESS = '[User] Give User Consent Success';\nconst RESET_GIVE_USER_CONSENT_PROCESS = '[User] Reset Give User Consent Process';\nconst TRANSFER_ANONYMOUS_CONSENT = '[User] Transfer Anonymous Consent';\nconst WITHDRAW_USER_CONSENT = '[User] Withdraw User Consent';\nconst WITHDRAW_USER_CONSENT_FAIL = '[User] Withdraw User Consent Fail';\nconst WITHDRAW_USER_CONSENT_SUCCESS = '[User] Withdraw User Consent Success';\nconst RESET_WITHDRAW_USER_CONSENT_PROCESS = '[User] Reset Withdraw User Consent Process';\nclass LoadUserConsents extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_CONSENTS);\n    this.payload = payload;\n    this.type = LOAD_USER_CONSENTS;\n  }\n}\nclass LoadUserConsentsFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_CONSENTS, payload);\n    this.payload = payload;\n    this.type = LOAD_USER_CONSENTS_FAIL;\n  }\n}\nclass LoadUserConsentsSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_CONSENTS);\n    this.payload = payload;\n    this.type = LOAD_USER_CONSENTS_SUCCESS;\n  }\n}\nclass ResetLoadUserConsents extends LoaderResetAction {\n  constructor() {\n    super(USER_CONSENTS);\n    this.type = RESET_LOAD_USER_CONSENTS;\n  }\n}\nclass GiveUserConsent extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n    this.payload = payload;\n    this.type = GIVE_USER_CONSENT;\n  }\n}\nclass GiveUserConsentFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID, payload);\n    this.type = GIVE_USER_CONSENT_FAIL;\n  }\n}\nclass GiveUserConsentSuccess extends EntitySuccessAction {\n  constructor(consentTemplate) {\n    super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n    this.consentTemplate = consentTemplate;\n    this.type = GIVE_USER_CONSENT_SUCCESS;\n  }\n}\nclass ResetGiveUserConsentProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, GIVE_CONSENT_PROCESS_ID);\n    this.type = RESET_GIVE_USER_CONSENT_PROCESS;\n  }\n}\nclass TransferAnonymousConsent {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = TRANSFER_ANONYMOUS_CONSENT;\n  }\n}\nclass WithdrawUserConsent extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n    this.payload = payload;\n    this.type = WITHDRAW_USER_CONSENT;\n  }\n}\nclass WithdrawUserConsentFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID, payload);\n    this.type = WITHDRAW_USER_CONSENT_FAIL;\n  }\n}\nclass WithdrawUserConsentSuccess extends EntitySuccessAction {\n  constructor() {\n    super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n    this.type = WITHDRAW_USER_CONSENT_SUCCESS;\n  }\n}\nclass ResetWithdrawUserConsentProcess extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, WITHDRAW_CONSENT_PROCESS_ID);\n    this.type = RESET_WITHDRAW_USER_CONSENT_PROCESS;\n  }\n}\nconst LOAD_ACTIVE_COST_CENTERS = '[User] Load Active CostCenters';\nconst LOAD_ACTIVE_COST_CENTERS_FAIL = '[User] Load Active CostCenters Fail';\nconst LOAD_ACTIVE_COST_CENTERS_SUCCESS = '[User] Load Active CostCenters Success';\nclass LoadActiveCostCenters extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_COST_CENTERS);\n    this.payload = payload;\n    this.type = LOAD_ACTIVE_COST_CENTERS;\n  }\n}\nclass LoadActiveCostCentersFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_COST_CENTERS, payload);\n    this.payload = payload;\n    this.type = LOAD_ACTIVE_COST_CENTERS_FAIL;\n  }\n}\nclass LoadActiveCostCentersSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_COST_CENTERS);\n    this.payload = payload;\n    this.type = LOAD_ACTIVE_COST_CENTERS_SUCCESS;\n  }\n}\nconst CLEAR_USER_MISCS_DATA = '[User] Clear User Misc Data';\nclass ClearUserMiscsData {\n  constructor() {\n    this.type = CLEAR_USER_MISCS_DATA;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_ORDERS = '[User] Load User Orders';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_ORDERS_FAIL = '[User] Load User Orders Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_ORDERS_SUCCESS = '[User] Load User Orders Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_USER_ORDERS = '[User] Clear User Orders';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserOrders extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_ORDERS);\n    this.payload = payload;\n    this.type = LOAD_USER_ORDERS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserOrdersFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_ORDERS, payload);\n    this.payload = payload;\n    this.type = LOAD_USER_ORDERS_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserOrdersSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_ORDERS);\n    this.payload = payload;\n    this.type = LOAD_USER_ORDERS_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearUserOrders extends LoaderResetAction {\n  constructor() {\n    super(USER_ORDERS);\n    this.type = CLEAR_USER_ORDERS;\n  }\n}\nconst REGISTER_USER_SUCCESS = '[User] Register User Success';\n/**\n * @deprecated since 3.2, moved to `@spartacus/user/profile/core`\n */\nclass RegisterUserSuccess extends EntitySuccessAction {\n  constructor() {\n    super(PROCESS_FEATURE, REGISTER_USER_PROCESS_ID);\n    this.type = REGISTER_USER_SUCCESS;\n  }\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_REPLENISHMENT_ORDERS = '[User] Load User Replenishment Orders';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_REPLENISHMENT_ORDERS_FAIL = '[User] Load User Replenishment Orders Fail';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS = '[User] Load User Replenishment Orders Success';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CLEAR_USER_REPLENISHMENT_ORDERS = '[User] Clear User Replenishment Orders';\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserReplenishmentOrders extends LoaderLoadAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDERS);\n    this.payload = payload;\n    this.type = LOAD_USER_REPLENISHMENT_ORDERS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserReplenishmentOrdersFail extends LoaderFailAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDERS, payload);\n    this.payload = payload;\n    this.type = LOAD_USER_REPLENISHMENT_ORDERS_FAIL;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass LoadUserReplenishmentOrdersSuccess extends LoaderSuccessAction {\n  constructor(payload) {\n    super(USER_REPLENISHMENT_ORDERS);\n    this.payload = payload;\n    this.type = LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS;\n  }\n}\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nclass ClearUserReplenishmentOrders extends LoaderResetAction {\n  constructor() {\n    super(USER_REPLENISHMENT_ORDERS);\n    this.type = CLEAR_USER_REPLENISHMENT_ORDERS;\n  }\n}\nvar userGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_BILLING_COUNTRIES: LOAD_BILLING_COUNTRIES,\n  LOAD_BILLING_COUNTRIES_FAIL: LOAD_BILLING_COUNTRIES_FAIL,\n  LOAD_BILLING_COUNTRIES_SUCCESS: LOAD_BILLING_COUNTRIES_SUCCESS,\n  LoadBillingCountries: LoadBillingCountries,\n  LoadBillingCountriesFail: LoadBillingCountriesFail,\n  LoadBillingCountriesSuccess: LoadBillingCountriesSuccess,\n  LOAD_CONSIGNMENT_TRACKING: LOAD_CONSIGNMENT_TRACKING,\n  LOAD_CONSIGNMENT_TRACKING_FAIL: LOAD_CONSIGNMENT_TRACKING_FAIL,\n  LOAD_CONSIGNMENT_TRACKING_SUCCESS: LOAD_CONSIGNMENT_TRACKING_SUCCESS,\n  CLEAR_CONSIGNMENT_TRACKING: CLEAR_CONSIGNMENT_TRACKING,\n  LoadConsignmentTracking: LoadConsignmentTracking,\n  LoadConsignmentTrackingFail: LoadConsignmentTrackingFail,\n  LoadConsignmentTrackingSuccess: LoadConsignmentTrackingSuccess,\n  ClearConsignmentTracking: ClearConsignmentTracking,\n  LOAD_CUSTOMER_COUPONS: LOAD_CUSTOMER_COUPONS,\n  LOAD_CUSTOMER_COUPONS_FAIL: LOAD_CUSTOMER_COUPONS_FAIL,\n  LOAD_CUSTOMER_COUPONS_SUCCESS: LOAD_CUSTOMER_COUPONS_SUCCESS,\n  RESET_LOAD_CUSTOMER_COUPONS: RESET_LOAD_CUSTOMER_COUPONS,\n  SUBSCRIBE_CUSTOMER_COUPON: SUBSCRIBE_CUSTOMER_COUPON,\n  SUBSCRIBE_CUSTOMER_COUPON_FAIL: SUBSCRIBE_CUSTOMER_COUPON_FAIL,\n  SUBSCRIBE_CUSTOMER_COUPON_SUCCESS: SUBSCRIBE_CUSTOMER_COUPON_SUCCESS,\n  RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_SUBSCRIBE_CUSTOMER_COUPON_PROCESS,\n  UNSUBSCRIBE_CUSTOMER_COUPON: UNSUBSCRIBE_CUSTOMER_COUPON,\n  UNSUBSCRIBE_CUSTOMER_COUPON_FAIL: UNSUBSCRIBE_CUSTOMER_COUPON_FAIL,\n  UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS: UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS,\n  RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS: RESET_UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS,\n  CLAIM_CUSTOMER_COUPON: CLAIM_CUSTOMER_COUPON,\n  CLAIM_CUSTOMER_COUPON_FAIL: CLAIM_CUSTOMER_COUPON_FAIL,\n  CLAIM_CUSTOMER_COUPON_SUCCESS: CLAIM_CUSTOMER_COUPON_SUCCESS,\n  LoadCustomerCoupons: LoadCustomerCoupons,\n  LoadCustomerCouponsFail: LoadCustomerCouponsFail,\n  LoadCustomerCouponsSuccess: LoadCustomerCouponsSuccess,\n  ResetLoadCustomerCoupons: ResetLoadCustomerCoupons,\n  SubscribeCustomerCoupon: SubscribeCustomerCoupon,\n  SubscribeCustomerCouponFail: SubscribeCustomerCouponFail,\n  SubscribeCustomerCouponSuccess: SubscribeCustomerCouponSuccess,\n  ResetSubscribeCustomerCouponProcess: ResetSubscribeCustomerCouponProcess,\n  UnsubscribeCustomerCoupon: UnsubscribeCustomerCoupon,\n  UnsubscribeCustomerCouponFail: UnsubscribeCustomerCouponFail,\n  UnsubscribeCustomerCouponSuccess: UnsubscribeCustomerCouponSuccess,\n  ResetUnsubscribeCustomerCouponProcess: ResetUnsubscribeCustomerCouponProcess,\n  ClaimCustomerCoupon: ClaimCustomerCoupon,\n  ClaimCustomerCouponFail: ClaimCustomerCouponFail,\n  ClaimCustomerCouponSuccess: ClaimCustomerCouponSuccess,\n  LOAD_DELIVERY_COUNTRIES: LOAD_DELIVERY_COUNTRIES,\n  LOAD_DELIVERY_COUNTRIES_FAIL: LOAD_DELIVERY_COUNTRIES_FAIL,\n  LOAD_DELIVERY_COUNTRIES_SUCCESS: LOAD_DELIVERY_COUNTRIES_SUCCESS,\n  LoadDeliveryCountries: LoadDeliveryCountries,\n  LoadDeliveryCountriesFail: LoadDeliveryCountriesFail,\n  LoadDeliveryCountriesSuccess: LoadDeliveryCountriesSuccess,\n  LOAD_NOTIFICATION_PREFERENCES: LOAD_NOTIFICATION_PREFERENCES,\n  LOAD_NOTIFICATION_PREFERENCES_FAIL: LOAD_NOTIFICATION_PREFERENCES_FAIL,\n  LOAD_NOTIFICATION_PREFERENCES_SUCCESS: LOAD_NOTIFICATION_PREFERENCES_SUCCESS,\n  UPDATE_NOTIFICATION_PREFERENCES: UPDATE_NOTIFICATION_PREFERENCES,\n  UPDATE_NOTIFICATION_PREFERENCES_FAIL: UPDATE_NOTIFICATION_PREFERENCES_FAIL,\n  UPDATE_NOTIFICATION_PREFERENCES_SUCCESS: UPDATE_NOTIFICATION_PREFERENCES_SUCCESS,\n  RESET_NOTIFICATION_PREFERENCES: RESET_NOTIFICATION_PREFERENCES,\n  CLEAR_NOTIFICATION_PREFERENCES: CLEAR_NOTIFICATION_PREFERENCES,\n  LoadNotificationPreferences: LoadNotificationPreferences,\n  LoadNotificationPreferencesFail: LoadNotificationPreferencesFail,\n  LoadNotificationPreferencesSuccess: LoadNotificationPreferencesSuccess,\n  UpdateNotificationPreferences: UpdateNotificationPreferences,\n  UpdateNotificationPreferencesFail: UpdateNotificationPreferencesFail,\n  UpdateNotificationPreferencesSuccess: UpdateNotificationPreferencesSuccess,\n  ResetNotificationPreferences: ResetNotificationPreferences,\n  ClearNotificationPreferences: ClearNotificationPreferences,\n  LOAD_ORDER_DETAILS: LOAD_ORDER_DETAILS,\n  LOAD_ORDER_DETAILS_FAIL: LOAD_ORDER_DETAILS_FAIL,\n  LOAD_ORDER_DETAILS_SUCCESS: LOAD_ORDER_DETAILS_SUCCESS,\n  CLEAR_ORDER_DETAILS: CLEAR_ORDER_DETAILS,\n  CANCEL_ORDER: CANCEL_ORDER,\n  CANCEL_ORDER_FAIL: CANCEL_ORDER_FAIL,\n  CANCEL_ORDER_SUCCESS: CANCEL_ORDER_SUCCESS,\n  RESET_CANCEL_ORDER_PROCESS: RESET_CANCEL_ORDER_PROCESS,\n  LoadOrderDetails: LoadOrderDetails,\n  LoadOrderDetailsFail: LoadOrderDetailsFail,\n  LoadOrderDetailsSuccess: LoadOrderDetailsSuccess,\n  ClearOrderDetails: ClearOrderDetails,\n  CancelOrder: CancelOrder,\n  CancelOrderFail: CancelOrderFail,\n  CancelOrderSuccess: CancelOrderSuccess,\n  ResetCancelOrderProcess: ResetCancelOrderProcess,\n  CREATE_ORDER_RETURN_REQUEST: CREATE_ORDER_RETURN_REQUEST,\n  CREATE_ORDER_RETURN_REQUEST_FAIL: CREATE_ORDER_RETURN_REQUEST_FAIL,\n  CREATE_ORDER_RETURN_REQUEST_SUCCESS: CREATE_ORDER_RETURN_REQUEST_SUCCESS,\n  LOAD_ORDER_RETURN_REQUEST: LOAD_ORDER_RETURN_REQUEST,\n  LOAD_ORDER_RETURN_REQUEST_FAIL: LOAD_ORDER_RETURN_REQUEST_FAIL,\n  LOAD_ORDER_RETURN_REQUEST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_SUCCESS,\n  CANCEL_ORDER_RETURN_REQUEST: CANCEL_ORDER_RETURN_REQUEST,\n  CANCEL_ORDER_RETURN_REQUEST_FAIL: CANCEL_ORDER_RETURN_REQUEST_FAIL,\n  CANCEL_ORDER_RETURN_REQUEST_SUCCESS: CANCEL_ORDER_RETURN_REQUEST_SUCCESS,\n  LOAD_ORDER_RETURN_REQUEST_LIST: LOAD_ORDER_RETURN_REQUEST_LIST,\n  LOAD_ORDER_RETURN_REQUEST_LIST_FAIL: LOAD_ORDER_RETURN_REQUEST_LIST_FAIL,\n  LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS: LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS,\n  CLEAR_ORDER_RETURN_REQUEST: CLEAR_ORDER_RETURN_REQUEST,\n  CLEAR_ORDER_RETURN_REQUEST_LIST: CLEAR_ORDER_RETURN_REQUEST_LIST,\n  RESET_CANCEL_RETURN_PROCESS: RESET_CANCEL_RETURN_PROCESS,\n  CreateOrderReturnRequest: CreateOrderReturnRequest,\n  CreateOrderReturnRequestFail: CreateOrderReturnRequestFail,\n  CreateOrderReturnRequestSuccess: CreateOrderReturnRequestSuccess,\n  LoadOrderReturnRequest: LoadOrderReturnRequest,\n  LoadOrderReturnRequestFail: LoadOrderReturnRequestFail,\n  LoadOrderReturnRequestSuccess: LoadOrderReturnRequestSuccess,\n  CancelOrderReturnRequest: CancelOrderReturnRequest,\n  CancelOrderReturnRequestFail: CancelOrderReturnRequestFail,\n  CancelOrderReturnRequestSuccess: CancelOrderReturnRequestSuccess,\n  LoadOrderReturnRequestList: LoadOrderReturnRequestList,\n  LoadOrderReturnRequestListFail: LoadOrderReturnRequestListFail,\n  LoadOrderReturnRequestListSuccess: LoadOrderReturnRequestListSuccess,\n  ClearOrderReturnRequest: ClearOrderReturnRequest,\n  ClearOrderReturnRequestList: ClearOrderReturnRequestList,\n  ResetCancelReturnProcess: ResetCancelReturnProcess,\n  LOAD_USER_PAYMENT_METHODS: LOAD_USER_PAYMENT_METHODS,\n  LOAD_USER_PAYMENT_METHODS_FAIL: LOAD_USER_PAYMENT_METHODS_FAIL,\n  LOAD_USER_PAYMENT_METHODS_SUCCESS: LOAD_USER_PAYMENT_METHODS_SUCCESS,\n  SET_DEFAULT_USER_PAYMENT_METHOD: SET_DEFAULT_USER_PAYMENT_METHOD,\n  SET_DEFAULT_USER_PAYMENT_METHOD_FAIL: SET_DEFAULT_USER_PAYMENT_METHOD_FAIL,\n  SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS: SET_DEFAULT_USER_PAYMENT_METHOD_SUCCESS,\n  DELETE_USER_PAYMENT_METHOD: DELETE_USER_PAYMENT_METHOD,\n  DELETE_USER_PAYMENT_METHOD_FAIL: DELETE_USER_PAYMENT_METHOD_FAIL,\n  DELETE_USER_PAYMENT_METHOD_SUCCESS: DELETE_USER_PAYMENT_METHOD_SUCCESS,\n  LoadUserPaymentMethods: LoadUserPaymentMethods,\n  LoadUserPaymentMethodsFail: LoadUserPaymentMethodsFail,\n  LoadUserPaymentMethodsSuccess: LoadUserPaymentMethodsSuccess,\n  SetDefaultUserPaymentMethod: SetDefaultUserPaymentMethod,\n  SetDefaultUserPaymentMethodFail: SetDefaultUserPaymentMethodFail,\n  SetDefaultUserPaymentMethodSuccess: SetDefaultUserPaymentMethodSuccess,\n  DeleteUserPaymentMethod: DeleteUserPaymentMethod,\n  DeleteUserPaymentMethodFail: DeleteUserPaymentMethodFail,\n  DeleteUserPaymentMethodSuccess: DeleteUserPaymentMethodSuccess,\n  LOAD_PRODUCT_INTERESTS: LOAD_PRODUCT_INTERESTS,\n  LOAD_PRODUCT_INTERESTS_FAIL: LOAD_PRODUCT_INTERESTS_FAIL,\n  LOAD_PRODUCT_INTERESTS_SUCCESS: LOAD_PRODUCT_INTERESTS_SUCCESS,\n  REMOVE_PRODUCT_INTEREST: REMOVE_PRODUCT_INTEREST,\n  REMOVE_PRODUCT_INTEREST_SUCCESS: REMOVE_PRODUCT_INTEREST_SUCCESS,\n  REMOVE_PRODUCT_INTEREST_FAIL: REMOVE_PRODUCT_INTEREST_FAIL,\n  ADD_PRODUCT_INTEREST: ADD_PRODUCT_INTEREST,\n  ADD_PRODUCT_INTEREST_FAIL: ADD_PRODUCT_INTEREST_FAIL,\n  ADD_PRODUCT_INTEREST_SUCCESS: ADD_PRODUCT_INTEREST_SUCCESS,\n  ADD_PRODUCT_INTEREST_RESET: ADD_PRODUCT_INTEREST_RESET,\n  REMOVE_PRODUCT_INTEREST_RESET: REMOVE_PRODUCT_INTEREST_RESET,\n  CLEAR_PRODUCT_INTERESTS: CLEAR_PRODUCT_INTERESTS,\n  LoadProductInterests: LoadProductInterests,\n  LoadProductInterestsFail: LoadProductInterestsFail,\n  LoadProductInterestsSuccess: LoadProductInterestsSuccess,\n  RemoveProductInterest: RemoveProductInterest,\n  RemoveProductInterestSuccess: RemoveProductInterestSuccess,\n  RemoveProductInterestFail: RemoveProductInterestFail,\n  AddProductInterest: AddProductInterest,\n  AddProductInterestSuccess: AddProductInterestSuccess,\n  AddProductInterestFail: AddProductInterestFail,\n  ResetAddInterestState: ResetAddInterestState,\n  ResetRemoveInterestState: ResetRemoveInterestState,\n  ClearProductInterests: ClearProductInterests,\n  LOAD_REGIONS: LOAD_REGIONS,\n  LOAD_REGIONS_SUCCESS: LOAD_REGIONS_SUCCESS,\n  LOAD_REGIONS_FAIL: LOAD_REGIONS_FAIL,\n  CLEAR_REGIONS: CLEAR_REGIONS,\n  LoadRegions: LoadRegions,\n  LoadRegionsFail: LoadRegionsFail,\n  LoadRegionsSuccess: LoadRegionsSuccess,\n  ClearRegions: ClearRegions,\n  LOAD_REPLENISHMENT_ORDER_DETAILS: LOAD_REPLENISHMENT_ORDER_DETAILS,\n  LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS: LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS,\n  LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL: LOAD_REPLENISHMENT_ORDER_DETAILS_FAIL,\n  ClEAR_REPLENISHMENT_ORDER_DETAILS: ClEAR_REPLENISHMENT_ORDER_DETAILS,\n  CANCEL_REPLENISHMENT_ORDER: CANCEL_REPLENISHMENT_ORDER,\n  CANCEL_REPLENISHMENT_ORDER_SUCCESS: CANCEL_REPLENISHMENT_ORDER_SUCCESS,\n  CANCEL_REPLENISHMENT_ORDER_FAIL: CANCEL_REPLENISHMENT_ORDER_FAIL,\n  CLEAR_CANCEL_REPLENISHMENT_ORDER: CLEAR_CANCEL_REPLENISHMENT_ORDER,\n  LoadReplenishmentOrderDetails: LoadReplenishmentOrderDetails,\n  LoadReplenishmentOrderDetailsSuccess: LoadReplenishmentOrderDetailsSuccess,\n  LoadReplenishmentOrderDetailsFail: LoadReplenishmentOrderDetailsFail,\n  ClearReplenishmentOrderDetails: ClearReplenishmentOrderDetails,\n  CancelReplenishmentOrder: CancelReplenishmentOrder,\n  CancelReplenishmentOrderSuccess: CancelReplenishmentOrderSuccess,\n  CancelReplenishmentOrderFail: CancelReplenishmentOrderFail,\n  ClearCancelReplenishmentOrder: ClearCancelReplenishmentOrder,\n  LOAD_USER_ADDRESSES: LOAD_USER_ADDRESSES,\n  LOAD_USER_ADDRESSES_FAIL: LOAD_USER_ADDRESSES_FAIL,\n  LOAD_USER_ADDRESSES_SUCCESS: LOAD_USER_ADDRESSES_SUCCESS,\n  ADD_USER_ADDRESS: ADD_USER_ADDRESS,\n  ADD_USER_ADDRESS_FAIL: ADD_USER_ADDRESS_FAIL,\n  ADD_USER_ADDRESS_SUCCESS: ADD_USER_ADDRESS_SUCCESS,\n  UPDATE_USER_ADDRESS: UPDATE_USER_ADDRESS,\n  UPDATE_USER_ADDRESS_FAIL: UPDATE_USER_ADDRESS_FAIL,\n  UPDATE_USER_ADDRESS_SUCCESS: UPDATE_USER_ADDRESS_SUCCESS,\n  DELETE_USER_ADDRESS: DELETE_USER_ADDRESS,\n  DELETE_USER_ADDRESS_FAIL: DELETE_USER_ADDRESS_FAIL,\n  DELETE_USER_ADDRESS_SUCCESS: DELETE_USER_ADDRESS_SUCCESS,\n  LoadUserAddresses: LoadUserAddresses,\n  LoadUserAddressesFail: LoadUserAddressesFail,\n  LoadUserAddressesSuccess: LoadUserAddressesSuccess,\n  AddUserAddress: AddUserAddress,\n  AddUserAddressFail: AddUserAddressFail,\n  AddUserAddressSuccess: AddUserAddressSuccess,\n  UpdateUserAddress: UpdateUserAddress,\n  UpdateUserAddressFail: UpdateUserAddressFail,\n  UpdateUserAddressSuccess: UpdateUserAddressSuccess,\n  DeleteUserAddress: DeleteUserAddress,\n  DeleteUserAddressFail: DeleteUserAddressFail,\n  DeleteUserAddressSuccess: DeleteUserAddressSuccess,\n  LOAD_USER_CONSENTS: LOAD_USER_CONSENTS,\n  LOAD_USER_CONSENTS_SUCCESS: LOAD_USER_CONSENTS_SUCCESS,\n  LOAD_USER_CONSENTS_FAIL: LOAD_USER_CONSENTS_FAIL,\n  RESET_LOAD_USER_CONSENTS: RESET_LOAD_USER_CONSENTS,\n  GIVE_USER_CONSENT: GIVE_USER_CONSENT,\n  GIVE_USER_CONSENT_FAIL: GIVE_USER_CONSENT_FAIL,\n  GIVE_USER_CONSENT_SUCCESS: GIVE_USER_CONSENT_SUCCESS,\n  RESET_GIVE_USER_CONSENT_PROCESS: RESET_GIVE_USER_CONSENT_PROCESS,\n  TRANSFER_ANONYMOUS_CONSENT: TRANSFER_ANONYMOUS_CONSENT,\n  WITHDRAW_USER_CONSENT: WITHDRAW_USER_CONSENT,\n  WITHDRAW_USER_CONSENT_FAIL: WITHDRAW_USER_CONSENT_FAIL,\n  WITHDRAW_USER_CONSENT_SUCCESS: WITHDRAW_USER_CONSENT_SUCCESS,\n  RESET_WITHDRAW_USER_CONSENT_PROCESS: RESET_WITHDRAW_USER_CONSENT_PROCESS,\n  LoadUserConsents: LoadUserConsents,\n  LoadUserConsentsFail: LoadUserConsentsFail,\n  LoadUserConsentsSuccess: LoadUserConsentsSuccess,\n  ResetLoadUserConsents: ResetLoadUserConsents,\n  GiveUserConsent: GiveUserConsent,\n  GiveUserConsentFail: GiveUserConsentFail,\n  GiveUserConsentSuccess: GiveUserConsentSuccess,\n  ResetGiveUserConsentProcess: ResetGiveUserConsentProcess,\n  TransferAnonymousConsent: TransferAnonymousConsent,\n  WithdrawUserConsent: WithdrawUserConsent,\n  WithdrawUserConsentFail: WithdrawUserConsentFail,\n  WithdrawUserConsentSuccess: WithdrawUserConsentSuccess,\n  ResetWithdrawUserConsentProcess: ResetWithdrawUserConsentProcess,\n  LOAD_ACTIVE_COST_CENTERS: LOAD_ACTIVE_COST_CENTERS,\n  LOAD_ACTIVE_COST_CENTERS_FAIL: LOAD_ACTIVE_COST_CENTERS_FAIL,\n  LOAD_ACTIVE_COST_CENTERS_SUCCESS: LOAD_ACTIVE_COST_CENTERS_SUCCESS,\n  LoadActiveCostCenters: LoadActiveCostCenters,\n  LoadActiveCostCentersFail: LoadActiveCostCentersFail,\n  LoadActiveCostCentersSuccess: LoadActiveCostCentersSuccess,\n  CLEAR_USER_MISCS_DATA: CLEAR_USER_MISCS_DATA,\n  ClearUserMiscsData: ClearUserMiscsData,\n  LOAD_USER_ORDERS: LOAD_USER_ORDERS,\n  LOAD_USER_ORDERS_FAIL: LOAD_USER_ORDERS_FAIL,\n  LOAD_USER_ORDERS_SUCCESS: LOAD_USER_ORDERS_SUCCESS,\n  CLEAR_USER_ORDERS: CLEAR_USER_ORDERS,\n  LoadUserOrders: LoadUserOrders,\n  LoadUserOrdersFail: LoadUserOrdersFail,\n  LoadUserOrdersSuccess: LoadUserOrdersSuccess,\n  ClearUserOrders: ClearUserOrders,\n  REGISTER_USER_SUCCESS: REGISTER_USER_SUCCESS,\n  RegisterUserSuccess: RegisterUserSuccess,\n  LOAD_USER_REPLENISHMENT_ORDERS: LOAD_USER_REPLENISHMENT_ORDERS,\n  LOAD_USER_REPLENISHMENT_ORDERS_FAIL: LOAD_USER_REPLENISHMENT_ORDERS_FAIL,\n  LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS: LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS,\n  CLEAR_USER_REPLENISHMENT_ORDERS: CLEAR_USER_REPLENISHMENT_ORDERS,\n  LoadUserReplenishmentOrders: LoadUserReplenishmentOrders,\n  LoadUserReplenishmentOrdersFail: LoadUserReplenishmentOrdersFail,\n  LoadUserReplenishmentOrdersSuccess: LoadUserReplenishmentOrdersSuccess,\n  ClearUserReplenishmentOrders: ClearUserReplenishmentOrders\n});\nclass AnonymousConsentTemplatesAdapter {}\nlet AnonymousConsentTemplatesConnector = /*#__PURE__*/(() => {\n  class AnonymousConsentTemplatesConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    loadAnonymousConsentTemplates() {\n      return this.adapter.loadAnonymousConsentTemplates();\n    }\n    loadAnonymousConsents() {\n      return this.adapter.loadAnonymousConsents();\n    }\n  }\n  AnonymousConsentTemplatesConnector.ɵfac = function AnonymousConsentTemplatesConnector_Factory(t) {\n    return new (t || AnonymousConsentTemplatesConnector)(i0.ɵɵinject(AnonymousConsentTemplatesAdapter));\n  };\n  AnonymousConsentTemplatesConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentTemplatesConnector,\n    factory: AnonymousConsentTemplatesConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return AnonymousConsentTemplatesConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst getUserState = createFeatureSelector(USER_FEATURE);\nconst getBillingCountriesState = createSelector(getUserState, state => state.billingCountries);\nconst getBillingCountriesEntites = createSelector(getBillingCountriesState, state => state.entities);\nconst getAllBillingCountries = createSelector(getBillingCountriesEntites, entites => Object.keys(entites).map(isocode => entites[isocode]));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getConsignmentTrackingState = createSelector(getUserState, state => state.consignmentTracking);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getConsignmentTracking = createSelector(getConsignmentTrackingState, state => state.tracking);\nconst getCustomerCouponsState = createSelector(getUserState, state => state.customerCoupons);\nconst getCustomerCouponsLoaded = createSelector(getCustomerCouponsState, state => loaderSuccessSelector(state));\nconst getCustomerCouponsLoading = createSelector(getCustomerCouponsState, state => loaderLoadingSelector(state));\nconst getCustomerCoupons = createSelector(getCustomerCouponsState, state => loaderValueSelector(state));\nconst getDeliveryCountriesState = createSelector(getUserState, state => state.countries);\nconst getDeliveryCountriesEntites = createSelector(getDeliveryCountriesState, state => state.entities);\nconst getAllDeliveryCountries = createSelector(getDeliveryCountriesEntites, entites => Object.keys(entites).map(isocode => entites[isocode]));\nconst countrySelectorFactory = isocode => createSelector(getDeliveryCountriesEntites, entities => Object.keys(entities).length !== 0 ? entities[isocode] : null);\nconst getPreferencesLoaderState = createSelector(getUserState, state => state.notificationPreferences);\nconst getPreferences = createSelector(getPreferencesLoaderState, state => loaderValueSelector(state));\nconst getEnabledPreferences = createSelector(getPreferencesLoaderState, state => loaderValueSelector(state).filter(p => p.enabled));\nconst getPreferencesLoading = createSelector(getPreferencesLoaderState, state => loaderLoadingSelector(state));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderState = createSelector(getUserState, state => state.order);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderDetails = createSelector(getOrderState, state => loaderValueSelector(state));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequestState = createSelector(getUserState, state => state.orderReturn);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequest = createSelector(getOrderReturnRequestState, state => loaderValueSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequestLoading = createSelector(getOrderReturnRequestState, state => loaderLoadingSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequestSuccess = createSelector(getOrderReturnRequestState, state => loaderSuccessSelector(state) && !loaderLoadingSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequestListState = createSelector(getUserState, state => state.orderReturnList);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrderReturnRequestList = createSelector(getOrderReturnRequestListState, state => loaderValueSelector(state));\nconst getPaymentMethodsState = createSelector(getUserState, state => state.payments);\nconst getPaymentMethods = createSelector(getPaymentMethodsState, state => loaderValueSelector(state));\nconst getPaymentMethodsLoading = createSelector(getPaymentMethodsState, state => loaderLoadingSelector(state));\nconst getPaymentMethodsLoadedSuccess = createSelector(getPaymentMethodsState, state => loaderSuccessSelector(state) && !loaderLoadingSelector(state));\nconst getInterestsState = createSelector(getUserState, state => state.productInterests);\nconst getInterests = createSelector(getInterestsState, state => loaderValueSelector(state));\nconst getInterestsLoading = createSelector(getInterestsState, state => loaderLoadingSelector(state));\nconst getRegionsLoaderState = createSelector(getUserState, state => state.regions);\nconst getAllRegions = createSelector(getRegionsLoaderState, state => {\n  return loaderValueSelector(state).entities;\n});\nconst getRegionsDataAndLoading = createSelector(getRegionsLoaderState, state => ({\n  loaded: loaderSuccessSelector(state),\n  loading: loaderLoadingSelector(state),\n  regions: loaderValueSelector(state).entities,\n  country: loaderValueSelector(state).country\n}));\nconst getRegionsCountry = createSelector(getRegionsLoaderState, state => loaderValueSelector(state).country);\nconst getRegionsLoading = createSelector(getRegionsLoaderState, state => loaderLoadingSelector(state));\nconst getRegionsLoaded = createSelector(getRegionsLoaderState, state => loaderSuccessSelector(state));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrderState = createSelector(getUserState, state => state.replenishmentOrder);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrderDetailsValue = createSelector(getReplenishmentOrderState, state => loaderValueSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrderDetailsLoading = createSelector(getReplenishmentOrderState, state => loaderLoadingSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrderDetailsSuccess = createSelector(getReplenishmentOrderState, state => loaderSuccessSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrderDetailsError = createSelector(getReplenishmentOrderState, state => loaderErrorSelector(state));\nconst getAddressesLoaderState = createSelector(getUserState, state => state.addresses);\nconst getAddresses = createSelector(getAddressesLoaderState, state => loaderValueSelector(state));\nconst getAddressesLoading = createSelector(getAddressesLoaderState, state => loaderLoadingSelector(state));\nconst getAddressesLoadedSuccess = createSelector(getAddressesLoaderState, state => loaderSuccessSelector(state) && !loaderLoadingSelector(state));\nconst getConsentsState = createSelector(getUserState, state => state.consents);\nconst getConsentsValue = createSelector(getConsentsState, loaderValueSelector);\nconst getConsentByTemplateId = templateId => createSelector(getConsentsValue, templates => templates.find(template => template.id === templateId));\nconst getConsentsLoading = createSelector(getConsentsState, loaderLoadingSelector);\nconst getConsentsSuccess = createSelector(getConsentsState, loaderSuccessSelector);\nconst getConsentsError = createSelector(getConsentsState, loaderErrorSelector);\nconst getCostCentersState = createSelector(getUserState, state => state.costCenters);\nconst getCostCenters = createSelector(getCostCentersState, state => loaderValueSelector(state));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrdersState = createSelector(getUserState, state => state.orders);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrdersLoaded = createSelector(getOrdersState, state => loaderSuccessSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getOrders = createSelector(getOrdersState, state => loaderValueSelector(state));\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrdersState = createSelector(getUserState, state => state.replenishmentOrders);\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrders = createSelector(getReplenishmentOrdersState, state => loaderValueSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrdersLoading = createSelector(getReplenishmentOrdersState, state => loaderLoadingSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrdersError = createSelector(getReplenishmentOrdersState, state => loaderErrorSelector(state));\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst getReplenishmentOrdersSuccess = createSelector(getReplenishmentOrdersState, state => loaderSuccessSelector(state));\nvar usersGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getBillingCountriesState: getBillingCountriesState,\n  getBillingCountriesEntites: getBillingCountriesEntites,\n  getAllBillingCountries: getAllBillingCountries,\n  getConsignmentTrackingState: getConsignmentTrackingState,\n  getConsignmentTracking: getConsignmentTracking,\n  getCustomerCouponsState: getCustomerCouponsState,\n  getCustomerCouponsLoaded: getCustomerCouponsLoaded,\n  getCustomerCouponsLoading: getCustomerCouponsLoading,\n  getCustomerCoupons: getCustomerCoupons,\n  getDeliveryCountriesState: getDeliveryCountriesState,\n  getDeliveryCountriesEntites: getDeliveryCountriesEntites,\n  getAllDeliveryCountries: getAllDeliveryCountries,\n  countrySelectorFactory: countrySelectorFactory,\n  getUserState: getUserState,\n  getPreferencesLoaderState: getPreferencesLoaderState,\n  getPreferences: getPreferences,\n  getEnabledPreferences: getEnabledPreferences,\n  getPreferencesLoading: getPreferencesLoading,\n  getOrderState: getOrderState,\n  getOrderDetails: getOrderDetails,\n  getOrderReturnRequestState: getOrderReturnRequestState,\n  getOrderReturnRequest: getOrderReturnRequest,\n  getOrderReturnRequestLoading: getOrderReturnRequestLoading,\n  getOrderReturnRequestSuccess: getOrderReturnRequestSuccess,\n  getOrderReturnRequestListState: getOrderReturnRequestListState,\n  getOrderReturnRequestList: getOrderReturnRequestList,\n  getPaymentMethodsState: getPaymentMethodsState,\n  getPaymentMethods: getPaymentMethods,\n  getPaymentMethodsLoading: getPaymentMethodsLoading,\n  getPaymentMethodsLoadedSuccess: getPaymentMethodsLoadedSuccess,\n  getInterestsState: getInterestsState,\n  getInterests: getInterests,\n  getInterestsLoading: getInterestsLoading,\n  getRegionsLoaderState: getRegionsLoaderState,\n  getAllRegions: getAllRegions,\n  getRegionsDataAndLoading: getRegionsDataAndLoading,\n  getRegionsCountry: getRegionsCountry,\n  getRegionsLoading: getRegionsLoading,\n  getRegionsLoaded: getRegionsLoaded,\n  getReplenishmentOrderState: getReplenishmentOrderState,\n  getReplenishmentOrderDetailsValue: getReplenishmentOrderDetailsValue,\n  getReplenishmentOrderDetailsLoading: getReplenishmentOrderDetailsLoading,\n  getReplenishmentOrderDetailsSuccess: getReplenishmentOrderDetailsSuccess,\n  getReplenishmentOrderDetailsError: getReplenishmentOrderDetailsError,\n  getAddressesLoaderState: getAddressesLoaderState,\n  getAddresses: getAddresses,\n  getAddressesLoading: getAddressesLoading,\n  getAddressesLoadedSuccess: getAddressesLoadedSuccess,\n  getConsentsState: getConsentsState,\n  getConsentsValue: getConsentsValue,\n  getConsentByTemplateId: getConsentByTemplateId,\n  getConsentsLoading: getConsentsLoading,\n  getConsentsSuccess: getConsentsSuccess,\n  getConsentsError: getConsentsError,\n  getCostCentersState: getCostCentersState,\n  getCostCenters: getCostCenters,\n  getOrdersState: getOrdersState,\n  getOrdersLoaded: getOrdersLoaded,\n  getOrders: getOrders,\n  getReplenishmentOrdersState: getReplenishmentOrdersState,\n  getReplenishmentOrders: getReplenishmentOrders,\n  getReplenishmentOrdersLoading: getReplenishmentOrdersLoading,\n  getReplenishmentOrdersError: getReplenishmentOrdersError,\n  getReplenishmentOrdersSuccess: getReplenishmentOrdersSuccess\n});\nlet UserConsentService = /*#__PURE__*/(() => {\n  class UserConsentService {\n    constructor(store, authService, userIdService) {\n      this.store = store;\n      this.authService = authService;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Retrieves all consents.\n     */\n    loadConsents() {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadUserConsents(userId));\n      });\n    }\n    /**\n     * Returns all consent templates. If `loadIfMissing` parameter is set to `true`, the method triggers the load if consent templates.\n     * @param loadIfMissing is set to `true`, the method will load templates if those are not already present. The default value is `false`.\n     */\n    getConsents(loadIfMissing = false) {\n      return iif(() => loadIfMissing, this.store.pipe(select(getConsentsValue), withLatestFrom(this.getConsentsResultLoading(), this.getConsentsResultSuccess()), filter(([_templates, loading, _success]) => !loading), tap(([templates, _loading, success]) => {\n        if (!templates || templates.length === 0) {\n          // avoid infite loop - if we've already attempted to load templates and we got an empty array as the response\n          if (!success) {\n            this.loadConsents();\n          }\n        }\n      }), filter(([templates, _loading]) => Boolean(templates)), map(([templates, _loading]) => templates)), this.store.pipe(select(getConsentsValue)));\n    }\n    /**\n     * Returns the consents loading flag\n     */\n    getConsentsResultLoading() {\n      return this.store.pipe(select(getConsentsLoading));\n    }\n    /**\n     * Returns the consents success flag\n     */\n    getConsentsResultSuccess() {\n      return this.store.pipe(select(getConsentsSuccess));\n    }\n    /**\n     * Returns the consents error flag\n     */\n    getConsentsResultError() {\n      return this.store.pipe(select(getConsentsError));\n    }\n    /**\n     * Resets the processing state for consent retrieval\n     */\n    resetConsentsProcessState() {\n      this.store.dispatch(new ResetLoadUserConsents());\n    }\n    /**\n     * Returns the registered consent for the given template ID.\n     *\n     * As a side-effect, the method will call `getConsents(true)` to load the templates if those are not present.\n     *\n     * @param templateId a template ID by which to filter the registered templates.\n     */\n    getConsent(templateId) {\n      return this.authService.isUserLoggedIn().pipe(filter(Boolean), tap(() => this.getConsents(true)), switchMap(() => this.store.pipe(select(getConsentByTemplateId(templateId)))), filter(template => Boolean(template)), map(template => template.currentConsent));\n    }\n    /**\n     * Returns `true` if the consent is truthy and if `consentWithdrawnDate` doesn't exist.\n     * Otherwise, `false` is returned.\n     *\n     * @param consent to check\n     */\n    isConsentGiven(consent) {\n      return Boolean(consent) && Boolean(consent.consentGivenDate) && !Boolean(consent.consentWithdrawnDate);\n    }\n    /**\n     * Returns `true` if the consent is either falsy or if `consentWithdrawnDate` is present.\n     * Otherwise, `false` is returned.\n     *\n     * @param consent to check\n     */\n    isConsentWithdrawn(consent) {\n      if (Boolean(consent)) {\n        return Boolean(consent.consentWithdrawnDate);\n      }\n      return true;\n    }\n    /**\n     * Give consent for specified consent template ID and version.\n     * @param consentTemplateId a template ID for which to give a consent\n     * @param consentTemplateVersion a template version for which to give a consent\n     */\n    giveConsent(consentTemplateId, consentTemplateVersion) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new GiveUserConsent({\n          userId,\n          consentTemplateId,\n          consentTemplateVersion\n        }));\n      });\n    }\n    /**\n     * Returns the give consent process loading flag\n     */\n    getGiveConsentResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the give consent process success flag\n     */\n    getGiveConsentResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the give consent process error flag\n     */\n    getGiveConsentResultError() {\n      return this.store.pipe(select(getProcessErrorFactory(GIVE_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Resents the give consent process flags\n     */\n    resetGiveConsentProcessState() {\n      return this.store.dispatch(new ResetGiveUserConsentProcess());\n    }\n    /**\n     * Withdraw consent for the given `consentCode`\n     * @param consentCode for which to withdraw the consent\n     */\n    withdrawConsent(consentCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new WithdrawUserConsent({\n          userId,\n          consentCode\n        }));\n      });\n    }\n    /**\n     * Returns the withdraw consent process loading flag\n     */\n    getWithdrawConsentResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the withdraw consent process success flag\n     */\n    getWithdrawConsentResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Returns the withdraw consent process error flag\n     */\n    getWithdrawConsentResultError() {\n      return this.store.pipe(select(getProcessErrorFactory(WITHDRAW_CONSENT_PROCESS_ID)));\n    }\n    /**\n     * Resets the process flags for withdraw consent\n     */\n    resetWithdrawConsentProcessState() {\n      return this.store.dispatch(new ResetWithdrawUserConsentProcess());\n    }\n    /**\n     * Filters the provided `templateList`' templates by hiding the template IDs specified in `hideTemplateIds`.\n     * If the `hideTemplateIds` is empty, the provided `templateList` is returned.\n     *\n     * @param templateList a list of consent templates to filter\n     * @param hideTemplateIds template IDs to hide\n     */\n    filterConsentTemplates(templateList, hideTemplateIds = []) {\n      if (hideTemplateIds.length === 0) {\n        return templateList;\n      }\n      const updatedTemplateList = [];\n      for (const template of templateList) {\n        const show = !hideTemplateIds.includes(template.id);\n        if (show) {\n          updatedTemplateList.push(template);\n        }\n      }\n      return updatedTemplateList;\n    }\n  }\n  UserConsentService.ɵfac = function UserConsentService_Factory(t) {\n    return new (t || UserConsentService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(AuthService), i0.ɵɵinject(UserIdService));\n  };\n  UserConsentService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserConsentService,\n    factory: UserConsentService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserConsentService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentsEffects = /*#__PURE__*/(() => {\n  class AnonymousConsentsEffects {\n    constructor(actions$, anonymousConsentTemplatesConnector, authService, anonymousConsentsConfig, anonymousConsentService, userConsentService, userIdService) {\n      this.actions$ = actions$;\n      this.anonymousConsentTemplatesConnector = anonymousConsentTemplatesConnector;\n      this.authService = authService;\n      this.anonymousConsentsConfig = anonymousConsentsConfig;\n      this.anonymousConsentService = anonymousConsentService;\n      this.userConsentService = userConsentService;\n      this.userIdService = userIdService;\n      this.checkConsentVersions$ = this.actions$.pipe(ofType(ANONYMOUS_CONSENT_CHECK_UPDATED_VERSIONS), withLatestFrom(this.anonymousConsentService.getConsents()), concatMap(([_, currentConsents]) => {\n        return this.anonymousConsentTemplatesConnector.loadAnonymousConsents().pipe(map(newConsents => {\n          if (!newConsents) {\n            if (isDevMode()) {\n              console.warn('No consents were loaded. Please check the Spartacus documentation as this could be a back-end configuration issue.');\n            }\n            return false;\n          }\n          const currentConsentVersions = currentConsents.map(consent => consent.templateVersion);\n          const newConsentVersions = newConsents.map(consent => consent.templateVersion);\n          return this.detectUpdatedVersion(currentConsentVersions, newConsentVersions);\n        }), switchMap(updated => updated ? of(new LoadAnonymousConsentTemplates()) : EMPTY), catchError(error => of(new LoadAnonymousConsentTemplatesFail(normalizeHttpError(error)))));\n      }));\n      this.loadAnonymousConsentTemplates$ = this.actions$.pipe(ofType(LOAD_ANONYMOUS_CONSENT_TEMPLATES), withLatestFrom(this.anonymousConsentService.getTemplates()), concatMap(([_, currentConsentTemplates]) => this.anonymousConsentTemplatesConnector.loadAnonymousConsentTemplates().pipe(mergeMap(newConsentTemplates => {\n        let updated = false;\n        if (currentConsentTemplates && currentConsentTemplates.length !== 0) {\n          updated = this.anonymousConsentService.detectUpdatedTemplates(currentConsentTemplates, newConsentTemplates);\n        }\n        return [new LoadAnonymousConsentTemplatesSuccess(newConsentTemplates), new ToggleAnonymousConsentTemplatesUpdated(updated)];\n      }), catchError(error => of(new LoadAnonymousConsentTemplatesFail(normalizeHttpError(error)))))));\n      // TODO(#9416): This won't work with flow different than `Resource Owner Password Flow` which involves redirect (maybe in popup in will work)\n      this.transferAnonymousConsentsToUser$ = this.actions$.pipe(ofType(LOGIN), filter(() => Boolean(this.anonymousConsentsConfig.anonymousConsents)), withLatestFrom(this.actions$.pipe(ofType(REGISTER_USER_SUCCESS))), filter(([, registerAction]) => Boolean(registerAction)), switchMap(() => this.anonymousConsentService.getConsents().pipe(withLatestFrom(this.userIdService.getUserId(), this.anonymousConsentService.getTemplates(), this.authService.isUserLoggedIn()), filter(([,,, loggedIn]) => loggedIn), concatMap(([consents, userId, templates, _loggedIn]) => {\n        const actions = [];\n        for (const consent of consents) {\n          if (this.anonymousConsentService.isConsentGiven(consent) && (!this.anonymousConsentsConfig.anonymousConsents.requiredConsents || !this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(consent.templateCode))) {\n            for (const template of templates) {\n              if (template.id === consent.templateCode) {\n                actions.push(new TransferAnonymousConsent({\n                  userId,\n                  consentTemplateId: template.id,\n                  consentTemplateVersion: template.version\n                }));\n                break;\n              }\n            }\n          }\n        }\n        if (actions.length > 0) {\n          return actions;\n        }\n        return EMPTY;\n      }))));\n      this.giveRequiredConsentsToUser$ = this.actions$.pipe(ofType(LOGIN), filter(action => Boolean(this.anonymousConsentsConfig.anonymousConsents) && Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) && Boolean(action)), concatMap(() => this.userConsentService.getConsentsResultSuccess().pipe(withLatestFrom(this.userIdService.getUserId(), this.userConsentService.getConsents(), this.authService.isUserLoggedIn()), filter(([,,, loggedIn]) => loggedIn), tap(([loaded, _userId, _templates, _loggedIn]) => {\n        if (!loaded) {\n          this.userConsentService.loadConsents();\n        }\n      }), map(([_loaded, userId, templates, _loggedIn]) => {\n        return {\n          userId,\n          templates\n        };\n      }), concatMap(({\n        userId,\n        templates\n      }) => {\n        const actions = [];\n        for (const template of templates) {\n          if (this.userConsentService.isConsentWithdrawn(template.currentConsent) && this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id)) {\n            actions.push(new GiveUserConsent({\n              userId,\n              consentTemplateId: template.id,\n              consentTemplateVersion: template.version\n            }));\n          }\n        }\n        if (actions.length > 0) {\n          return actions;\n        }\n        return EMPTY;\n      }))));\n    }\n    /**\n     * Compares the given versions and determines if there's a mismatch,\n     * in which case `true` is returned.\n     *\n     * @param currentVersions versions of the current consents\n     * @param newVersions versions of the new consents\n     */\n    detectUpdatedVersion(currentVersions, newVersions) {\n      if (currentVersions.length !== newVersions.length) {\n        return true;\n      }\n      for (let i = 0; i < newVersions.length; i++) {\n        if (currentVersions[i] !== newVersions[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  AnonymousConsentsEffects.ɵfac = function AnonymousConsentsEffects_Factory(t) {\n    return new (t || AnonymousConsentsEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(AnonymousConsentTemplatesConnector), i0.ɵɵinject(AuthService), i0.ɵɵinject(AnonymousConsentsConfig), i0.ɵɵinject(AnonymousConsentsService), i0.ɵɵinject(UserConsentService), i0.ɵɵinject(UserIdService));\n  };\n  AnonymousConsentsEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentsEffects,\n    factory: AnonymousConsentsEffects.ɵfac\n  });\n  __decorate([Effect()], AnonymousConsentsEffects.prototype, \"checkConsentVersions$\", void 0);\n  __decorate([Effect()], AnonymousConsentsEffects.prototype, \"loadAnonymousConsentTemplates$\", void 0);\n  __decorate([Effect()], AnonymousConsentsEffects.prototype, \"transferAnonymousConsentsToUser$\", void 0);\n  __decorate([Effect()], AnonymousConsentsEffects.prototype, \"giveRequiredConsentsToUser$\", void 0);\n  return AnonymousConsentsEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$5 = [AnonymousConsentsEffects];\nlet JavaRegExpConverter = /*#__PURE__*/(() => {\n  class JavaRegExpConverter {\n    constructor() {\n      /**\n       * Pattern that extracts modifiers from the Java regexp.\n       *\n       * Java regexps MAY start with ONE or MANY modifiers like `(?MODIFIERS)PATTERN`. Examples:\n       * - `(?i)` for Case Insensitive Mode: `(?i)PATTERN`\n       * - `(?u)` for Unicode-Aware Case Folding; `(?u)PATTERN`\n       * - or multiple combined:  `(?iu)PATTERN`\n       * - (more modifiers in the official Java docs https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)\n       *\n       * This pattern extracts 3 parts from the input string, i.e. for `(?iu)PATTERN`:\n       *    1. original modifiers syntax, i.e. `(?iu)` (or undefined if no modifiers present)\n       *    2. extracted modifiers, i.e. `iu` (or undefined if no modifiers present)\n       *    3. the rest of the regexp, i.e. `PATTERN`\n       */\n      this.EXTRACT_JAVA_REGEXP_MODIFIERS = /^(\\(\\?([a-z]+)\\))?(.*)/;\n    }\n    /**\n     * Converts RegExp from Java syntax to Javascript, by recognizing Java regexp modifiers\n     * and converting them to the Javascript ones (i.e. case insensitive mode: `(?i)PATTERN` -> `/pattern/i`)\n     *\n     * **CAUTION!** Not all features and modifiers of Java regexps are valid in Javascript!\n     * If unsupported feature or modifier is used, then `null` will be returned instead of Javascript RegExp.\n     *\n     * See differences between Java and Javascript regexps:\n     * - https://stackoverflow.com/questions/8754444/convert-javascript-regular-expression-to-java-syntax\n     * - https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines#Language_features\n     */\n    toJsRegExp(javaSyntax) {\n      const parts = javaSyntax.match(this.EXTRACT_JAVA_REGEXP_MODIFIERS);\n      if (!parts) {\n        return null;\n      }\n      const [,, modifiers, jsSyntax] = parts;\n      try {\n        return new RegExp(jsSyntax, modifiers);\n      } catch (error) {\n        if (isDevMode()) {\n          console.warn(`WARNING: Could not convert Java regexp into Javascript. Original regexp: ${javaSyntax} \\nMessage: ${error}`);\n        }\n        return null;\n      }\n    }\n  }\n  JavaRegExpConverter.ɵfac = function JavaRegExpConverter_Factory(t) {\n    return new (t || JavaRegExpConverter)();\n  };\n  JavaRegExpConverter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: JavaRegExpConverter,\n    factory: JavaRegExpConverter.ɵfac,\n    providedIn: 'root'\n  });\n  return JavaRegExpConverter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SiteContextConfigInitializer = /*#__PURE__*/(() => {\n  class SiteContextConfigInitializer {\n    constructor(baseSiteService, javaRegExpConverter, winRef) {\n      this.baseSiteService = baseSiteService;\n      this.javaRegExpConverter = javaRegExpConverter;\n      this.winRef = winRef;\n      this.scopes = ['context'];\n      this.configFactory = () => this.resolveConfig().toPromise();\n    }\n    get currentUrl() {\n      return this.winRef.location.href;\n    }\n    /**\n     * Emits the site context config basing on the current base site data.\n     *\n     * Completes after emitting the value.\n     */\n    resolveConfig() {\n      return this.baseSiteService.getAll().pipe(map(baseSites => baseSites === null || baseSites === void 0 ? void 0 : baseSites.find(site => this.isCurrentBaseSite(site))), filter(baseSite => {\n        if (!baseSite) {\n          throw new Error(`Error: Cannot get base site config! Current url (${this.currentUrl}) doesn't match any of url patterns of any base sites.`);\n        }\n        return Boolean(baseSite);\n      }), map(baseSite => this.getConfig(baseSite)), take(1));\n    }\n    getConfig(source) {\n      var _a, _b, _c, _d;\n      const result = {\n        context: {\n          urlParameters: this.getUrlParams(source.urlEncodingAttributes),\n          [BASE_SITE_CONTEXT_ID]: [source.uid],\n          [LANGUAGE_CONTEXT_ID]: this.getIsoCodes((_a = source.baseStore) === null || _a === void 0 ? void 0 : _a.languages, source.defaultLanguage || ((_b = source.baseStore) === null || _b === void 0 ? void 0 : _b.defaultLanguage)),\n          [CURRENCY_CONTEXT_ID]: this.getIsoCodes((_c = source.baseStore) === null || _c === void 0 ? void 0 : _c.currencies, (_d = source.baseStore) === null || _d === void 0 ? void 0 : _d.defaultCurrency),\n          [THEME_CONTEXT_ID]: [source.theme]\n        }\n      };\n      return result;\n    }\n    isCurrentBaseSite(site) {\n      const index = (site.urlPatterns || []).findIndex(javaRegexp => {\n        const jsRegexp = this.javaRegExpConverter.toJsRegExp(javaRegexp);\n        if (jsRegexp) {\n          const result = jsRegexp.test(this.currentUrl);\n          return result;\n        }\n      });\n      return index !== -1;\n    }\n    /**\n     * Returns an array of url encoded site context parameters.\n     *\n     * It maps the string \"storefront\" (used in OCC) to the \"baseSite\" (used in Spartacus)\n     */\n    getUrlParams(params) {\n      const STOREFRONT_PARAM = 'storefront';\n      return (params || []).map(param => param === STOREFRONT_PARAM ? BASE_SITE_CONTEXT_ID : param);\n    }\n    /**\n     * Returns iso codes in a array, where the first element is the default iso code.\n     */\n    getIsoCodes(elements, defaultElement) {\n      if (elements && defaultElement) {\n        const result = this.moveToFirst(elements, el => el.isocode === defaultElement.isocode).map(el => el.isocode);\n        return result;\n      }\n    }\n    /**\n     * Moves to the start of the array the first element that satisfies the given predicate.\n     *\n     * @param array array to modify\n     * @param predicate function called on elements\n     */\n    moveToFirst(array, predicate) {\n      array = [...array];\n      const index = array.findIndex(predicate);\n      if (index !== -1) {\n        const [el] = array.splice(index, 1);\n        array.unshift(el);\n      }\n      return array;\n    }\n  }\n  SiteContextConfigInitializer.ɵfac = function SiteContextConfigInitializer_Factory(t) {\n    return new (t || SiteContextConfigInitializer)(i0.ɵɵinject(BaseSiteService), i0.ɵɵinject(JavaRegExpConverter), i0.ɵɵinject(WindowRef));\n  };\n  SiteContextConfigInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextConfigInitializer,\n    factory: SiteContextConfigInitializer.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteContextConfigInitializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass SiteAdapter {}\nlet SiteConnector = /*#__PURE__*/(() => {\n  class SiteConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getLanguages() {\n      return this.adapter.loadLanguages();\n    }\n    getCurrencies() {\n      return this.adapter.loadCurrencies();\n    }\n    getCountries(type) {\n      return this.adapter.loadCountries(type);\n    }\n    getRegions(countryIsoCode) {\n      return this.adapter.loadRegions(countryIsoCode);\n    }\n    getBaseSite(siteUid) {\n      return this.adapter.loadBaseSite(siteUid);\n    }\n    getBaseSites() {\n      return this.adapter.loadBaseSites();\n    }\n  }\n  SiteConnector.ɵfac = function SiteConnector_Factory(t) {\n    return new (t || SiteConnector)(i0.ɵɵinject(SiteAdapter));\n  };\n  SiteConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteConnector,\n    factory: SiteConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst LANGUAGE_NORMALIZER = new InjectionToken('LanguageNormalizer');\nconst CURRENCY_NORMALIZER = new InjectionToken('CurrencyNormalizer');\nconst COUNTRY_NORMALIZER = new InjectionToken('CountryNormalizer');\nconst REGION_NORMALIZER = new InjectionToken('RegionNormalizer');\nconst BASE_SITE_NORMALIZER = new InjectionToken('BaseSiteNormalizer');\n\n/**\n * Indicates that the language has changed.\n */\nlet LanguageSetEvent = /*#__PURE__*/(() => {\n  class LanguageSetEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  LanguageSetEvent.type = 'LanguageSetEvent';\n  /**\n   * Indicates that the Currency has changed.\n   */\n  return LanguageSetEvent;\n})();\nlet CurrencySetEvent = /*#__PURE__*/(() => {\n  class CurrencySetEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  CurrencySetEvent.type = 'CurrencySetEvent';\n\n  /**\n   * Builds and registers the site context events\n   */\n  return CurrencySetEvent;\n})();\nlet SiteContextEventBuilder = /*#__PURE__*/(() => {\n  class SiteContextEventBuilder {\n    constructor(actionsSubject, eventService) {\n      this.actionsSubject = actionsSubject;\n      this.eventService = eventService;\n      this.register();\n    }\n    /**\n     * Registers the site context events\n     */\n    register() {\n      this.registerSetLanguage();\n      this.registerSetCurrency();\n    }\n    /**\n     * Register the language set action\n     */\n    registerSetLanguage() {\n      const languageEvent$ = this.actionsSubject.pipe(ofType(SET_ACTIVE_LANGUAGE), map(languageAction => createFrom(LanguageSetEvent, {\n        activeLanguage: languageAction.payload\n      })));\n      this.eventService.register(LanguageSetEvent, languageEvent$);\n    }\n    /**\n     * Register the currency set action\n     */\n    registerSetCurrency() {\n      const currencyEvent$ = this.actionsSubject.pipe(ofType(SET_ACTIVE_CURRENCY), map(currencyAction => createFrom(CurrencySetEvent, {\n        activeCurrency: currencyAction.payload\n      })));\n      this.eventService.register(CurrencySetEvent, currencyEvent$);\n    }\n  }\n  SiteContextEventBuilder.ɵfac = function SiteContextEventBuilder_Factory(t) {\n    return new (t || SiteContextEventBuilder)(i0.ɵɵinject(i1$2.ActionsSubject), i0.ɵɵinject(EventService));\n  };\n  SiteContextEventBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextEventBuilder,\n    factory: SiteContextEventBuilder.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteContextEventBuilder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SiteContextEventModule = /*#__PURE__*/(() => {\n  class SiteContextEventModule {\n    constructor(_siteContextEventBuilder) {}\n  }\n  SiteContextEventModule.ɵfac = function SiteContextEventModule_Factory(t) {\n    return new (t || SiteContextEventModule)(i0.ɵɵinject(SiteContextEventBuilder));\n  };\n  SiteContextEventModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SiteContextEventModule\n  });\n  SiteContextEventModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return SiteContextEventModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Facade that provides easy access to currency state, actions and selectors.\n */\nlet CurrencyService = /*#__PURE__*/(() => {\n  class CurrencyService {\n    constructor(store, config) {\n      this.store = store;\n      this.config = config;\n    }\n    /**\n     * Represents all the currencies supported by the current store.\n     */\n    getAll() {\n      return this.store.pipe(select(getAllCurrencies), tap(currencies => {\n        if (!currencies) {\n          this.store.dispatch(new LoadCurrencies());\n        }\n      }), filter(currencies => Boolean(currencies)));\n    }\n    /**\n     * Represents the isocode of the active currency.\n     */\n    getActive() {\n      return this.store.pipe(select(getActiveCurrency), filter(active => Boolean(active)));\n    }\n    /**\n     * Sets the active language.\n     */\n    setActive(isocode) {\n      this.store.pipe(select(getActiveCurrency), take(1)).subscribe(activeCurrency => {\n        if (activeCurrency !== isocode && this.isValid(isocode)) {\n          this.store.dispatch(new SetActiveCurrency(isocode));\n        }\n      });\n    }\n    /**\n     * Tells whether the value of the active currency has been already initialized\n     */\n    isInitialized() {\n      let valueInitialized = false;\n      this.getActive().subscribe(() => valueInitialized = true).unsubscribe();\n      return valueInitialized;\n    }\n    /**\n     * Tells whether the given iso code is allowed.\n     *\n     * The list of allowed iso codes can be configured in the `context` config of Spartacus.\n     */\n    isValid(value) {\n      return !!value && getContextParameterValues(this.config, CURRENCY_CONTEXT_ID).includes(value);\n    }\n  }\n  CurrencyService.ɵfac = function CurrencyService_Factory(t) {\n    return new (t || CurrencyService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(SiteContextConfig));\n  };\n  CurrencyService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CurrencyService,\n    factory: CurrencyService.ɵfac\n  });\n  return CurrencyService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Facade that provides easy access to language state, actions and selectors.\n */\nlet LanguageService = /*#__PURE__*/(() => {\n  class LanguageService {\n    constructor(store, config) {\n      this.store = store;\n      this.config = config;\n    }\n    /**\n     * Represents all the languages supported by the current store.\n     */\n    getAll() {\n      return this.store.pipe(select(getAllLanguages), tap(languages => {\n        if (!languages) {\n          this.store.dispatch(new LoadLanguages());\n        }\n      }), filter(languages => Boolean(languages)));\n    }\n    /**\n     * Represents the isocode of the active language.\n     */\n    getActive() {\n      return this.store.pipe(select(getActiveLanguage), filter(active => Boolean(active)));\n    }\n    /**\n     * Sets the active language.\n     */\n    setActive(isocode) {\n      this.store.pipe(select(getActiveLanguage), take(1)).subscribe(activeLanguage => {\n        if (activeLanguage !== isocode && this.isValid(isocode)) {\n          this.store.dispatch(new SetActiveLanguage(isocode));\n        }\n      });\n    }\n    /**\n     * Tells whether the value of the active language has been already initialized\n     */\n    isInitialized() {\n      let valueInitialized = false;\n      this.getActive().subscribe(() => valueInitialized = true).unsubscribe();\n      return valueInitialized;\n    }\n    /**\n     * Tells whether the given iso code is allowed.\n     *\n     * The list of allowed iso codes can be configured in the `context` config of Spartacus.\n     */\n    isValid(value) {\n      return !!value && getContextParameterValues(this.config, LANGUAGE_CONTEXT_ID).includes(value);\n    }\n  }\n  LanguageService.ɵfac = function LanguageService_Factory(t) {\n    return new (t || LanguageService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(SiteContextConfig));\n  };\n  LanguageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LanguageService,\n    factory: LanguageService.ɵfac\n  });\n  return LanguageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass ContextServiceMap {}\nfunction serviceMapFactory() {\n  return {\n    [LANGUAGE_CONTEXT_ID]: LanguageService,\n    [CURRENCY_CONTEXT_ID]: CurrencyService,\n    [BASE_SITE_CONTEXT_ID]: BaseSiteService\n  };\n}\nconst contextServiceMapProvider = {\n  provide: ContextServiceMap,\n  useFactory: serviceMapFactory\n};\nlet BaseSiteInitializer = /*#__PURE__*/(() => {\n  class BaseSiteInitializer {\n    constructor(baseSiteService, configInit) {\n      this.baseSiteService = baseSiteService;\n      this.configInit = configInit;\n    }\n    /**\n     * Initializes the value of the base site\n     */\n    initialize() {\n      this.subscription = this.configInit.getStable('context').pipe(\n      // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler\n      switchMap(() => this.setFallbackValue())).subscribe();\n    }\n    /**\n     * On subscription to the returned observable:\n     *\n     * Sets the default value taken from config, unless the active base site has been already initialized.\n     */\n    setFallbackValue() {\n      return this.configInit.getStable('context').pipe(tap(config => this.setDefaultFromConfig(config)));\n    }\n    /**\n     * Sets the active base site value based on the default value from the config,\n     * unless the active base site has been already initialized.\n     */\n    setDefaultFromConfig(config) {\n      if (!this.baseSiteService.isInitialized()) {\n        this.baseSiteService.setActive(getContextParameterDefault(config, BASE_SITE_CONTEXT_ID));\n      }\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n  }\n  BaseSiteInitializer.ɵfac = function BaseSiteInitializer_Factory(t) {\n    return new (t || BaseSiteInitializer)(i0.ɵɵinject(BaseSiteService), i0.ɵɵinject(ConfigInitializerService));\n  };\n  BaseSiteInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BaseSiteInitializer,\n    factory: BaseSiteInitializer.ɵfac,\n    providedIn: 'root'\n  });\n  return BaseSiteInitializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CurrencyStatePersistenceService = /*#__PURE__*/(() => {\n  class CurrencyStatePersistenceService {\n    constructor(statePersistenceService, currencyService, config) {\n      this.statePersistenceService = statePersistenceService;\n      this.currencyService = currencyService;\n      this.config = config;\n      this.initialized$ = new ReplaySubject(1);\n    }\n    initSync() {\n      this.statePersistenceService.syncWithStorage({\n        key: CURRENCY_CONTEXT_ID,\n        state$: this.currencyService.getActive(),\n        onRead: state => this.onRead(state)\n      });\n      return this.initialized$;\n    }\n    onRead(valueFromStorage) {\n      if (!this.currencyService.isInitialized() && valueFromStorage) {\n        this.currencyService.setActive(valueFromStorage);\n      }\n      if (!this.initialized$.closed) {\n        this.initialized$.next();\n        this.initialized$.complete();\n      }\n    }\n  }\n  CurrencyStatePersistenceService.ɵfac = function CurrencyStatePersistenceService_Factory(t) {\n    return new (t || CurrencyStatePersistenceService)(i0.ɵɵinject(StatePersistenceService), i0.ɵɵinject(CurrencyService), i0.ɵɵinject(SiteContextConfig));\n  };\n  CurrencyStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CurrencyStatePersistenceService,\n    factory: CurrencyStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return CurrencyStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction configInitializerFactory(configInitializer, initializers) {\n  const isReady = () => configInitializer.initialize(initializers);\n  return isReady;\n}\nfunction locationInitializedFactory(configInitializer) {\n  return configInitializer.getStable().toPromise();\n}\nlet ConfigInitializerModule = /*#__PURE__*/(() => {\n  class ConfigInitializerModule {\n    static forRoot() {\n      return {\n        ngModule: ConfigInitializerModule,\n        providers: [{\n          provide: CONFIG_INITIALIZER_FORROOT_GUARD,\n          useValue: true\n        }, {\n          provide: APP_INITIALIZER,\n          multi: true,\n          useFactory: configInitializerFactory,\n          deps: [ConfigInitializerService, [new Optional(), CONFIG_INITIALIZER]]\n        }, {\n          // Hold on the initial navigation until the Spartacus configuration is stable\n          provide: LOCATION_INITIALIZED,\n          useFactory: locationInitializedFactory,\n          deps: [ConfigInitializerService]\n        }]\n      };\n    }\n  }\n  ConfigInitializerModule.ɵfac = function ConfigInitializerModule_Factory(t) {\n    return new (t || ConfigInitializerModule)();\n  };\n  ConfigInitializerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ConfigInitializerModule\n  });\n  ConfigInitializerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ConfigInitializerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction configValidatorFactory(configInitializer, validators) {\n  const validate = () => {\n    if (isDevMode()) {\n      configInitializer.getStable().subscribe(config => validateConfig(config, validators || []));\n    }\n  };\n  return validate;\n}\n/**\n * Should stay private in 1.x\n * as forRoot() is used internally by ConfigInitializerModule\n *\n * issue: #5279\n */\nlet ConfigValidatorModule = /*#__PURE__*/(() => {\n  class ConfigValidatorModule {\n    static forRoot() {\n      return {\n        ngModule: ConfigValidatorModule,\n        providers: [{\n          provide: APP_INITIALIZER,\n          multi: true,\n          useFactory: configValidatorFactory,\n          deps: [ConfigInitializerService, [new Optional(), ConfigValidatorToken]]\n        }]\n      };\n    }\n  }\n  ConfigValidatorModule.ɵfac = function ConfigValidatorModule_Factory(t) {\n    return new (t || ConfigValidatorModule)();\n  };\n  ConfigValidatorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ConfigValidatorModule\n  });\n  ConfigValidatorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ConfigValidatorModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isFeatureConfig(config) {\n  return typeof config === 'object' && !!config.features;\n}\nfunction isInLevel(level, version) {\n  if (level === '*') {\n    return true;\n  }\n  const levelParts = level.split('.');\n  const versionParts = version.split('.');\n  for (let i = 0; i < versionParts.length; i++) {\n    const versionNumberPart = Number(versionParts[i]);\n    const levelNumberPart = Number(levelParts[i]) || 0;\n    if (versionNumberPart !== levelNumberPart) {\n      return levelNumberPart > versionNumberPart;\n    }\n  }\n  return true;\n}\nfunction isFeatureLevel(config, level) {\n  if (isFeatureConfig(config) && config.features.level) {\n    return level.startsWith('!') ? !isInLevel(config.features.level, level.substr(1, level.length)) : isInLevel(config.features.level, level);\n  }\n  return false;\n}\nfunction isFeatureEnabled(config, feature) {\n  if (isFeatureConfig(config)) {\n    const featureConfig = feature[0] === '!' ? config.features[feature.substr(1, feature.length)] : config.features[feature];\n    const result = typeof featureConfig === 'string' ? isFeatureLevel(config, featureConfig) : featureConfig;\n    return feature.startsWith('!') ? !result : !!result;\n  }\n  return false;\n}\nlet FeaturesConfig = /*#__PURE__*/(() => {\n  class FeaturesConfig {}\n  FeaturesConfig.ɵfac = function FeaturesConfig_Factory(t) {\n    return new (t || FeaturesConfig)();\n  };\n  FeaturesConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FeaturesConfig,\n    factory: function FeaturesConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || FeaturesConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return FeaturesConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FeatureConfigService = /*#__PURE__*/(() => {\n  class FeatureConfigService {\n    constructor(config) {\n      this.config = config;\n    }\n    isLevel(version) {\n      return isFeatureLevel(this.config, version);\n    }\n    isEnabled(feature) {\n      return isFeatureEnabled(this.config, feature);\n    }\n  }\n  FeatureConfigService.ɵfac = function FeatureConfigService_Factory(t) {\n    return new (t || FeatureConfigService)(i0.ɵɵinject(FeaturesConfig));\n  };\n  FeatureConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FeatureConfigService,\n    factory: FeatureConfigService.ɵfac,\n    providedIn: 'root'\n  });\n  return FeatureConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FeatureLevelDirective = /*#__PURE__*/(() => {\n  class FeatureLevelDirective {\n    constructor(templateRef, viewContainer, featureConfig) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.featureConfig = featureConfig;\n      this.hasView = false;\n    }\n    set cxFeatureLevel(level) {\n      if (this.featureConfig.isLevel(level.toString()) && !this.hasView) {\n        this.viewContainer.createEmbeddedView(this.templateRef);\n        this.hasView = true;\n      } else if (!this.featureConfig.isLevel(level.toString()) && this.hasView) {\n        this.viewContainer.clear();\n        this.hasView = false;\n      }\n    }\n  }\n  FeatureLevelDirective.ɵfac = function FeatureLevelDirective_Factory(t) {\n    return new (t || FeatureLevelDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(FeatureConfigService));\n  };\n  FeatureLevelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FeatureLevelDirective,\n    selectors: [[\"\", \"cxFeatureLevel\", \"\"]],\n    inputs: {\n      cxFeatureLevel: \"cxFeatureLevel\"\n    }\n  });\n  return FeatureLevelDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FeatureDirective = /*#__PURE__*/(() => {\n  class FeatureDirective {\n    constructor(templateRef, viewContainer, featureConfig) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.featureConfig = featureConfig;\n      this.hasView = false;\n    }\n    set cxFeature(feature) {\n      if (this.featureConfig.isEnabled(feature) && !this.hasView) {\n        this.viewContainer.createEmbeddedView(this.templateRef);\n        this.hasView = true;\n      } else if (!this.featureConfig.isEnabled(feature) && this.hasView) {\n        this.viewContainer.clear();\n        this.hasView = false;\n      }\n    }\n  }\n  FeatureDirective.ɵfac = function FeatureDirective_Factory(t) {\n    return new (t || FeatureDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(FeatureConfigService));\n  };\n  FeatureDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FeatureDirective,\n    selectors: [[\"\", \"cxFeature\", \"\"]],\n    inputs: {\n      cxFeature: \"cxFeature\"\n    }\n  });\n  return FeatureDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FeaturesConfigModule = /*#__PURE__*/(() => {\n  class FeaturesConfigModule {\n    static forRoot(defaultLevel = '3.0') {\n      return {\n        ngModule: FeaturesConfigModule,\n        providers: [provideDefaultConfig({\n          features: {\n            level: defaultLevel || '*'\n          }\n        })]\n      };\n    }\n  }\n  FeaturesConfigModule.ɵfac = function FeaturesConfigModule_Factory(t) {\n    return new (t || FeaturesConfigModule)();\n  };\n  FeaturesConfigModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FeaturesConfigModule\n  });\n  FeaturesConfigModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return FeaturesConfigModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NOT_FOUND_SYMBOL$1 = {};\n/**\n * CombinedInjector is able to combine more than one injector together.\n *\n * Can be used to instantiate lazy loaded modules with dependency modules,\n * so lazy loaded module can use instances provided in all dependency modules.\n *\n * Injector tries to resolve token in all Injector, taking into account the order\n * in which they were provided in complementaryInjectors and fallbacks to the\n * mainInjector.\n */\nclass CombinedInjector {\n  /**\n   * @param mainInjector Component hierarchical injector\n   * @param complementaryInjectors Additional injector that will be taken into an account when resolving dependencies\n   */\n  constructor(mainInjector, complementaryInjectors) {\n    this.mainInjector = mainInjector;\n    this.complementaryInjectors = complementaryInjectors;\n  }\n  get(token, notFoundValue, flags) {\n    // eslint-disable-next-line no-bitwise\n    if (flags & InjectFlags.Self) {\n      if (notFoundValue !== undefined) {\n        return notFoundValue;\n      }\n      throw new Error(\"CombinedInjector should be used as a parent injector / doesn't support self dependencies\");\n    }\n    for (const injector of this.complementaryInjectors) {\n      // First we are resolving providers provided at Self level\n      // in all complementary injectors...\n      const service = injector.get(token, NOT_FOUND_SYMBOL$1, InjectFlags.Self);\n      if (service !== NOT_FOUND_SYMBOL$1) {\n        return service;\n      }\n    }\n    for (const injector of this.complementaryInjectors) {\n      // next we try to resolve tokens from all levels\n      const service = injector.get(token, NOT_FOUND_SYMBOL$1);\n      if (service !== NOT_FOUND_SYMBOL$1) {\n        return service;\n      }\n    }\n    // ...and then fallback to main injector\n    return this.mainInjector.get(token, notFoundValue);\n  }\n}\n\n/**\n * Will be thrown in case lazy loaded modules are loaded and instantiated.\n *\n * This event is thrown for cms driven lazy loaded feature modules amd it's\n * dependencies\n */\nlet ModuleInitializedEvent = /*#__PURE__*/(() => {\n  class ModuleInitializedEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  ModuleInitializedEvent.type = 'ModuleInitializedEvent';\n\n  /**\n   * The MODULE_INITIALIZER is used as a multi provider that returns\n   * a function that should be executed when the module is lazy loaded.\n   * It is, in a way, an APP_INITIALIZER for lazy loaded modules.\n   *\n   * If the module is eagerly loaded, the MODULE_INITIALIZER functions\n   * run when the app is initialized.  Therfore, if the module in which it is\n   * defined is used in a eager loading configuration, MODULE_INITIALIZER\n   * will fall back to work like APP_INITIALIZER.\n   */\n  return ModuleInitializedEvent;\n})();\nconst MODULE_INITIALIZER = new InjectionToken('MODULE_INITIALIZER');\n\n/**\n * Utility service for managing dynamic imports of Angular services\n */\nlet LazyModulesService = /*#__PURE__*/(() => {\n  class LazyModulesService {\n    constructor(compiler, injector, events) {\n      this.compiler = compiler;\n      this.injector = injector;\n      this.events = events;\n      /**\n       * Expose lazy loaded module references\n       */\n      this.modules$ = this.events.get(ModuleInitializedEvent).pipe(map(event => event.moduleRef), publishReplay());\n      this.dependencyModules = new Map();\n      this.eventSubscription = this.modules$.connect();\n    }\n    /**\n     * Resolves module instance based dynamic import wrapped in an arrow function\n     *\n     * New module instance will be created with each call.\n     *\n     * @param moduleFunc\n     * @param feature\n     */\n    resolveModuleInstance(moduleFunc, feature, dependencyModuleRefs = []) {\n      let parentInjector;\n      if (!dependencyModuleRefs.length) {\n        parentInjector = this.injector;\n      } else if (dependencyModuleRefs.length === 1) {\n        parentInjector = dependencyModuleRefs[0].injector;\n      } else {\n        parentInjector = new CombinedInjector(this.injector, dependencyModuleRefs.map(moduleRef => moduleRef.injector));\n      }\n      return this.resolveModuleFactory(moduleFunc).pipe(map(([moduleFactory]) => moduleFactory.create(parentInjector)), concatMap(moduleRef => this.runModuleInitializersForModule(moduleRef)), tap(moduleRef => this.events.dispatch(createFrom(ModuleInitializedEvent, {\n        feature,\n        moduleRef\n      }))));\n    }\n    /**\n     * Returns dependency module instance and initializes it when needed.\n     *\n     * Module will be instantiated only once, at first request for a this specific module class\n     */\n    resolveDependencyModuleInstance(moduleFunc) {\n      // We grab moduleFactory symbol from module function and if there is no\n      // such a module created yet, we create it and store it in a\n      // dependencyModules map\n      return this.resolveModuleFactory(moduleFunc).pipe(map(([moduleFactory, module]) => {\n        if (!this.dependencyModules.has(module)) {\n          const moduleRef = moduleFactory.create(this.injector);\n          this.dependencyModules.set(module, moduleRef);\n        }\n        return this.dependencyModules.get(module);\n      }), concatMap(moduleRef => this.runModuleInitializersForModule(moduleRef)), tap(moduleRef => this.events.dispatch(createFrom(ModuleInitializedEvent, {\n        moduleRef\n      }))));\n    }\n    /**\n     * The purpose of this function is to run MODULE_INITIALIZER logic that can be provided\n     * by a lazy loaded module.  The module is recieved as a function parameter.\n     * This function returns an Observable to the module reference passed as an argument.\n     *\n     * @param {NgModuleRef<any>} moduleRef\n     *\n     * @returns {Observable<NgModuleRef<any>>}\n     */\n    runModuleInitializersForModule(moduleRef) {\n      const moduleInits = moduleRef.injector.get(MODULE_INITIALIZER, [], InjectFlags.Self);\n      const asyncInitPromises = this.runModuleInitializerFunctions(moduleInits);\n      if (asyncInitPromises.length) {\n        return from(Promise.all(asyncInitPromises)).pipe(catchError(error => {\n          console.error('MODULE_INITIALIZER promise was rejected while lazy loading a module.', error);\n          return throwError(error);\n        }), switchMapTo(of(moduleRef)));\n      } else {\n        return of(moduleRef);\n      }\n    }\n    /**\n     * This function accepts an array of functions and runs them all. For each function that returns a promise,\n     * the resulting promise is stored in an array of promises.  That array of promises is returned.\n     * It is not required for the functions to return a Promise.  All functions are run.  The return values\n     * that are not a Promise are simply not stored and returned.\n     *\n     * @param {(() => any)[]} initFunctions An array of functions too be run.\n     *\n     * @return {Promise<any>[]} An array of Promise returned by the functions, if any,\n     */\n    runModuleInitializerFunctions(initFunctions) {\n      const initPromises = [];\n      try {\n        if (initFunctions) {\n          for (let i = 0; i < initFunctions.length; i++) {\n            const initResult = initFunctions[i]();\n            if (this.isObjectPromise(initResult)) {\n              initPromises.push(initResult);\n            }\n          }\n        }\n        return initPromises;\n      } catch (error) {\n        console.error(`MODULE_INITIALIZER init function throwed an error. `, error);\n        throw error;\n      }\n    }\n    /**\n     * Determine if the argument is shaped like a Promise\n     */\n    isObjectPromise(obj) {\n      return !!obj && typeof obj.then === 'function';\n    }\n    /**\n     * Resolve any Angular module from an function that return module or moduleFactory\n     */\n    resolveModuleFactory(moduleFunc) {\n      return from(moduleFunc()).pipe(switchMap(module => module instanceof NgModuleFactory ? of([module, module]) : combineLatest([\n      // using compiler here is for jit compatibility, there is no overhead\n      // for aot production builds as it will be stubbed\n      from(this.compiler.compileModuleAsync(module)), of(module)])), observeOn(queueScheduler));\n    }\n    ngOnDestroy() {\n      if (this.eventSubscription) {\n        this.eventSubscription.unsubscribe();\n      }\n      // clean up all initialized dependency modules\n      this.dependencyModules.forEach(dependency => dependency.destroy());\n    }\n  }\n  LazyModulesService.ɵfac = function LazyModulesService_Factory(t) {\n    return new (t || LazyModulesService)(i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(EventService));\n  };\n  LazyModulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LazyModulesService,\n    factory: LazyModulesService.ɵfac,\n    providedIn: 'root'\n  });\n  return LazyModulesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NOT_FOUND_SYMBOL = {};\n/**\n * UnifiedInjector provides a way to get instances of tokens not only once, from the root injector,\n * but also from lazy loaded module injectors that can be initialized over time.\n */\nlet UnifiedInjector = /*#__PURE__*/(() => {\n  class UnifiedInjector {\n    constructor(rootInjector, lazyModules) {\n      this.rootInjector = rootInjector;\n      this.lazyModules = lazyModules;\n      /**\n       * Gather all the injectors, with the root injector as a first one\n       *\n       */\n      this.injectors$ = this.lazyModules.modules$.pipe(map(moduleRef => moduleRef.injector), startWith(this.rootInjector));\n    }\n    /**\n     * Gen instances for specified tokens.\n     *\n     * When notFoundValue is provided, it will consistently emit once per injector,\n     * even if injector doesn't contain instances for specified token.\n     * Otherwise, emissions will only involve cases, where new instances will be found.\n     *\n     * @param token\n     * @param notFoundValue\n     */\n    get(token, notFoundValue) {\n      return this.injectors$.pipe(map((injector, index) => injector.get(token, notFoundValue !== null && notFoundValue !== void 0 ? notFoundValue : NOT_FOUND_SYMBOL,\n      // we want to get only Self instances from all injectors except the\n      // first one, which is a root injector\n      index ? InjectFlags.Self : undefined)), filter(instance => instance !== NOT_FOUND_SYMBOL));\n    }\n    getMulti(token) {\n      return this.get(token, []).pipe(filter(instances => {\n        if (!Array.isArray(instances)) {\n          throw new Error(`Multi-providers mixed with single providers for ${token.toString()}!`);\n        }\n        return instances.length > 0;\n      }), scan((acc, services) => [...acc, ...services], []));\n    }\n  }\n  UnifiedInjector.ɵfac = function UnifiedInjector_Factory(t) {\n    return new (t || UnifiedInjector)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(LazyModulesService));\n  };\n  UnifiedInjector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UnifiedInjector,\n    factory: UnifiedInjector.ɵfac,\n    providedIn: 'root'\n  });\n  return UnifiedInjector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ConfigurationService = /*#__PURE__*/(() => {\n  class ConfigurationService {\n    constructor(rootConfig, defaultConfig, unifiedInjector, config) {\n      this.rootConfig = rootConfig;\n      this.defaultConfig = defaultConfig;\n      this.unifiedInjector = unifiedInjector;\n      this.ambientDefaultConfig = {};\n      this.ambientConfig = {};\n      this.config = config;\n      this.unifiedConfig$ = new BehaviorSubject(config);\n      // We need to use subscription to propagate changes to the config from the beginning.\n      // It will be possible to make it lazy, when we drop this compatibility feature\n      // in the future.\n      this.subscription = this.feedUnifiedConfig().subscribe();\n    }\n    feedUnifiedConfig() {\n      const configChunks$ = this.unifiedInjector.get(ConfigChunk, []);\n      const defaultConfigChunks$ = this.unifiedInjector.get(DefaultConfigChunk, []);\n      return zip(configChunks$, defaultConfigChunks$).pipe(\n      // we don't need result from the root injector\n      skip(1), tap(([configChunks, defaultConfigChunks]) => this.processConfig(configChunks, defaultConfigChunks)));\n    }\n    processConfig(configChunks, defaultConfigChunks) {\n      if (defaultConfigChunks === null || defaultConfigChunks === void 0 ? void 0 : defaultConfigChunks.length) {\n        deepMerge(this.ambientDefaultConfig, ...defaultConfigChunks);\n      }\n      if (configChunks.length) {\n        deepMerge(this.ambientConfig, ...configChunks);\n      }\n      if (configChunks.length || defaultConfigChunks.length) {\n        this.emitUnifiedConfig();\n      }\n    }\n    emitUnifiedConfig() {\n      const newConfig = deepMerge({}, this.defaultConfig, this.ambientDefaultConfig, this.ambientConfig, this.rootConfig);\n      this.unifiedConfig$.next(newConfig);\n      // compatibility mechanism, can be disabled with feature toggle\n      if (!isFeatureEnabled(this.config, 'disableConfigUpdates')) {\n        deepMerge(this.config, newConfig);\n      }\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n      this.unifiedConfig$.complete();\n    }\n  }\n  ConfigurationService.ɵfac = function ConfigurationService_Factory(t) {\n    return new (t || ConfigurationService)(i0.ɵɵinject(RootConfig), i0.ɵɵinject(DefaultConfig), i0.ɵɵinject(UnifiedInjector), i0.ɵɵinject(Config));\n  };\n  ConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigurationService,\n    factory: ConfigurationService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConfigurationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ConfigModule = /*#__PURE__*/(() => {\n  class ConfigModule {\n    // To make sure ConfigurationService will be instantiated, we inject it into\n    // module constructor\n    constructor(_configurationService) {}\n    /**\n     * Import ConfigModule and contribute config to the global configuration\n     *\n     * To provide default configuration in libraries provideDefaultConfig should be used instead.\n     *\n     * @param config Config object to merge with the global configuration\n     */\n    static withConfig(config) {\n      return {\n        ngModule: ConfigModule,\n        providers: [provideConfig(config)]\n      };\n    }\n    /**\n     * Import ConfigModule and contribute config to the global configuration using factory function\n     *\n     * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.\n     *\n     * @param configFactory Factory function that will generate configuration\n     * @param deps Optional dependencies to factory function\n     */\n    static withConfigFactory(configFactory, deps) {\n      return {\n        ngModule: ConfigModule,\n        providers: [provideConfigFactory(configFactory, deps)]\n      };\n    }\n    /**\n     * Module with providers, should be imported only once, if possible, at the root of the app.\n     *\n     * @param config\n     */\n    static forRoot(config = {}) {\n      return {\n        ngModule: ConfigModule,\n        providers: [provideConfig(config)]\n      };\n    }\n  }\n  ConfigModule.ɵfac = function ConfigModule_Factory(t) {\n    return new (t || ConfigModule)(i0.ɵɵinject(ConfigurationService));\n  };\n  ConfigModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ConfigModule\n  });\n  ConfigModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ConfigModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getCookie(cookie, name) {\n  const regExp = new RegExp('(?:^|;\\\\s*)' + name + '=([^;]*)', 'g');\n  const result = regExp.exec(cookie);\n  return result && decodeURIComponent(result[1]) || '';\n}\nconst TEST_CONFIG_COOKIE_NAME = new InjectionToken('TEST_CONFIG_COOKIE_NAME');\nfunction parseConfigJSON(config) {\n  try {\n    return JSON.parse(decodeURIComponent(config));\n  } catch (_) {\n    return {};\n  }\n}\nfunction configFromCookieFactory(cookieName, platform, document) {\n  if (isPlatformBrowser(platform) && cookieName) {\n    const config = getCookie(document.cookie, cookieName);\n    return parseConfigJSON(config);\n  }\n  return {};\n}\n/**\n * Designed/intended to provide dynamic configuration for testing scenarios ONLY (e.g. e2e tests).\n *\n * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.\n */\nlet TestConfigModule = /*#__PURE__*/(() => {\n  class TestConfigModule {\n    /**\n     * Injects JSON config from the cookie of the given name.\n     *\n     * Be aware of the cookie limitations (4096 bytes).\n     *\n     * CAUTION: DON'T USE IT IN PRODUCTION! IT HASN'T BEEN REVIEWED FOR SECURITY ISSUES.\n     */\n    static forRoot(options) {\n      return {\n        ngModule: TestConfigModule,\n        providers: [{\n          provide: TEST_CONFIG_COOKIE_NAME,\n          useValue: options && options.cookie\n        }, provideConfigFactory(configFromCookieFactory, [TEST_CONFIG_COOKIE_NAME, PLATFORM_ID, DOCUMENT])]\n      };\n    }\n  }\n  TestConfigModule.ɵfac = function TestConfigModule_Factory(t) {\n    return new (t || TestConfigModule)();\n  };\n  TestConfigModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TestConfigModule\n  });\n  TestConfigModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TestConfigModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CurrencyInitializer = /*#__PURE__*/(() => {\n  class CurrencyInitializer {\n    constructor(currencyService, currencyStatePersistenceService, configInit) {\n      this.currencyService = currencyService;\n      this.currencyStatePersistenceService = currencyStatePersistenceService;\n      this.configInit = configInit;\n    }\n    /**\n     * Initializes the value of the active currency.\n     */\n    initialize() {\n      this.subscription = this.configInit.getStable('context').pipe(\n      // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler\n      switchMap(() => this.currencyStatePersistenceService.initSync()), switchMap(() => this.setFallbackValue())).subscribe();\n    }\n    /**\n     * On subscription to the returned observable:\n     *\n     * Sets the default value taken from config, unless the active currency has been already initialized.\n     */\n    setFallbackValue() {\n      return this.configInit.getStable('context').pipe(tap(config => this.setDefaultFromConfig(config)));\n    }\n    /**\n     * Sets the active currency value based on the default value from the config,\n     * unless the active currency has been already initialized.\n     */\n    setDefaultFromConfig(config) {\n      if (!this.currencyService.isInitialized()) {\n        this.currencyService.setActive(getContextParameterDefault(config, CURRENCY_CONTEXT_ID));\n      }\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n  }\n  CurrencyInitializer.ɵfac = function CurrencyInitializer_Factory(t) {\n    return new (t || CurrencyInitializer)(i0.ɵɵinject(CurrencyService), i0.ɵɵinject(CurrencyStatePersistenceService), i0.ɵɵinject(ConfigInitializerService));\n  };\n  CurrencyInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CurrencyInitializer,\n    factory: CurrencyInitializer.ɵfac,\n    providedIn: 'root'\n  });\n  return CurrencyInitializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LanguageStatePersistenceService = /*#__PURE__*/(() => {\n  class LanguageStatePersistenceService {\n    constructor(statePersistenceService, languageService, config) {\n      this.statePersistenceService = statePersistenceService;\n      this.languageService = languageService;\n      this.config = config;\n      this.initialized$ = new ReplaySubject(1);\n    }\n    /**\n     * Initializes the synchronization of the active language with the local storage.\n     *\n     * @returns Observable that emits and completes when the value is read from the storage.\n     */\n    initSync() {\n      this.statePersistenceService.syncWithStorage({\n        key: LANGUAGE_CONTEXT_ID,\n        state$: this.languageService.getActive(),\n        onRead: state => this.onRead(state)\n      });\n      return this.initialized$;\n    }\n    onRead(valueFromStorage) {\n      if (!this.languageService.isInitialized() && valueFromStorage) {\n        this.languageService.setActive(valueFromStorage);\n      }\n      if (!this.initialized$.closed) {\n        this.initialized$.next();\n        this.initialized$.complete();\n      }\n    }\n  }\n  LanguageStatePersistenceService.ɵfac = function LanguageStatePersistenceService_Factory(t) {\n    return new (t || LanguageStatePersistenceService)(i0.ɵɵinject(StatePersistenceService), i0.ɵɵinject(LanguageService), i0.ɵɵinject(SiteContextConfig));\n  };\n  LanguageStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LanguageStatePersistenceService,\n    factory: LanguageStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return LanguageStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LanguageInitializer = /*#__PURE__*/(() => {\n  class LanguageInitializer {\n    constructor(languageService, languageStatePersistenceService, configInit) {\n      this.languageService = languageService;\n      this.languageStatePersistenceService = languageStatePersistenceService;\n      this.configInit = configInit;\n    }\n    /**\n     * Initializes the value of the active language.\n     */\n    initialize() {\n      this.subscription = this.configInit.getStable('context').pipe(\n      // TODO(#12351): <--- plug here explicitly SiteContextRoutesHandler\n      switchMap(() => this.languageStatePersistenceService.initSync()), switchMap(() => this.setFallbackValue())).subscribe();\n    }\n    /**\n     * On subscription to the returned observable:\n     *\n     * Sets the default value taken from config, unless the active language has been already initialized.\n     */\n    setFallbackValue() {\n      return this.configInit.getStable('context').pipe(tap(config => this.setDefaultFromConfig(config)));\n    }\n    /**\n     * Sets the active language value based on the default value from the config,\n     * unless the active language has been already initialized.\n     */\n    setDefaultFromConfig(config) {\n      if (!this.languageService.isInitialized()) {\n        this.languageService.setActive(getContextParameterDefault(config, LANGUAGE_CONTEXT_ID));\n      }\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n  }\n  LanguageInitializer.ɵfac = function LanguageInitializer_Factory(t) {\n    return new (t || LanguageInitializer)(i0.ɵɵinject(LanguageService), i0.ɵɵinject(LanguageStatePersistenceService), i0.ɵɵinject(ConfigInitializerService));\n  };\n  LanguageInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LanguageInitializer,\n    factory: LanguageInitializer.ɵfac,\n    providedIn: 'root'\n  });\n  return LanguageInitializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SiteContextParamsService = /*#__PURE__*/(() => {\n  class SiteContextParamsService {\n    constructor(config, injector, serviceMap) {\n      this.config = config;\n      this.injector = injector;\n      this.serviceMap = serviceMap;\n    }\n    getContextParameters() {\n      if (this.config.context) {\n        return Object.keys(this.config.context).filter(param => param !== 'urlParameters');\n      }\n      return [];\n    }\n    getUrlEncodingParameters() {\n      return this.config.context && this.config.context.urlParameters || [];\n    }\n    getParamValues(param) {\n      return getContextParameterValues(this.config, param);\n    }\n    getParamDefaultValue(param) {\n      return getContextParameterDefault(this.config, param);\n    }\n    getSiteContextService(param) {\n      if (this.serviceMap[param]) {\n        try {\n          return this.injector.get(this.serviceMap[param]);\n        } catch (_a) {\n          if (isDevMode()) {\n            console.warn(`Couldn't find site context service for '${param}'.`);\n          }\n          return undefined;\n        }\n      }\n    }\n    getValue(param) {\n      let value;\n      const service = this.getSiteContextService(param);\n      if (service) {\n        service.getActive().subscribe(val => value = val).unsubscribe();\n      }\n      return value !== undefined ? value : this.getParamDefaultValue(param);\n    }\n    setValue(param, value) {\n      const service = this.getSiteContextService(param);\n      if (service) {\n        service.setActive(value);\n      }\n    }\n    /**\n     * Get active values for all provided context parameters\n     *\n     * @param params Context parameters\n     *\n     * @returns Observable emitting array of all passed active context values\n     */\n    getValues(params) {\n      if (params.length === 0) {\n        return of([]);\n      }\n      return combineLatest(params.map(param => {\n        const service = this.getSiteContextService(param);\n        if (service) {\n          return service.getActive().pipe(distinctUntilChanged());\n        }\n        return of('');\n      })).pipe(filter(value => value.every(param => !!param)));\n    }\n  }\n  SiteContextParamsService.ɵfac = function SiteContextParamsService_Factory(t) {\n    return new (t || SiteContextParamsService)(i0.ɵɵinject(SiteContextConfig), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(ContextServiceMap));\n  };\n  SiteContextParamsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextParamsService,\n    factory: SiteContextParamsService.ɵfac\n  });\n  return SiteContextParamsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Angular URL Serializer aware of Spartacus site context parameters\n * encoded in the URL.\n */\nlet SiteContextUrlSerializer = /*#__PURE__*/(() => {\n  class SiteContextUrlSerializer extends DefaultUrlSerializer {\n    constructor(siteContextParams) {\n      super();\n      this.siteContextParams = siteContextParams;\n      /**\n       * Splits the URL into 2 parts: path and the query/fragment part\n       */\n      this.URL_SPLIT = /(^[^#?]*)(.*)/;\n    }\n    /**\n     * Names of site context parameters encoded in the URL\n     */\n    get urlEncodingParameters() {\n      return this.siteContextParams.getUrlEncodingParameters();\n    }\n    /**\n     * Tells whether any site context parameters should be encoded in the URL\n     */\n    get hasContextInRoutes() {\n      return this.urlEncodingParameters.length > 0;\n    }\n    /**\n     * @override Recognizes the site context parameters encoded in the prefix segments\n     * of the given URL.\n     *\n     * It returns the UrlTree for the given URL shortened by the recognized params, but saves\n     * the params' values in the custom property of UrlTree: `siteContext`.\n     */\n    parse(url) {\n      if (this.hasContextInRoutes) {\n        const urlWithParams = this.urlExtractContextParameters(url);\n        const parsed = super.parse(urlWithParams.url);\n        this.urlTreeIncludeContextParameters(parsed, urlWithParams.params);\n        return parsed;\n      } else {\n        return super.parse(url);\n      }\n    }\n    /**\n     * Recognizes the site context parameters encoded in the prefix segments of the given URL.\n     *\n     * It returns the recognized site context params as well as the\n     * URL shortened by the recognized params.\n     */\n    urlExtractContextParameters(url) {\n      const [, urlPart, queryPart] = url.match(this.URL_SPLIT);\n      const segments = urlPart.split('/');\n      if (segments[0] === '') {\n        segments.shift();\n      }\n      const params = {};\n      let paramId = 0;\n      let segmentId = 0;\n      while (paramId < this.urlEncodingParameters.length && segmentId < segments.length) {\n        const paramName = this.urlEncodingParameters[paramId];\n        const paramValues = this.siteContextParams.getParamValues(paramName);\n        if (paramValues.includes(segments[segmentId])) {\n          params[paramName] = segments[segmentId];\n          segmentId++;\n        }\n        paramId++;\n      }\n      url = segments.slice(segmentId).join('/') + queryPart;\n      return {\n        url,\n        params\n      };\n    }\n    /**\n     * Saves the given site context parameters in the custom property\n     * of the given UrlTree: `siteContext`.\n     */\n    urlTreeIncludeContextParameters(urlTree, params) {\n      urlTree.siteContext = params;\n    }\n    /**\n     * @override Serializes the given UrlTree to a string and prepends\n     *  to it the current values of the site context parameters.\n     */\n    serialize(tree) {\n      const params = this.urlTreeExtractContextParameters(tree);\n      const url = super.serialize(tree);\n      const serialized = this.urlIncludeContextParameters(url, params);\n      return serialized;\n    }\n    /**\n     * Returns the site context parameters stored in the custom property\n     * of the UrlTree: `siteContext`.\n     */\n    urlTreeExtractContextParameters(urlTree) {\n      return urlTree.siteContext ? urlTree.siteContext : {};\n    }\n    /**\n     * Prepends the current values of the site context parameters to the given URL.\n     */\n    urlIncludeContextParameters(url, params) {\n      const contextRoutePart = this.urlEncodingParameters.map(param => {\n        return params[param] ? params[param] : this.siteContextParams.getValue(param);\n      }).join('/');\n      return contextRoutePart + url;\n    }\n  }\n  SiteContextUrlSerializer.ɵfac = function SiteContextUrlSerializer_Factory(t) {\n    return new (t || SiteContextUrlSerializer)(i0.ɵɵinject(SiteContextParamsService));\n  };\n  SiteContextUrlSerializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextUrlSerializer,\n    factory: SiteContextUrlSerializer.ɵfac\n  });\n  return SiteContextUrlSerializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction baseSiteConfigValidator(config) {\n  if (getContextParameterDefault(config, BASE_SITE_CONTEXT_ID) === undefined) {\n    return 'Please configure context.parameters.baseSite before using storefront library!';\n  }\n}\nfunction defaultSiteContextConfigFactory() {\n  return {\n    context: {\n      [LANGUAGE_CONTEXT_ID]: ['en', 'de', 'ja', 'zh', 'ru', 'fr', 'tr', 'it', 'es', 'uk', 'pl', 'nl', 'hi', 'ar', 'pt', 'bn', 'pa'],\n      [CURRENCY_CONTEXT_ID]: ['USD', 'EUR', 'JPY', 'GBP', 'AUD', 'CAD', 'CHF', 'CNY', 'SEK', 'NZD', 'MXN', 'SGD', 'HKD', 'NOK', 'KRW', 'TRY', 'RUB', 'INR', 'BRL', 'ZAR']\n    }\n  };\n}\nfunction initializeCurrency(currencyInitializer) {\n  const result = () => {\n    currencyInitializer.initialize();\n  };\n  return result;\n}\nfunction initializeLanguage(languageInitializer) {\n  const result = () => {\n    languageInitializer.initialize();\n  };\n  return result;\n}\nfunction initializeBaseSite(baseSiteInitializer) {\n  const result = () => {\n    baseSiteInitializer.initialize();\n  };\n  return result;\n}\nconst contextInitializerProviders = [{\n  provide: APP_INITIALIZER,\n  useFactory: initializeLanguage,\n  deps: [LanguageInitializer],\n  multi: true\n}, {\n  provide: APP_INITIALIZER,\n  useFactory: initializeCurrency,\n  deps: [CurrencyInitializer],\n  multi: true\n}, {\n  provide: APP_INITIALIZER,\n  useFactory: initializeBaseSite,\n  deps: [BaseSiteInitializer],\n  multi: true\n}];\n\n// PRIVATE API\nlet SiteContextRoutesHandler = /*#__PURE__*/(() => {\n  class SiteContextRoutesHandler {\n    constructor(siteContextParams, serializer, injector) {\n      this.siteContextParams = siteContextParams;\n      this.serializer = serializer;\n      this.injector = injector;\n      this.subscription = new Subscription();\n      this.contextValues = {};\n      /**\n       * Tells whether there is a pending navigation at the moment, so we can avoid an infinite loop caused by the cyclic dependency:\n       * - `subscribeChanges` method triggers a navigation on update of site context state\n       * - `subscribeRouting` method updates the site context state on navigation\n       */\n      this.isNavigating = false;\n    }\n    /**\n     * Initializes the two-way synchronization between the site context state and the URL.\n     */\n    init() {\n      this.router = this.injector.get(Router);\n      this.location = this.injector.get(Location);\n      const routingParams = this.siteContextParams.getUrlEncodingParameters();\n      if (routingParams.length) {\n        this.setContextParamsFromRoute(this.location.path(true));\n        this.subscribeChanges(routingParams);\n        this.subscribeRouting();\n      }\n    }\n    /**\n     * After each change of the site context state, it modifies the current URL in place.\n     * But it happens only for the parameters configured to be persisted in the URL.\n     */\n    subscribeChanges(params) {\n      params.forEach(param => {\n        const service = this.siteContextParams.getSiteContextService(param);\n        if (service) {\n          this.subscription.add(service.getActive().subscribe(value => {\n            if (!this.isNavigating && this.contextValues[param] && this.contextValues[param] !== value) {\n              const parsed = this.router.parseUrl(this.router.url);\n              const serialized = this.router.serializeUrl(parsed);\n              this.location.replaceState(serialized);\n            }\n            this.contextValues[param] = value;\n          }));\n        }\n      });\n    }\n    /**\n     * After each Angular NavigationStart event it updates the site context state based on\n     * site context params encoded in the anticipated URL.\n     */\n    subscribeRouting() {\n      this.subscription.add(this.router.events.pipe(filter(event => event instanceof NavigationStart || event instanceof NavigationEnd || event instanceof NavigationError || event instanceof NavigationCancel)).subscribe(event => {\n        this.isNavigating = event instanceof NavigationStart;\n        if (this.isNavigating) {\n          this.setContextParamsFromRoute(event.url);\n        }\n      }));\n    }\n    /**\n     * Updates the site context state based on the context params encoded in the given URL\n     *\n     * @param url URL with encoded context params\n     */\n    setContextParamsFromRoute(url) {\n      const {\n        params\n      } = this.serializer.urlExtractContextParameters(url);\n      Object.keys(params).forEach(param => this.siteContextParams.setValue(param, params[param]));\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  SiteContextRoutesHandler.ɵfac = function SiteContextRoutesHandler_Factory(t) {\n    return new (t || SiteContextRoutesHandler)(i0.ɵɵinject(SiteContextParamsService), i0.ɵɵinject(SiteContextUrlSerializer), i0.ɵɵinject(i0.Injector));\n  };\n  SiteContextRoutesHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextRoutesHandler,\n    factory: SiteContextRoutesHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteContextRoutesHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction initializeContext(configInit, siteContextRoutesHandler) {\n  return () => {\n    return configInit.getStable('context').pipe(tap(() => {\n      // `siteContextRoutesHandler.init()` should be executed before CurrencyInitializer,\n      // LanguageInitializer and BaseSiteInitializer\n      // (now it's the case, thanks to the order of providers for APP_INITIALIZER).\n      //\n      // TODO(#12351): move it to the logic of specific context initializers\n      siteContextRoutesHandler.init();\n    })).toPromise();\n  };\n}\nconst contextServiceProviders = [BaseSiteService, LanguageService, CurrencyService, {\n  provide: APP_INITIALIZER,\n  useFactory: initializeContext,\n  deps: [ConfigInitializerService, SiteContextRoutesHandler],\n  multi: true\n}];\n\n// functions below should not be exposed in public API:\nconst siteContextParamsProviders = [SiteContextParamsService, SiteContextUrlSerializer, {\n  provide: UrlSerializer,\n  useExisting: SiteContextUrlSerializer\n}];\nlet BaseSiteEffects = /*#__PURE__*/(() => {\n  class BaseSiteEffects {\n    constructor(actions$, siteConnector) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.loadBaseSite$ = this.actions$.pipe(ofType(LOAD_BASE_SITE), exhaustMap(() => {\n        return this.siteConnector.getBaseSite().pipe(map(baseSite => new LoadBaseSiteSuccess(baseSite)), catchError(error => of(new LoadBaseSiteFail(normalizeHttpError(error)))));\n      }));\n      this.loadBaseSites$ = this.actions$.pipe(ofType(LOAD_BASE_SITES), exhaustMap(() => {\n        return this.siteConnector.getBaseSites().pipe(map(baseSites => new LoadBaseSitesSuccess(baseSites)), catchError(error => of(new LoadBaseSitesFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  BaseSiteEffects.ɵfac = function BaseSiteEffects_Factory(t) {\n    return new (t || BaseSiteEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector));\n  };\n  BaseSiteEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BaseSiteEffects,\n    factory: BaseSiteEffects.ɵfac\n  });\n  __decorate([Effect()], BaseSiteEffects.prototype, \"loadBaseSite$\", void 0);\n  __decorate([Effect()], BaseSiteEffects.prototype, \"loadBaseSites$\", void 0);\n  return BaseSiteEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CurrenciesEffects = /*#__PURE__*/(() => {\n  class CurrenciesEffects {\n    constructor(actions$, siteConnector, state) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.state = state;\n      this.loadCurrencies$ = this.actions$.pipe(ofType(LOAD_CURRENCIES), exhaustMap(() => {\n        return this.siteConnector.getCurrencies().pipe(map(currencies => new LoadCurrenciesSuccess(currencies)), catchError(error => of(new LoadCurrenciesFail(normalizeHttpError(error)))));\n      }));\n      this.activateCurrency$ = this.state.select(getActiveCurrency).pipe(bufferCount(2, 1),\n      // avoid dispatching `change` action when we're just setting the initial value:\n      filter(([previous]) => !!previous), map(([previous, current]) => new CurrencyChange({\n        previous,\n        current\n      })));\n    }\n  }\n  CurrenciesEffects.ɵfac = function CurrenciesEffects_Factory(t) {\n    return new (t || CurrenciesEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector), i0.ɵɵinject(i1$2.Store));\n  };\n  CurrenciesEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CurrenciesEffects,\n    factory: CurrenciesEffects.ɵfac\n  });\n  __decorate([Effect()], CurrenciesEffects.prototype, \"loadCurrencies$\", void 0);\n  __decorate([Effect()], CurrenciesEffects.prototype, \"activateCurrency$\", void 0);\n  return CurrenciesEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LanguagesEffects = /*#__PURE__*/(() => {\n  class LanguagesEffects {\n    constructor(actions$, siteConnector, state) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.state = state;\n      this.loadLanguages$ = this.actions$.pipe(ofType(LOAD_LANGUAGES), exhaustMap(() => {\n        return this.siteConnector.getLanguages().pipe(map(languages => new LoadLanguagesSuccess(languages)), catchError(error => of(new LoadLanguagesFail(normalizeHttpError(error)))));\n      }));\n      this.activateLanguage$ = this.state.select(getActiveLanguage).pipe(bufferCount(2, 1),\n      // avoid dispatching `change` action when we're just setting the initial value:\n      filter(([previous]) => !!previous), map(([previous, current]) => new LanguageChange({\n        previous,\n        current\n      })));\n    }\n  }\n  LanguagesEffects.ɵfac = function LanguagesEffects_Factory(t) {\n    return new (t || LanguagesEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector), i0.ɵɵinject(i1$2.Store));\n  };\n  LanguagesEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LanguagesEffects,\n    factory: LanguagesEffects.ɵfac\n  });\n  __decorate([Effect()], LanguagesEffects.prototype, \"loadLanguages$\", void 0);\n  __decorate([Effect()], LanguagesEffects.prototype, \"activateLanguage$\", void 0);\n  return LanguagesEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$4 = [LanguagesEffects, CurrenciesEffects, BaseSiteEffects];\nconst initialState$u = {\n  entities: null,\n  details: {},\n  activeSite: ''\n};\nfunction reducer$u(state = initialState$u, action) {\n  switch (action.type) {\n    case LOAD_BASE_SITE_SUCCESS:\n      {\n        return Object.assign(Object.assign({}, state), {\n          details: action.payload\n        });\n      }\n    case SET_ACTIVE_BASE_SITE:\n      {\n        // if active base site is updated,\n        // the active base site details data should also be updated\n        let details = {};\n        if (state.entities) {\n          details = state.entities[action.payload];\n        }\n        return Object.assign(Object.assign({}, state), {\n          details,\n          activeSite: action.payload\n        });\n      }\n    case LOAD_BASE_SITES_SUCCESS:\n      {\n        const sites = action.payload;\n        const entities = sites.reduce((siteEntities, site) => {\n          return Object.assign(Object.assign({}, siteEntities), {\n            [site.uid]: site\n          });\n        }, Object.assign({}, state.entities));\n        // after base sites entities are populated,\n        // the active base site details data is also populated\n        const details = entities[state.activeSite];\n        return Object.assign(Object.assign({}, state), {\n          details,\n          entities\n        });\n      }\n  }\n  return state;\n}\nconst initialState$t = {\n  entities: null,\n  activeCurrency: null\n};\nfunction reducer$t(state = initialState$t, action) {\n  switch (action.type) {\n    case LOAD_CURRENCIES_SUCCESS:\n      {\n        const currencies = action.payload;\n        const entities = currencies.reduce((currEntities, currency) => {\n          return Object.assign(Object.assign({}, currEntities), {\n            [currency.isocode]: currency\n          });\n        }, Object.assign({}, state.entities));\n        return Object.assign(Object.assign({}, state), {\n          entities\n        });\n      }\n    case SET_ACTIVE_CURRENCY:\n      {\n        const isocode = action.payload;\n        return Object.assign(Object.assign({}, state), {\n          activeCurrency: isocode\n        });\n      }\n  }\n  return state;\n}\nconst initialState$s = {\n  entities: null,\n  activeLanguage: null\n};\nfunction reducer$s(state = initialState$s, action) {\n  switch (action.type) {\n    case LOAD_LANGUAGES_SUCCESS:\n      {\n        const languages = action.payload;\n        const entities = languages.reduce((langEntities, language) => {\n          return Object.assign(Object.assign({}, langEntities), {\n            [language.isocode]: language\n          });\n        }, Object.assign({}, state.entities));\n        return Object.assign(Object.assign({}, state), {\n          entities\n        });\n      }\n    case SET_ACTIVE_LANGUAGE:\n      {\n        const isocode = action.payload;\n        return Object.assign(Object.assign({}, state), {\n          activeLanguage: isocode\n        });\n      }\n  }\n  return state;\n}\nfunction getReducers$7() {\n  return {\n    languages: reducer$s,\n    currencies: reducer$t,\n    baseSite: reducer$u\n  };\n}\nconst reducerToken$7 = new InjectionToken('SiteContextReducers');\nconst reducerProvider$7 = {\n  provide: reducerToken$7,\n  useFactory: getReducers$7\n};\nfunction siteContextStoreConfigFactory() {\n  // if we want to reuse SITE_CONTEXT_FEATURE const in config, we have to use factory instead of plain object\n  const config = {\n    state: {\n      ssrTransfer: {\n        keys: {\n          [SITE_CONTEXT_FEATURE]: StateTransferType.TRANSFER_STATE\n        }\n      }\n    }\n  };\n  return config;\n}\nlet SiteContextStoreModule = /*#__PURE__*/(() => {\n  class SiteContextStoreModule {}\n  SiteContextStoreModule.ɵfac = function SiteContextStoreModule_Factory(t) {\n    return new (t || SiteContextStoreModule)();\n  };\n  SiteContextStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SiteContextStoreModule\n  });\n  SiteContextStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfigFactory(siteContextStoreConfigFactory), reducerProvider$7],\n    imports: [[CommonModule, StoreModule.forFeature(SITE_CONTEXT_FEATURE, reducerToken$7), EffectsModule.forFeature(effects$4)]]\n  });\n  return SiteContextStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Initializes the site context config\n */\nfunction initSiteContextConfig(configInitializer, config) {\n  /**\n   * Load config for `context` from backend only when there is no static config for `context.baseSite`\n   */\n  if (!config.context || !config.context[BASE_SITE_CONTEXT_ID]) {\n    return configInitializer;\n  }\n  return null;\n}\nlet SiteContextModule = /*#__PURE__*/(() => {\n  class SiteContextModule {\n    static forRoot() {\n      return {\n        ngModule: SiteContextModule,\n        providers: [provideDefaultConfigFactory(defaultSiteContextConfigFactory), contextServiceMapProvider, ...contextServiceProviders, ...siteContextParamsProviders, provideConfigValidator(baseSiteConfigValidator), {\n          provide: CONFIG_INITIALIZER,\n          useFactory: initSiteContextConfig,\n          deps: [SiteContextConfigInitializer, SiteContextConfig],\n          multi: true\n        }, ...contextInitializerProviders]\n      };\n    }\n  }\n  SiteContextModule.ɵfac = function SiteContextModule_Factory(t) {\n    return new (t || SiteContextModule)();\n  };\n  SiteContextModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SiteContextModule\n  });\n  SiteContextModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[StateModule, SiteContextStoreModule, SiteContextEventModule]]\n  });\n  return SiteContextModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst initialState$r = false;\nfunction reducer$r(state = initialState$r, action) {\n  switch (action.type) {\n    case TOGGLE_ANONYMOUS_CONSENTS_BANNER_DISMISSED:\n      {\n        return action.dismissed;\n      }\n  }\n  return state;\n}\nconst initialState$q = false;\nfunction reducer$q(state = initialState$q, action) {\n  switch (action.type) {\n    case TOGGLE_ANONYMOUS_CONSENT_TEMPLATES_UPDATED:\n      {\n        return action.updated;\n      }\n  }\n  return state;\n}\nconst initialState$p = [];\nfunction toggleConsentStatus(consents, templateCode, status) {\n  if (!consents) {\n    return [];\n  }\n  return consents.map(consent => {\n    if (consent.templateCode === templateCode) {\n      consent = Object.assign(Object.assign({}, consent), {\n        consentState: status\n      });\n    }\n    return consent;\n  });\n}\nfunction reducer$p(state = initialState$p, action) {\n  switch (action.type) {\n    case GIVE_ANONYMOUS_CONSENT:\n      {\n        return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.GIVEN);\n      }\n    case WITHDRAW_ANONYMOUS_CONSENT:\n      {\n        return toggleConsentStatus(state, action.templateCode, ANONYMOUS_CONSENT_STATUS.WITHDRAWN);\n      }\n    case SET_ANONYMOUS_CONSENTS:\n      {\n        return action.payload;\n      }\n  }\n  return state;\n}\nfunction getReducers$6() {\n  return {\n    templates: loaderReducer(ANONYMOUS_CONSENTS),\n    consents: reducer$p,\n    ui: combineReducers({\n      bannerDismissed: reducer$r,\n      updated: reducer$q\n    })\n  };\n}\nconst reducerToken$6 = new InjectionToken('AnonymousConsentsReducers');\nconst reducerProvider$6 = {\n  provide: reducerToken$6,\n  useFactory: getReducers$6\n};\nfunction clearAnonymousConsentTemplates(reducer) {\n  return function (state, action) {\n    if (action.type === LOGOUT || action.type === LANGUAGE_CHANGE) {\n      state = Object.assign(Object.assign({}, state), {\n        templates: undefined\n      });\n    }\n    return reducer(state, action);\n  };\n}\nconst metaReducers$3 = [clearAnonymousConsentTemplates];\n\n/**\n * Responsible for saving the anonymous consents data in browser storage.\n */\nlet AnonymousConsentsStatePersistenceService = /*#__PURE__*/(() => {\n  class AnonymousConsentsStatePersistenceService {\n    constructor(statePersistenceService, store, anonymousConsentsService) {\n      this.statePersistenceService = statePersistenceService;\n      this.store = store;\n      this.anonymousConsentsService = anonymousConsentsService;\n      this.subscription = new Subscription();\n      /**\n       * Identifier used for storage key.\n       */\n      this.key = 'anonymous-consents';\n    }\n    /**\n     * Initializes the synchronization between state and browser storage.\n     */\n    initSync() {\n      this.subscription.add(this.statePersistenceService.syncWithStorage({\n        key: this.key,\n        state$: this.getAuthState(),\n        onRead: state => this.onRead(state)\n      }));\n    }\n    /**\n     * Gets and transforms state from different sources into the form that should\n     * be saved in storage.\n     */\n    getAuthState() {\n      return this.store.select(getAnonymousConsentState);\n    }\n    /**\n     * Function called on each browser storage read.\n     * Used to update state from browser -> state.\n     */\n    onRead(state) {\n      var _a;\n      const templates = state === null || state === void 0 ? void 0 : state.templates;\n      const consents = state === null || state === void 0 ? void 0 : state.consents;\n      const ui = state === null || state === void 0 ? void 0 : state.ui;\n      // templates\n      if (templates === null || templates === void 0 ? void 0 : templates.success) {\n        this.store.dispatch(new LoadAnonymousConsentTemplatesSuccess((_a = templates.value) !== null && _a !== void 0 ? _a : []));\n      }\n      // consents\n      if (consents) {\n        this.anonymousConsentsService.setConsents(consents);\n      }\n      // ui\n      if (ui) {\n        this.anonymousConsentsService.toggleBannerDismissed(ui === null || ui === void 0 ? void 0 : ui.bannerDismissed);\n        this.anonymousConsentsService.toggleTemplatesUpdated(ui === null || ui === void 0 ? void 0 : ui.updated);\n      }\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  AnonymousConsentsStatePersistenceService.ɵfac = function AnonymousConsentsStatePersistenceService_Factory(t) {\n    return new (t || AnonymousConsentsStatePersistenceService)(i0.ɵɵinject(StatePersistenceService), i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(AnonymousConsentsService));\n  };\n  AnonymousConsentsStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentsStatePersistenceService,\n    factory: AnonymousConsentsStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return AnonymousConsentsStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction anonymousConsentsStatePersistenceFactory(anonymousConsentsStatePersistenceService) {\n  const result = () => anonymousConsentsStatePersistenceService.initSync();\n  return result;\n}\nlet AnonymousConsentsStoreModule = /*#__PURE__*/(() => {\n  class AnonymousConsentsStoreModule {}\n  AnonymousConsentsStoreModule.ɵfac = function AnonymousConsentsStoreModule_Factory(t) {\n    return new (t || AnonymousConsentsStoreModule)();\n  };\n  AnonymousConsentsStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AnonymousConsentsStoreModule\n  });\n  AnonymousConsentsStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerProvider$6, {\n      provide: APP_INITIALIZER,\n      useFactory: anonymousConsentsStatePersistenceFactory,\n      deps: [AnonymousConsentsStatePersistenceService],\n      multi: true\n    }],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(ANONYMOUS_CONSENTS_STORE_FEATURE, reducerToken$6, {\n      metaReducers: metaReducers$3\n    }), EffectsModule.forFeature(effects$5)]]\n  });\n  return AnonymousConsentsStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentsModule = /*#__PURE__*/(() => {\n  class AnonymousConsentsModule {\n    static forRoot() {\n      return {\n        ngModule: AnonymousConsentsModule,\n        providers: [...interceptors, AnonymousConsentsService, provideDefaultConfig(defaultAnonymousConsentsConfig)]\n      };\n    }\n  }\n  AnonymousConsentsModule.ɵfac = function AnonymousConsentsModule_Factory(t) {\n    return new (t || AnonymousConsentsModule)();\n  };\n  AnonymousConsentsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AnonymousConsentsModule\n  });\n  AnonymousConsentsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[AnonymousConsentsStoreModule]]\n  });\n  return AnonymousConsentsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ANONYMOUS_CONSENT_NORMALIZER = new InjectionToken('AnonymousConsentNormalizer');\nconst MULTI_CART_FEATURE = 'cart';\nconst MULTI_CART_DATA = '[Multi Cart] Multi Cart Data';\n// TODO(#7241): Drop after event system implementation for cart vouchers\n/**\n * Add voucher process const\n * @deprecated since 2.0\n */\nconst ADD_VOUCHER_PROCESS_ID = 'addVoucher';\nconst CART_ADD_ENTRY = '[Cart-entry] Add Entry';\nconst CART_ADD_ENTRY_SUCCESS = '[Cart-entry] Add Entry Success';\nconst CART_ADD_ENTRY_FAIL = '[Cart-entry] Add Entry Fail';\nconst CART_REMOVE_ENTRY = '[Cart-entry] Remove Entry';\nconst CART_REMOVE_ENTRY_SUCCESS = '[Cart-entry] Remove Entry Success';\nconst CART_REMOVE_ENTRY_FAIL = '[Cart-entry] Remove Entry Fail';\nconst CART_UPDATE_ENTRY = '[Cart-entry] Update Entry';\nconst CART_UPDATE_ENTRY_SUCCESS = '[Cart-entry] Update Entry Success';\nconst CART_UPDATE_ENTRY_FAIL = '[Cart-entry] Update Entry Fail';\nclass CartAddEntry extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_ADD_ENTRY;\n  }\n}\nclass CartAddEntrySuccess extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_ADD_ENTRY_SUCCESS;\n  }\n}\nclass CartAddEntryFail extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_ADD_ENTRY_FAIL;\n  }\n}\nclass CartRemoveEntry extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_ENTRY;\n  }\n}\nclass CartRemoveEntrySuccess extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_ENTRY_SUCCESS;\n  }\n}\nclass CartRemoveEntryFail extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_ENTRY_FAIL;\n  }\n}\nclass CartUpdateEntry extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_UPDATE_ENTRY;\n  }\n}\nclass CartUpdateEntrySuccess extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_UPDATE_ENTRY_SUCCESS;\n  }\n}\nclass CartUpdateEntryFail extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_UPDATE_ENTRY_FAIL;\n  }\n}\nconst CART_ADD_VOUCHER = '[Cart-voucher] Add Cart Vouchers';\nconst CART_ADD_VOUCHER_FAIL = '[Cart-voucher] Add Cart Voucher Fail';\nconst CART_ADD_VOUCHER_SUCCESS = '[Cart-voucher] Add Cart Voucher Success';\nconst CART_RESET_ADD_VOUCHER = '[Cart-voucher] Reset Add Cart Voucher';\nconst CART_REMOVE_VOUCHER = '[Cart-voucher] Remove Cart Voucher';\nconst CART_REMOVE_VOUCHER_FAIL = '[Cart-voucher] Remove Cart Voucher Fail';\nconst CART_REMOVE_VOUCHER_SUCCESS = '[Cart-voucher] Remove Cart Voucher Success';\n// Adding cart voucher actions\nclass CartAddVoucher extends EntityLoadAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n    this.payload = payload;\n    this.type = CART_ADD_VOUCHER;\n  }\n}\nclass CartAddVoucherFail extends EntityFailAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID, payload.error);\n    this.payload = payload;\n    this.type = CART_ADD_VOUCHER_FAIL;\n  }\n}\nclass CartAddVoucherSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n    this.payload = payload;\n    this.type = CART_ADD_VOUCHER_SUCCESS;\n  }\n}\n// TODO(#7241): Remove when switching to event system for vouchers\n/**\n * Resets add voucher process\n *\n * @deprecated since 2.0\n */\nclass CartResetAddVoucher extends EntityLoaderResetAction {\n  constructor() {\n    super(PROCESS_FEATURE, ADD_VOUCHER_PROCESS_ID);\n    this.type = CART_RESET_ADD_VOUCHER;\n  }\n}\n// Deleting cart voucher\nclass CartRemoveVoucher extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_VOUCHER;\n  }\n}\nclass CartRemoveVoucherFail extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_VOUCHER_FAIL;\n  }\n}\nclass CartRemoveVoucherSuccess extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CART_REMOVE_VOUCHER_SUCCESS;\n  }\n}\nconst CREATE_CART = '[Cart] Create Cart';\nconst CREATE_CART_FAIL = '[Cart] Create Cart Fail';\nconst CREATE_CART_SUCCESS = '[Cart] Create Cart Success';\nconst LOAD_CART = '[Cart] Load Cart';\nconst LOAD_CART_FAIL = '[Cart] Load Cart Fail';\nconst LOAD_CART_SUCCESS = '[Cart] Load Cart Success';\nconst LOAD_CARTS_SUCCESS = '[Cart] Load Carts Success';\nconst ADD_EMAIL_TO_CART = '[Cart] Add Email to Cart';\nconst ADD_EMAIL_TO_CART_FAIL = '[Cart] Add Email to Cart Fail';\nconst ADD_EMAIL_TO_CART_SUCCESS = '[Cart] Add Email to Cart Success';\nconst MERGE_CART = '[Cart] Merge Cart';\nconst MERGE_CART_SUCCESS = '[Cart] Merge Cart Success';\nconst RESET_CART_DETAILS = '[Cart] Reset Cart Details';\nconst REMOVE_CART = '[Cart] Remove Cart';\nconst DELETE_CART = '[Cart] Delete Cart';\nconst DELETE_CART_SUCCESS = '[Cart] Delete Cart Success';\nconst DELETE_CART_FAIL = '[Cart] Delete Cart Fail';\nclass CreateCart extends EntityLoadAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.tempCartId);\n    this.payload = payload;\n    this.type = CREATE_CART;\n  }\n}\nclass CreateCartFail extends EntityFailAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.tempCartId);\n    this.payload = payload;\n    this.type = CREATE_CART_FAIL;\n  }\n}\nclass CreateCartSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = CREATE_CART_SUCCESS;\n  }\n}\nclass AddEmailToCart extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = ADD_EMAIL_TO_CART;\n  }\n}\nclass AddEmailToCartFail extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = ADD_EMAIL_TO_CART_FAIL;\n  }\n}\nclass AddEmailToCartSuccess extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = ADD_EMAIL_TO_CART_SUCCESS;\n  }\n}\nclass LoadCart extends EntityLoadAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = LOAD_CART;\n  }\n}\nclass LoadCartFail extends EntityFailAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId, payload.error);\n    this.payload = payload;\n    this.type = LOAD_CART_FAIL;\n  }\n}\nclass LoadCartSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = LOAD_CART_SUCCESS;\n  }\n}\nclass LoadCartsSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.map(cart => cart === null || cart === void 0 ? void 0 : cart.code));\n    this.payload = payload;\n    this.type = LOAD_CARTS_SUCCESS;\n  }\n}\nclass MergeCart {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = MERGE_CART;\n  }\n}\nclass MergeCartSuccess extends EntityRemoveAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.oldCartId);\n    this.payload = payload;\n    this.type = MERGE_CART_SUCCESS;\n  }\n}\n/**\n * On site context change we want to keep current list of entities, but we want to clear the value and flags.\n * With ProcessesLoaderResetAction we run it on every entity of this type.\n */\nclass ResetCartDetails extends ProcessesLoaderResetAction {\n  constructor() {\n    super(MULTI_CART_DATA);\n    this.type = RESET_CART_DETAILS;\n  }\n}\n/**\n * Used for cleaning cart in local state, when we get information that it no longer exists in the backend.\n * For removing particular cart in both places use DeleteCart actions.\n */\nclass RemoveCart extends EntityRemoveAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = REMOVE_CART;\n  }\n}\nclass DeleteCart {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = DELETE_CART;\n  }\n}\nclass DeleteCartSuccess extends EntityRemoveAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = DELETE_CART_SUCCESS;\n  }\n}\nclass DeleteCartFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = DELETE_CART_FAIL;\n  }\n}\nconst SET_TEMP_CART = '[Cart] Set Temp Cart';\nconst CART_PROCESSES_INCREMENT = '[Cart] Cart Processes Increment';\nconst CART_PROCESSES_DECREMENT = '[Cart] Cart Processes Decrement';\nconst SET_ACTIVE_CART_ID = '[Cart] Set Active Cart Id';\nconst CLEAR_CART_STATE = '[Cart] Clear Cart State';\n/**\n * To keep track of cart creation process we use cart with `temp-${uuid}` id.\n * After creating cart we switch to entity with `code` or `guid`.\n * We need `temp-${uuid}` cart entities for loading/error state.\n */\nclass SetTempCart extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.tempCartId, payload.cart);\n    this.payload = payload;\n    this.type = SET_TEMP_CART;\n  }\n}\n// TODO(#7241): Remove when there won't be any usage\n/**\n * Increases process counter on cart entities\n * All actions that cause computations on cart should extend EntityProcessesIncrementAction instead of dispatching this action.\n * @deprecated since 2.0\n */\nclass CartProcessesIncrement extends EntityProcessesIncrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload);\n    this.payload = payload;\n    this.type = CART_PROCESSES_INCREMENT;\n  }\n}\n// TODO(#7241): Remove when there won't be any usage\n/**\n * Decrement process counter on cart entities\n * All actions that cause computations on cart should extend EntityProcessesDecrementAction instead of dispatching this action.\n * @deprecated since 2.0\n */\nclass CartProcessesDecrement extends EntityProcessesDecrementAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload);\n    this.payload = payload;\n    this.type = CART_PROCESSES_DECREMENT;\n  }\n}\n/**\n * Only sets active cart property with id of active cart. Then services take care of loading that cart.\n */\nclass SetActiveCartId {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = SET_ACTIVE_CART_ID;\n  }\n}\n/**\n * Clear whole cart store state: all entities + reset rest of the cart state.\n */\nclass ClearCartState extends EntityRemoveAllAction {\n  constructor() {\n    super(MULTI_CART_DATA);\n    this.type = CLEAR_CART_STATE;\n  }\n}\n\n/**\n * Extract cart identifier for current user. Anonymous calls use `guid` and for logged users `code` is used.\n */\nfunction getCartIdByUserId(cart, userId) {\n  if (userId === OCC_USER_ID_ANONYMOUS) {\n    return cart.guid;\n  }\n  return cart.code;\n}\n/**\n * Check if cart is selective (save for later) based on id.\n */\nfunction isSelectiveCart(cartId = '') {\n  return cartId.startsWith('selectivecart');\n}\n/**\n * Check if the returned error is of type notFound.\n *\n * We additionally check if the cart is not a selective cart.\n * For selective cart this error can happen only when extension is disabled.\n * It should never happen, because in that case, selective cart should also be disabled in our configuration.\n * However if that happens we want to handle these errors silently.\n */\nfunction isCartNotFoundError(error) {\n  return error.reason === 'notFound' && error.subjectType === 'cart' && !isSelectiveCart(error.subject);\n}\n/**\n * Compute wishlist cart name for customer.\n */\nfunction getWishlistName(customerId) {\n  return `wishlist${customerId}`;\n}\n/**\n * What is a temporary cart?\n * - frontend only cart entity!\n * - can be identified in store by `temp-` prefix with some unique id (multiple carts can be created at the same time eg. active cart, wishlist)\n *\n * Why we need temporary carts?\n * - to have information about cart creation process (meta flags: loading, error - for showing loader, error message)\n * - to know if there is currently a cart creation process in progress (eg. so, we don't create more than one active cart at the same time)\n * - cart identifiers are created in the backend, so those are only known after cart is created\n *\n * Temporary cart life cycle\n * - create cart method invoked\n * - new `temp-${uuid}` cart is created with `loading=true` state\n * - backend returns created cart\n * - normal cart entity is saved under correct id (eg. for logged user under cart `code` key)\n * - temporary cart value is set to backend response (anyone observing this cart can read code/guid from it and switch selector to normal cart)\n * - in next tick temporary cart is removed\n */\nfunction isTempCartId(cartId) {\n  return cartId.startsWith('temp-');\n}\nconst CREATE_WISH_LIST = '[Wish List] Create Wish List';\nconst CREATE_WISH_LIST_FAIL = '[Wish List] Create Wish List Fail';\nconst CREATE_WISH_LIST_SUCCESS = '[Wish List] Create Wish List Success';\nconst LOAD_WISH_LIST = '[Wish List] Load Wish List';\nconst LOAD_WISH_LIST_SUCCESS = '[Wish List] Load Wish List Success';\nconst LOAD_WISH_LIST_FAIL = '[Wish List] Load Wish List Fail';\nconst RESET_WISH_LIST_DETAILS = '[Wish List] Reset Wish List';\nclass CreateWishList {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = CREATE_WISH_LIST;\n  }\n}\nclass CreateWishListSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, getCartIdByUserId(payload.cart, payload.userId));\n    this.payload = payload;\n    this.type = CREATE_WISH_LIST_SUCCESS;\n  }\n}\nclass CreateWishListFail extends EntityFailAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId, payload.error);\n    this.payload = payload;\n    this.type = CREATE_WISH_LIST_FAIL;\n  }\n}\nclass LoadWishList extends EntityLoadAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.tempCartId);\n    this.payload = payload;\n    this.type = LOAD_WISH_LIST;\n  }\n}\nclass LoadWishListSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId);\n    this.payload = payload;\n    this.type = LOAD_WISH_LIST_SUCCESS;\n  }\n}\nclass LoadWishListFail extends EntityFailAction {\n  constructor(payload) {\n    super(MULTI_CART_DATA, payload.cartId, payload.error);\n    this.payload = payload;\n    this.type = LOAD_WISH_LIST_FAIL;\n  }\n}\nvar cartGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CART_ADD_ENTRY: CART_ADD_ENTRY,\n  CART_ADD_ENTRY_SUCCESS: CART_ADD_ENTRY_SUCCESS,\n  CART_ADD_ENTRY_FAIL: CART_ADD_ENTRY_FAIL,\n  CART_REMOVE_ENTRY: CART_REMOVE_ENTRY,\n  CART_REMOVE_ENTRY_SUCCESS: CART_REMOVE_ENTRY_SUCCESS,\n  CART_REMOVE_ENTRY_FAIL: CART_REMOVE_ENTRY_FAIL,\n  CART_UPDATE_ENTRY: CART_UPDATE_ENTRY,\n  CART_UPDATE_ENTRY_SUCCESS: CART_UPDATE_ENTRY_SUCCESS,\n  CART_UPDATE_ENTRY_FAIL: CART_UPDATE_ENTRY_FAIL,\n  CartAddEntry: CartAddEntry,\n  CartAddEntrySuccess: CartAddEntrySuccess,\n  CartAddEntryFail: CartAddEntryFail,\n  CartRemoveEntry: CartRemoveEntry,\n  CartRemoveEntrySuccess: CartRemoveEntrySuccess,\n  CartRemoveEntryFail: CartRemoveEntryFail,\n  CartUpdateEntry: CartUpdateEntry,\n  CartUpdateEntrySuccess: CartUpdateEntrySuccess,\n  CartUpdateEntryFail: CartUpdateEntryFail,\n  CART_ADD_VOUCHER: CART_ADD_VOUCHER,\n  CART_ADD_VOUCHER_FAIL: CART_ADD_VOUCHER_FAIL,\n  CART_ADD_VOUCHER_SUCCESS: CART_ADD_VOUCHER_SUCCESS,\n  CART_RESET_ADD_VOUCHER: CART_RESET_ADD_VOUCHER,\n  CART_REMOVE_VOUCHER: CART_REMOVE_VOUCHER,\n  CART_REMOVE_VOUCHER_FAIL: CART_REMOVE_VOUCHER_FAIL,\n  CART_REMOVE_VOUCHER_SUCCESS: CART_REMOVE_VOUCHER_SUCCESS,\n  CartAddVoucher: CartAddVoucher,\n  CartAddVoucherFail: CartAddVoucherFail,\n  CartAddVoucherSuccess: CartAddVoucherSuccess,\n  CartResetAddVoucher: CartResetAddVoucher,\n  CartRemoveVoucher: CartRemoveVoucher,\n  CartRemoveVoucherFail: CartRemoveVoucherFail,\n  CartRemoveVoucherSuccess: CartRemoveVoucherSuccess,\n  CREATE_CART: CREATE_CART,\n  CREATE_CART_FAIL: CREATE_CART_FAIL,\n  CREATE_CART_SUCCESS: CREATE_CART_SUCCESS,\n  LOAD_CART: LOAD_CART,\n  LOAD_CART_FAIL: LOAD_CART_FAIL,\n  LOAD_CART_SUCCESS: LOAD_CART_SUCCESS,\n  LOAD_CARTS_SUCCESS: LOAD_CARTS_SUCCESS,\n  ADD_EMAIL_TO_CART: ADD_EMAIL_TO_CART,\n  ADD_EMAIL_TO_CART_FAIL: ADD_EMAIL_TO_CART_FAIL,\n  ADD_EMAIL_TO_CART_SUCCESS: ADD_EMAIL_TO_CART_SUCCESS,\n  MERGE_CART: MERGE_CART,\n  MERGE_CART_SUCCESS: MERGE_CART_SUCCESS,\n  RESET_CART_DETAILS: RESET_CART_DETAILS,\n  REMOVE_CART: REMOVE_CART,\n  DELETE_CART: DELETE_CART,\n  DELETE_CART_SUCCESS: DELETE_CART_SUCCESS,\n  DELETE_CART_FAIL: DELETE_CART_FAIL,\n  CreateCart: CreateCart,\n  CreateCartFail: CreateCartFail,\n  CreateCartSuccess: CreateCartSuccess,\n  AddEmailToCart: AddEmailToCart,\n  AddEmailToCartFail: AddEmailToCartFail,\n  AddEmailToCartSuccess: AddEmailToCartSuccess,\n  LoadCart: LoadCart,\n  LoadCartFail: LoadCartFail,\n  LoadCartSuccess: LoadCartSuccess,\n  LoadCartsSuccess: LoadCartsSuccess,\n  MergeCart: MergeCart,\n  MergeCartSuccess: MergeCartSuccess,\n  ResetCartDetails: ResetCartDetails,\n  RemoveCart: RemoveCart,\n  DeleteCart: DeleteCart,\n  DeleteCartSuccess: DeleteCartSuccess,\n  DeleteCartFail: DeleteCartFail,\n  SET_TEMP_CART: SET_TEMP_CART,\n  CART_PROCESSES_INCREMENT: CART_PROCESSES_INCREMENT,\n  CART_PROCESSES_DECREMENT: CART_PROCESSES_DECREMENT,\n  SET_ACTIVE_CART_ID: SET_ACTIVE_CART_ID,\n  CLEAR_CART_STATE: CLEAR_CART_STATE,\n  SetTempCart: SetTempCart,\n  CartProcessesIncrement: CartProcessesIncrement,\n  CartProcessesDecrement: CartProcessesDecrement,\n  SetActiveCartId: SetActiveCartId,\n  ClearCartState: ClearCartState,\n  CREATE_WISH_LIST: CREATE_WISH_LIST,\n  CREATE_WISH_LIST_FAIL: CREATE_WISH_LIST_FAIL,\n  CREATE_WISH_LIST_SUCCESS: CREATE_WISH_LIST_SUCCESS,\n  LOAD_WISH_LIST: LOAD_WISH_LIST,\n  LOAD_WISH_LIST_SUCCESS: LOAD_WISH_LIST_SUCCESS,\n  LOAD_WISH_LIST_FAIL: LOAD_WISH_LIST_FAIL,\n  RESET_WISH_LIST_DETAILS: RESET_WISH_LIST_DETAILS,\n  CreateWishList: CreateWishList,\n  CreateWishListSuccess: CreateWishListSuccess,\n  CreateWishListFail: CreateWishListFail,\n  LoadWishList: LoadWishList,\n  LoadWishListSuccess: LoadWishListSuccess,\n  LoadWishListFail: LoadWishListFail\n});\n\n/**\n *\n * Withdraw from the source observable when notifier emits a value\n *\n * Withdraw will result in resubscribing to the source observable\n * Operator is useful to kill ongoing emission transformation on notifier emission\n *\n * @param notifier\n */\nfunction withdrawOn(notifier) {\n  return source => notifier.pipe(startWith(undefined), switchMapTo(source));\n}\nclass CartEntryAdapter {}\nlet CartEntryConnector = /*#__PURE__*/(() => {\n  class CartEntryConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    add(userId, cartId, productCode, quantity) {\n      return this.adapter.add(userId, cartId, productCode, quantity);\n    }\n    update(userId, cartId, entryNumber, qty, pickupStore) {\n      return this.adapter.update(userId, cartId, entryNumber, qty, pickupStore);\n    }\n    remove(userId, cartId, entryNumber) {\n      return this.adapter.remove(userId, cartId, entryNumber);\n    }\n  }\n  CartEntryConnector.ɵfac = function CartEntryConnector_Factory(t) {\n    return new (t || CartEntryConnector)(i0.ɵɵinject(CartEntryAdapter));\n  };\n  CartEntryConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartEntryConnector,\n    factory: CartEntryConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CartEntryConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartEntryEffects = /*#__PURE__*/(() => {\n  class CartEntryEffects {\n    constructor(actions$, cartEntryConnector) {\n      this.actions$ = actions$;\n      this.cartEntryConnector = cartEntryConnector;\n      this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n      this.addEntry$ = this.actions$.pipe(ofType(CART_ADD_ENTRY), map(action => action.payload), concatMap(payload => {\n        return this.cartEntryConnector.add(payload.userId, payload.cartId, payload.productCode, payload.quantity).pipe(map(cartModification => new CartAddEntrySuccess(Object.assign(Object.assign({}, payload), cartModification))), catchError(error => from([new CartAddEntryFail(Object.assign(Object.assign({}, payload), {\n          error: normalizeHttpError(error)\n        })), new LoadCart({\n          cartId: payload.cartId,\n          userId: payload.userId\n        })])));\n      }), withdrawOn(this.contextChange$));\n      this.removeEntry$ = this.actions$.pipe(ofType(CART_REMOVE_ENTRY), map(action => action.payload), concatMap(payload => this.cartEntryConnector.remove(payload.userId, payload.cartId, payload.entryNumber).pipe(map(() => {\n        return new CartRemoveEntrySuccess(Object.assign({}, payload));\n      }), catchError(error => from([new CartRemoveEntryFail(Object.assign(Object.assign({}, payload), {\n        error: normalizeHttpError(error)\n      })), new LoadCart({\n        cartId: payload.cartId,\n        userId: payload.userId\n      })])))), withdrawOn(this.contextChange$));\n      this.updateEntry$ = this.actions$.pipe(ofType(CART_UPDATE_ENTRY), map(action => action.payload), concatMap(payload => this.cartEntryConnector.update(payload.userId, payload.cartId, payload.entryNumber, payload.quantity).pipe(map(() => {\n        return new CartUpdateEntrySuccess(Object.assign({}, payload));\n      }), catchError(error => from([new CartUpdateEntryFail(Object.assign(Object.assign({}, payload), {\n        error: normalizeHttpError(error)\n      })), new LoadCart({\n        cartId: payload.cartId,\n        userId: payload.userId\n      })])))), withdrawOn(this.contextChange$));\n    }\n  }\n  CartEntryEffects.ɵfac = function CartEntryEffects_Factory(t) {\n    return new (t || CartEntryEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CartEntryConnector));\n  };\n  CartEntryEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartEntryEffects,\n    factory: CartEntryEffects.ɵfac\n  });\n  __decorate([Effect()], CartEntryEffects.prototype, \"addEntry$\", void 0);\n  __decorate([Effect()], CartEntryEffects.prototype, \"removeEntry$\", void 0);\n  __decorate([Effect()], CartEntryEffects.prototype, \"updateEntry$\", void 0);\n  return CartEntryEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass CartVoucherAdapter {}\nlet CartVoucherConnector = /*#__PURE__*/(() => {\n  class CartVoucherConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    add(userId, cartId, voucherId) {\n      return this.adapter.add(userId, cartId, voucherId);\n    }\n    remove(userId, cartId, voucherId) {\n      return this.adapter.remove(userId, cartId, voucherId);\n    }\n  }\n  CartVoucherConnector.ɵfac = function CartVoucherConnector_Factory(t) {\n    return new (t || CartVoucherConnector)(i0.ɵɵinject(CartVoucherAdapter));\n  };\n  CartVoucherConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartVoucherConnector,\n    factory: CartVoucherConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CartVoucherConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartVoucherEffects = /*#__PURE__*/(() => {\n  class CartVoucherEffects {\n    constructor(actions$, cartVoucherConnector, messageService) {\n      this.actions$ = actions$;\n      this.cartVoucherConnector = cartVoucherConnector;\n      this.messageService = messageService;\n      this.addCartVoucher$ = this.actions$.pipe(ofType(CART_ADD_VOUCHER), map(action => action.payload), mergeMap(payload => {\n        return this.cartVoucherConnector.add(payload.userId, payload.cartId, payload.voucherId).pipe(map(() => {\n          this.showGlobalMessage('voucher.applyVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n          return new CartAddVoucherSuccess(Object.assign({}, payload));\n        }), catchError(error => from([new CartAddVoucherFail(Object.assign(Object.assign({}, payload), {\n          error: normalizeHttpError(error)\n        })), new CartProcessesDecrement(payload.cartId), new LoadCart({\n          userId: payload.userId,\n          cartId: payload.cartId\n        })])));\n      }));\n      this.removeCartVoucher$ = this.actions$.pipe(ofType(CART_REMOVE_VOUCHER), map(action => action.payload), mergeMap(payload => {\n        return this.cartVoucherConnector.remove(payload.userId, payload.cartId, payload.voucherId).pipe(map(() => {\n          this.showGlobalMessage('voucher.removeVoucherSuccess', payload.voucherId, GlobalMessageType.MSG_TYPE_INFO);\n          return new CartRemoveVoucherSuccess({\n            userId: payload.userId,\n            cartId: payload.cartId,\n            voucherId: payload.voucherId\n          });\n        }), catchError(error => from([new CartRemoveVoucherFail({\n          error: normalizeHttpError(error),\n          cartId: payload.cartId,\n          userId: payload.userId,\n          voucherId: payload.voucherId\n        }), new LoadCart({\n          userId: payload.userId,\n          cartId: payload.cartId\n        })])));\n      }));\n    }\n    showGlobalMessage(text, param, messageType) {\n      this.messageService.add({\n        key: text,\n        params: {\n          voucherCode: param\n        }\n      }, messageType);\n    }\n  }\n  CartVoucherEffects.ɵfac = function CartVoucherEffects_Factory(t) {\n    return new (t || CartVoucherEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CartVoucherConnector), i0.ɵɵinject(GlobalMessageService));\n  };\n  CartVoucherEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartVoucherEffects,\n    factory: CartVoucherEffects.ɵfac\n  });\n  __decorate([Effect()], CartVoucherEffects.prototype, \"addCartVoucher$\", void 0);\n  __decorate([Effect()], CartVoucherEffects.prototype, \"removeCartVoucher$\", void 0);\n  return CartVoucherEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst getMultiCartState = createFeatureSelector(MULTI_CART_FEATURE);\nconst getMultiCartEntities = createSelector(getMultiCartState, state => state.carts);\nconst getCartEntitySelectorFactory = cartId => {\n  return createSelector(getMultiCartEntities, state => entityProcessesLoaderStateSelector(state, cartId));\n};\nconst getCartSelectorFactory = cartId => {\n  return createSelector(getMultiCartEntities, state => entityValueSelector(state, cartId));\n};\nconst getCartIsStableSelectorFactory = cartId => {\n  return createSelector(getMultiCartEntities, state => entityIsStableSelector(state, cartId));\n};\nconst getCartHasPendingProcessesSelectorFactory = cartId => {\n  return createSelector(getMultiCartEntities, state => entityHasPendingProcessesSelector(state, cartId));\n};\nconst getCartEntriesSelectorFactory = cartId => {\n  return createSelector(getCartSelectorFactory(cartId), state => {\n    return state && state.entries ? state.entries : [];\n  });\n};\nconst getCartEntrySelectorFactory = (cartId, productCode) => {\n  return createSelector(getCartEntriesSelectorFactory(cartId), state => {\n    return state ? state.find(entry => entry.product.code === productCode) : undefined;\n  });\n};\nconst getActiveCartId = createSelector(getMultiCartState, state => state.active);\nconst getWishListId = createSelector(getMultiCartState, state => state.wishList);\nconst getCartsSelectorFactory = createSelector(getMultiCartEntities, state => Object.keys(state.entities).map(key => entityValueSelector(state, key)));\nclass CartAdapter {}\nlet CartConnector = /*#__PURE__*/(() => {\n  class CartConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    loadAll(userId) {\n      return this.adapter.loadAll(userId);\n    }\n    load(userId, cartId) {\n      return this.adapter.load(userId, cartId);\n    }\n    create(userId, oldCartId, toMergeCartGuid) {\n      return this.adapter.create(userId, oldCartId, toMergeCartGuid);\n    }\n    delete(userId, cartId) {\n      return this.adapter.delete(userId, cartId);\n    }\n    addEmail(userId, cartId, email) {\n      return this.adapter.addEmail(userId, cartId, email);\n    }\n  }\n  CartConnector.ɵfac = function CartConnector_Factory(t) {\n    return new (t || CartConnector)(i0.ɵɵinject(CartAdapter));\n  };\n  CartConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartConnector,\n    factory: CartConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CartConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartEffects = /*#__PURE__*/(() => {\n  class CartEffects {\n    constructor(actions$, cartConnector, store) {\n      this.actions$ = actions$;\n      this.cartConnector = cartConnector;\n      this.store = store;\n      this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n      this.loadCart$ = this.actions$.pipe(ofType(LOAD_CART), map(action => action.payload), groupBy(payload => payload.cartId), mergeMap(group$ => group$.pipe(switchMap(payload => {\n        return of(payload).pipe(withLatestFrom(this.store.pipe(select(getCartHasPendingProcessesSelectorFactory(payload.cartId)))));\n      }), filter(([_, hasPendingProcesses]) => !hasPendingProcesses), map(([payload]) => payload), switchMap(payload => {\n        return this.cartConnector.load(payload.userId, payload.cartId).pipe(mergeMap(cart => {\n          let actions = [];\n          if (cart) {\n            actions.push(new LoadCartSuccess(Object.assign(Object.assign({}, payload), {\n              cart,\n              cartId: getCartIdByUserId(cart, payload.userId)\n            })));\n            if (payload.cartId === OCC_CART_ID_CURRENT) {\n              // Removing cart from entity object under `current` key as it is no longer needed.\n              // Current cart is loaded under it's code entity.\n              actions.push(new RemoveCart({\n                cartId: OCC_CART_ID_CURRENT\n              }));\n            }\n          } else {\n            actions = [new LoadCartFail(Object.assign(Object.assign({}, payload), {\n              error: {}\n            }))];\n          }\n          return actions;\n        }), catchError(error => {\n          var _a;\n          if ((_a = error === null || error === void 0 ? void 0 : error.error) === null || _a === void 0 ? void 0 : _a.errors) {\n            const couponExpiredErrors = error.error.errors.filter(err => err.reason === 'invalid');\n            if (couponExpiredErrors.length > 0) {\n              // Reload in case of expired coupon.\n              return of(new LoadCart(Object.assign({}, payload)));\n            }\n            const cartNotFoundErrors = error.error.errors.filter(err => isCartNotFoundError(err) || err.reason === 'UnknownResourceError');\n            if (cartNotFoundErrors.length > 0) {\n              // Remove cart as it doesn't exist on backend (selective cart always exists).\n              return of(new RemoveCart({\n                cartId: payload.cartId\n              }));\n            }\n          }\n          return of(new LoadCartFail(Object.assign(Object.assign({}, payload), {\n            error: normalizeHttpError(error)\n          })));\n        }));\n      }))), withdrawOn(this.contextChange$));\n      this.createCart$ = this.actions$.pipe(ofType(CREATE_CART), map(action => action.payload), mergeMap(payload => {\n        return this.cartConnector.create(payload.userId, payload.oldCartId, payload.toMergeCartGuid).pipe(switchMap(cart => {\n          const conditionalActions = [];\n          if (payload.oldCartId) {\n            conditionalActions.push(new MergeCartSuccess({\n              extraData: payload.extraData,\n              userId: payload.userId,\n              tempCartId: payload.tempCartId,\n              cartId: getCartIdByUserId(cart, payload.userId),\n              oldCartId: payload.oldCartId\n            }));\n          }\n          return [new CreateCartSuccess(Object.assign(Object.assign({}, payload), {\n            cart,\n            cartId: getCartIdByUserId(cart, payload.userId)\n          })), new SetTempCart({\n            cart,\n            tempCartId: payload.tempCartId\n          }), ...conditionalActions];\n        }), catchError(error => of(new CreateCartFail(Object.assign(Object.assign({}, payload), {\n          error: normalizeHttpError(error)\n        })))));\n      }), withdrawOn(this.contextChange$));\n      this.mergeCart$ = this.actions$.pipe(ofType(MERGE_CART), map(action => action.payload), switchMap(payload => {\n        return this.cartConnector.load(payload.userId, OCC_CART_ID_CURRENT).pipe(map(currentCart => {\n          if ((currentCart === null || currentCart === void 0 ? void 0 : currentCart.code) !== payload.cartId) {\n            return new CreateCart({\n              userId: payload.userId,\n              oldCartId: payload.cartId,\n              toMergeCartGuid: currentCart ? currentCart.guid : undefined,\n              extraData: payload.extraData,\n              tempCartId: payload.tempCartId\n            });\n          }\n        }), filter(isNotUndefined));\n      }), withdrawOn(this.contextChange$));\n      // TODO(#7241): Remove when AddVoucherSuccess actions will extend processes actions\n      this.refresh$ = this.actions$.pipe(ofType(CART_ADD_VOUCHER_SUCCESS), map(action => action.payload), concatMap(payload => from([new CartProcessesDecrement(payload.cartId), new LoadCart({\n        userId: payload.userId,\n        cartId: payload.cartId\n      })])));\n      // TODO: Switch to automatic cart reload on processes count reaching 0 for cart entity\n      this.refreshWithoutProcesses$ = this.actions$.pipe(ofType(CART_ADD_ENTRY_SUCCESS, CART_REMOVE_ENTRY_SUCCESS, CART_UPDATE_ENTRY_SUCCESS, CART_REMOVE_VOUCHER_SUCCESS), map(action => action.payload), map(payload => new LoadCart({\n        userId: payload.userId,\n        cartId: payload.cartId\n      })));\n      this.resetCartDetailsOnSiteContextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), mergeMap(() => {\n        return [new ResetCartDetails()];\n      }));\n      this.addEmail$ = this.actions$.pipe(ofType(ADD_EMAIL_TO_CART), map(action => action.payload), mergeMap(payload => this.cartConnector.addEmail(payload.userId, payload.cartId, payload.email).pipe(mergeMap(() => {\n        return [new AddEmailToCartSuccess(Object.assign({}, payload)), new LoadCart({\n          userId: payload.userId,\n          cartId: payload.cartId\n        })];\n      }), catchError(error => from([new AddEmailToCartFail(Object.assign(Object.assign({}, payload), {\n        error: normalizeHttpError(error)\n      })), new LoadCart({\n        userId: payload.userId,\n        cartId: payload.cartId\n      })])))), withdrawOn(this.contextChange$));\n      this.deleteCart$ = this.actions$.pipe(ofType(DELETE_CART), map(action => action.payload), mergeMap(payload => this.cartConnector.delete(payload.userId, payload.cartId).pipe(map(() => {\n        return new DeleteCartSuccess(Object.assign({}, payload));\n      }), catchError(error => from([new DeleteCartFail(Object.assign(Object.assign({}, payload), {\n        error: normalizeHttpError(error)\n      })),\n      // Error might happen in higher backend layer and cart could still be removed.\n      // When load fail with NotFound error then RemoveCart action will kick in and clear that cart in our state.\n      new LoadCart(Object.assign({}, payload))])))));\n    }\n  }\n  CartEffects.ɵfac = function CartEffects_Factory(t) {\n    return new (t || CartEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CartConnector), i0.ɵɵinject(i1$2.Store));\n  };\n  CartEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartEffects,\n    factory: CartEffects.ɵfac\n  });\n  __decorate([Effect()], CartEffects.prototype, \"loadCart$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"createCart$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"mergeCart$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"refresh$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"refreshWithoutProcesses$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"resetCartDetailsOnSiteContextChange$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"addEmail$\", void 0);\n  __decorate([Effect()], CartEffects.prototype, \"deleteCart$\", void 0);\n  return CartEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar multiCartGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getMultiCartState: getMultiCartState,\n  getMultiCartEntities: getMultiCartEntities,\n  getCartEntitySelectorFactory: getCartEntitySelectorFactory,\n  getCartSelectorFactory: getCartSelectorFactory,\n  getCartIsStableSelectorFactory: getCartIsStableSelectorFactory,\n  getCartHasPendingProcessesSelectorFactory: getCartHasPendingProcessesSelectorFactory,\n  getCartEntriesSelectorFactory: getCartEntriesSelectorFactory,\n  getCartEntrySelectorFactory: getCartEntrySelectorFactory,\n  getActiveCartId: getActiveCartId,\n  getWishListId: getWishListId,\n  getCartsSelectorFactory: getCartsSelectorFactory\n});\nclass SaveCartAdapter {}\nlet SaveCartConnector = /*#__PURE__*/(() => {\n  class SaveCartConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    saveCart(userId, cartId, saveCartName, saveCartDescription) {\n      return this.adapter.saveCart(userId, cartId, saveCartName, saveCartDescription);\n    }\n  }\n  SaveCartConnector.ɵfac = function SaveCartConnector_Factory(t) {\n    return new (t || SaveCartConnector)(i0.ɵɵinject(SaveCartAdapter));\n  };\n  SaveCartConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SaveCartConnector,\n    factory: SaveCartConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return SaveCartConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WishListEffects = /*#__PURE__*/(() => {\n  class WishListEffects {\n    constructor(actions$, cartConnector, saveCartConnector, userIdService, store) {\n      this.actions$ = actions$;\n      this.cartConnector = cartConnector;\n      this.saveCartConnector = saveCartConnector;\n      this.userIdService = userIdService;\n      this.store = store;\n      this.createWishList$ = this.actions$.pipe(ofType(CREATE_WISH_LIST), map(action => action.payload), switchMap(payload => {\n        return this.cartConnector.create(payload.userId).pipe(switchMap(cart => {\n          return this.saveCartConnector.saveCart(payload.userId, cart.code, payload.name, payload.description).pipe(switchMap(saveCartResult => [new CreateWishListSuccess({\n            cart: saveCartResult.savedCartData,\n            userId: payload.userId\n          })]), catchError(error => from([new CreateWishListFail({\n            cartId: cart.code,\n            error: normalizeHttpError(error)\n          })])));\n        }));\n      }));\n      this.loadWishList$ = this.actions$.pipe(ofType(LOAD_WISH_LIST), map(action => action.payload), concatMap(payload => {\n        const {\n          userId,\n          customerId,\n          tempCartId\n        } = payload;\n        return this.cartConnector.loadAll(userId).pipe(switchMap(carts => {\n          if (carts) {\n            const wishList = carts.find(cart => cart.name === getWishlistName(customerId));\n            if (Boolean(wishList)) {\n              return [new LoadWishListSuccess({\n                cart: wishList,\n                userId,\n                tempCartId,\n                customerId,\n                cartId: getCartIdByUserId(wishList, userId)\n              }), new RemoveCart({\n                cartId: tempCartId\n              })];\n            } else {\n              return [new CreateWishList({\n                userId,\n                name: getWishlistName(customerId)\n              })];\n            }\n          }\n        }), catchError(error => from([new LoadWishListFail({\n          userId,\n          cartId: tempCartId,\n          customerId,\n          error: normalizeHttpError(error)\n        })])));\n      }));\n      this.resetWishList$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), withLatestFrom(this.userIdService.getUserId(), this.store.pipe(select(getWishListId))), switchMap(([, userId, wishListId]) => {\n        if (Boolean(wishListId)) {\n          return this.cartConnector.load(userId, wishListId).pipe(switchMap(wishList => [new LoadWishListSuccess({\n            cart: wishList,\n            userId,\n            cartId: getCartIdByUserId(wishList, userId)\n          })]), catchError(error => from([new LoadWishListFail({\n            userId,\n            cartId: wishListId,\n            error: normalizeHttpError(error)\n          })])));\n        }\n        return EMPTY;\n      }));\n    }\n  }\n  WishListEffects.ɵfac = function WishListEffects_Factory(t) {\n    return new (t || WishListEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CartConnector), i0.ɵɵinject(SaveCartConnector), i0.ɵɵinject(UserIdService), i0.ɵɵinject(i1$2.Store));\n  };\n  WishListEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WishListEffects,\n    factory: WishListEffects.ɵfac\n  });\n  __decorate([Effect()], WishListEffects.prototype, \"createWishList$\", void 0);\n  __decorate([Effect()], WishListEffects.prototype, \"loadWishList$\", void 0);\n  __decorate([Effect()], WishListEffects.prototype, \"resetWishList$\", void 0);\n  return WishListEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst activeCartInitialState = null;\nconst activeCartDefaultState = '';\nconst wishListInitialState = '';\nfunction activeCartReducer(state = activeCartDefaultState, action) {\n  var _a, _b, _c;\n  switch (action.type) {\n    case LOAD_CART_SUCCESS:\n    case CREATE_CART_SUCCESS:\n    // point to `temp-${uuid}` cart when we are creating/merging cart\n    case CREATE_CART:\n      if ((_b = (_a = action === null || action === void 0 ? void 0 : action.payload) === null || _a === void 0 ? void 0 : _a.extraData) === null || _b === void 0 ? void 0 : _b.active) {\n        return action.meta.entityId;\n      } else {\n        return state;\n      }\n    case SET_ACTIVE_CART_ID:\n      return action.payload;\n    case REMOVE_CART:\n    case DELETE_CART_SUCCESS:\n      if (((_c = action.payload) === null || _c === void 0 ? void 0 : _c.cartId) === state) {\n        return activeCartDefaultState;\n      }\n      return state;\n    case CLEAR_CART_STATE:\n      return state === activeCartInitialState ? activeCartInitialState : activeCartDefaultState;\n  }\n  return state;\n}\nconst cartEntitiesInitialState = undefined;\nfunction cartEntitiesReducer(state = cartEntitiesInitialState, action) {\n  switch (action.type) {\n    case LOAD_CARTS_SUCCESS:\n      return action.payload;\n    case LOAD_CART_SUCCESS:\n    case CREATE_CART_SUCCESS:\n    case CREATE_WISH_LIST_SUCCESS:\n    case LOAD_WISH_LIST_SUCCESS:\n    case SET_TEMP_CART:\n      return action.payload.cart;\n  }\n  return state;\n}\nfunction wishListReducer(state = wishListInitialState, action) {\n  switch (action.type) {\n    case CREATE_WISH_LIST_SUCCESS:\n    case LOAD_WISH_LIST_SUCCESS:\n      return action.meta.entityId;\n    case CLEAR_CART_STATE:\n      return wishListInitialState;\n  }\n  return state;\n}\nfunction clearMultiCartState(reducer) {\n  return function (state, action) {\n    if (action.type === LOGOUT) {\n      state = undefined;\n    }\n    return reducer(state, action);\n  };\n}\nconst multiCartMetaReducers = [clearMultiCartState];\nconst multiCartReducerToken = new InjectionToken('MultiCartReducers');\nfunction getMultiCartReducers() {\n  return {\n    carts: entityProcessesLoaderReducer(MULTI_CART_DATA, cartEntitiesReducer),\n    active: activeCartReducer,\n    wishList: wishListReducer\n  };\n}\nconst multiCartReducerProvider = {\n  provide: multiCartReducerToken,\n  useFactory: getMultiCartReducers\n};\nlet MultiCartStatePersistenceService = /*#__PURE__*/(() => {\n  class MultiCartStatePersistenceService {\n    constructor(statePersistenceService, store, siteContextParamsService) {\n      this.statePersistenceService = statePersistenceService;\n      this.store = store;\n      this.siteContextParamsService = siteContextParamsService;\n      this.subscription = new Subscription();\n    }\n    initSync() {\n      this.subscription.add(this.statePersistenceService.syncWithStorage({\n        key: 'cart',\n        state$: this.getCartState(),\n        context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]),\n        onRead: state => this.onRead(state)\n      }));\n    }\n    getCartState() {\n      return this.store.pipe(select(getMultiCartState), filter(state => !!state), distinctUntilKeyChanged('active'), map(state => {\n        return {\n          active: state.active\n        };\n      }));\n    }\n    onRead(state) {\n      this.store.dispatch(new ClearCartState());\n      if (state) {\n        this.store.dispatch(new SetActiveCartId(state.active));\n      } else {\n        this.store.dispatch(new SetActiveCartId(''));\n      }\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  MultiCartStatePersistenceService.ɵfac = function MultiCartStatePersistenceService_Factory(t) {\n    return new (t || MultiCartStatePersistenceService)(i0.ɵɵinject(StatePersistenceService), i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(SiteContextParamsService));\n  };\n  MultiCartStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MultiCartStatePersistenceService,\n    factory: MultiCartStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return MultiCartStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction cartStatePersistenceFactory(cartStatePersistenceService, configInit) {\n  const result = () => configInit.getStable('context').pipe(tap(() => {\n    cartStatePersistenceService.initSync();\n  })).toPromise();\n  return result;\n}\n/**\n * Before `MultiCartStatePersistenceService` restores the active cart id `ActiveCartService`\n * will use `current` cart instead of the one saved in browser. This meta reducer\n * sets the value on store initialization to null cart which holds active cart loading\n * until the data from storage is restored.\n */\nfunction uninitializeActiveCartMetaReducerFactory() {\n  const metaReducer = reducer => (state, action) => {\n    const newState = Object.assign({}, state);\n    if (action.type === '@ngrx/store/init') {\n      newState.cart = Object.assign(Object.assign({}, newState.cart), {\n        active: activeCartInitialState\n      });\n    }\n    return reducer(newState, action);\n  };\n  return metaReducer;\n}\n/**\n * Complimentary module for cart to store cart id in browser storage.\n * This makes it possible to work on the same anonymous cart even after page refresh.\n */\nlet CartPersistenceModule = /*#__PURE__*/(() => {\n  class CartPersistenceModule {\n    static forRoot() {\n      return {\n        ngModule: CartPersistenceModule,\n        providers: [{\n          provide: APP_INITIALIZER,\n          useFactory: cartStatePersistenceFactory,\n          deps: [MultiCartStatePersistenceService, ConfigInitializerService],\n          multi: true\n        }, {\n          provide: META_REDUCERS,\n          useFactory: uninitializeActiveCartMetaReducerFactory,\n          multi: true\n        }]\n      };\n    }\n  }\n  CartPersistenceModule.ɵfac = function CartPersistenceModule_Factory(t) {\n    return new (t || CartPersistenceModule)();\n  };\n  CartPersistenceModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CartPersistenceModule\n  });\n  CartPersistenceModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return CartPersistenceModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Base cart event. Most cart events should have these properties.\n */\nclass CartEvent extends CxEvent {}\n// =====================================================================\nlet CartAddEntryEvent = /*#__PURE__*/(() => {\n  class CartAddEntryEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartAddEntryEvent.type = 'CartAddEntryEvent';\n  return CartAddEntryEvent;\n})();\nlet CartAddEntrySuccessEvent = /*#__PURE__*/(() => {\n  class CartAddEntrySuccessEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartAddEntrySuccessEvent.type = 'CartAddEntrySuccessEvent';\n  return CartAddEntrySuccessEvent;\n})();\nlet CartAddEntryFailEvent = /*#__PURE__*/(() => {\n  class CartAddEntryFailEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartAddEntryFailEvent.type = 'CartAddEntryFailEvent';\n  return CartAddEntryFailEvent;\n})();\nlet CartRemoveEntryFailEvent = /*#__PURE__*/(() => {\n  class CartRemoveEntryFailEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartRemoveEntryFailEvent.type = 'CartRemoveEntryFailEvent';\n  return CartRemoveEntryFailEvent;\n})();\nlet CartRemoveEntrySuccessEvent = /*#__PURE__*/(() => {\n  class CartRemoveEntrySuccessEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartRemoveEntrySuccessEvent.type = 'CartRemoveEntrySuccessEvent';\n  return CartRemoveEntrySuccessEvent;\n})();\nlet CartUpdateEntrySuccessEvent = /*#__PURE__*/(() => {\n  class CartUpdateEntrySuccessEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartUpdateEntrySuccessEvent.type = 'CartUpdateEntrySuccessEvent';\n  return CartUpdateEntrySuccessEvent;\n})();\nlet CartUpdateEntryFailEvent = /*#__PURE__*/(() => {\n  class CartUpdateEntryFailEvent extends CartEvent {}\n  /**\n   * Event's type\n   */\n  CartUpdateEntryFailEvent.type = 'CartUpdateEntryFailEvent';\n\n  // Email Standard RFC 5322:\n  return CartUpdateEntryFailEvent;\n})();\nconst EMAIL_PATTERN = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line\nconst PASSWORD_PATTERN = /^(?=.*?[A-Z])(?=.*?[0-9])(?=.*?[!@#$%^*()_\\-+{};:.,]).{6,}$/;\nlet MultiCartService = /*#__PURE__*/(() => {\n  class MultiCartService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Returns cart from store as an observable\n     *\n     * @param cartId\n     */\n    getCart(cartId) {\n      return this.store.pipe(select(getCartSelectorFactory(cartId)));\n    }\n    /**\n     * Returns a list of carts from store as an observable\n     *\n     */\n    getCarts() {\n      return this.store.pipe(select(getCartsSelectorFactory));\n    }\n    /**\n     * Returns cart entity from store (cart with loading, error, success flags) as an observable\n     *\n     * @param cartId\n     */\n    getCartEntity(cartId) {\n      return this.store.pipe(select(getCartEntitySelectorFactory(cartId)));\n    }\n    /**\n     * Returns true when there are no operations on that in progress and it is not currently loading\n     *\n     * @param cartId\n     */\n    isStable(cartId) {\n      return this.store.pipe(select(getCartIsStableSelectorFactory(cartId)),\n      // We dispatch a lot of actions just after finishing some process or loading, so we want this flag not to flicker.\n      // This flickering should only be avoided when switching from false to true\n      // Start of loading should be showed instantly (no debounce)\n      // Extra actions are only dispatched after some loading\n      debounce(isStable => isStable ? timer(0) : EMPTY), distinctUntilChanged());\n    }\n    /**\n     * Simple random temp cart id generator\n     */\n    generateTempCartId() {\n      const pseudoUuid = Math.random().toString(36).substr(2, 9);\n      return `temp-${pseudoUuid}`;\n    }\n    /**\n     * Create or merge cart\n     *\n     * @param params Object with userId, oldCartId, toMergeCartGuid and extraData\n     */\n    createCart({\n      userId,\n      oldCartId,\n      toMergeCartGuid,\n      extraData\n    }) {\n      // to support creating multiple carts at the same time we need to use different entity for every process\n      // simple random uuid generator is used here for entity names\n      const tempCartId = this.generateTempCartId();\n      this.store.dispatch(new CreateCart({\n        extraData,\n        userId,\n        oldCartId,\n        toMergeCartGuid,\n        tempCartId\n      }));\n      return this.getCartEntity(tempCartId);\n    }\n    /**\n     * Merge provided cart to current user cart\n     *\n     * @param params Object with userId, cartId and extraData\n     */\n    mergeToCurrentCart({\n      userId,\n      cartId,\n      extraData\n    }) {\n      const tempCartId = this.generateTempCartId();\n      this.store.dispatch(new MergeCart({\n        userId,\n        cartId,\n        extraData,\n        tempCartId\n      }));\n    }\n    /**\n     * Load cart\n     *\n     * @param params Object with userId, cartId and extraData\n     */\n    loadCart({\n      cartId,\n      userId,\n      extraData\n    }) {\n      this.store.dispatch(new LoadCart({\n        userId,\n        cartId,\n        extraData\n      }));\n    }\n    /**\n     * Get cart entries as an observable\n     * @param cartId\n     */\n    getEntries(cartId) {\n      return this.store.pipe(select(getCartEntriesSelectorFactory(cartId)));\n    }\n    /**\n     * Get last entry for specific product code from cart.\n     * Needed to cover processes where multiple entries can share the same product code\n     * (e.g. promotions or configurable products)\n     *\n     * @param cartId\n     * @param productCode\n     */\n    getLastEntry(cartId, productCode) {\n      return this.store.pipe(select(getCartEntriesSelectorFactory(cartId)), map(entries => {\n        const filteredEntries = entries.filter(entry => entry.product.code === productCode);\n        return filteredEntries ? filteredEntries[filteredEntries.length - 1] : undefined;\n      }));\n    }\n    /**\n     * Add entry to cart\n     *\n     * @param userId\n     * @param cartId\n     * @param productCode\n     * @param quantity\n     */\n    addEntry(userId, cartId, productCode, quantity) {\n      this.store.dispatch(new CartAddEntry({\n        userId,\n        cartId,\n        productCode,\n        quantity\n      }));\n    }\n    /**\n     * Add multiple entries to cart\n     *\n     * @param userId\n     * @param cartId\n     * @param products Array with items (productCode and quantity)\n     */\n    addEntries(userId, cartId, products) {\n      products.forEach(product => {\n        this.store.dispatch(new CartAddEntry({\n          userId,\n          cartId,\n          productCode: product.productCode,\n          quantity: product.quantity\n        }));\n      });\n    }\n    /**\n     * Remove entry from cart\n     *\n     * @param userId\n     * @param cartId\n     * @param entryNumber\n     */\n    removeEntry(userId, cartId, entryNumber) {\n      this.store.dispatch(new CartRemoveEntry({\n        userId,\n        cartId,\n        entryNumber: `${entryNumber}`\n      }));\n    }\n    /**\n     * Update entry in cart. For quantity = 0 it removes entry\n     *\n     * @param userId\n     * @param cartId\n     * @param entryNumber\n     * @param quantity\n     */\n    updateEntry(userId, cartId, entryNumber, quantity) {\n      if (quantity > 0) {\n        this.store.dispatch(new CartUpdateEntry({\n          userId,\n          cartId,\n          entryNumber: `${entryNumber}`,\n          quantity: quantity\n        }));\n      } else {\n        this.removeEntry(userId, cartId, entryNumber);\n      }\n    }\n    /**\n     * Get first entry from cart matching the specified product code\n     *\n     * @param cartId\n     * @param productCode\n     */\n    getEntry(cartId, productCode) {\n      return this.store.pipe(select(getCartEntrySelectorFactory(cartId, productCode)));\n    }\n    /**\n     * Assign email to the cart\n     *\n     * @param cartId\n     * @param userId\n     * @param email\n     */\n    assignEmail(cartId, userId, email) {\n      this.store.dispatch(new AddEmailToCart({\n        userId,\n        cartId,\n        email\n      }));\n    }\n    /**\n     * Delete cart\n     *\n     * @param cartId\n     * @param userId\n     */\n    deleteCart(cartId, userId) {\n      this.store.dispatch(new DeleteCart({\n        userId,\n        cartId\n      }));\n    }\n    /**\n     * Reloads the cart with specified id.\n     *\n     * @param cartId\n     * @param extraData\n     */\n    reloadCart(cartId, extraData) {\n      this.userIdService.takeUserId().subscribe(userId => this.store.dispatch(new LoadCart({\n        userId,\n        cartId,\n        extraData\n      })));\n    }\n  }\n  MultiCartService.ɵfac = function MultiCartService_Factory(t) {\n    return new (t || MultiCartService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  MultiCartService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MultiCartService,\n    factory: MultiCartService.ɵfac,\n    providedIn: 'root'\n  });\n  return MultiCartService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ActiveCartService = /*#__PURE__*/(() => {\n  class ActiveCartService {\n    constructor(store, multiCartService, userIdService) {\n      this.store = store;\n      this.multiCartService = multiCartService;\n      this.userIdService = userIdService;\n      this.subscription = new Subscription();\n      // This stream is used for referencing carts in API calls.\n      this.activeCartId$ = this.userIdService.getUserId().pipe(\n      // We want to wait with initialization of cartId until we have userId initialized\n      // We have take(1) to not trigger this stream, when userId changes.\n      take(1), switchMapTo(this.store), select(getActiveCartId),\n      // We also wait until we initialize cart from localStorage. Before that happens cartId in store === null\n      filter(cartId => cartId !== activeCartInitialState), map(cartId => {\n        if (cartId === '') {\n          // We fallback to current when we don't have particular cart id -> cartId === '', because that's how you reference latest user cart.\n          return OCC_CART_ID_CURRENT;\n        }\n        return cartId;\n      }));\n      // Stream with active cart entity\n      this.cartSelector$ = this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getCartEntity(cartId)));\n      this.initActiveCart();\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    initActiveCart() {\n      // Any change of user id is also interesting for us, because we have to merge/load/switch cart in those cases.\n      this.subscription.add(this.userIdService.getUserId().pipe(\n      // We never trigger cart merge/load on app initialization here and that's why we wait with pairwise for a change of userId (not initialization).\n      pairwise(), switchMap(([previousUserId, userId]) =>\n      // We need cartId once we have the previous and current userId. We don't want to subscribe to cartId stream before.\n      combineLatest([of(previousUserId), of(userId), this.activeCartId$]).pipe(take(1)))).subscribe(([previousUserId, userId, cartId]) => {\n        // Only change of user and not a logout (current user id !== anonymous) should trigger loading mechanism\n        if (this.isJustLoggedIn(userId, previousUserId)) {\n          this.loadOrMerge(cartId, userId, previousUserId);\n        }\n      }));\n      // Stream for getting the cart value\n      const activeCartValue$ = this.cartSelector$.pipe(map(cartEntity => {\n        return {\n          cart: cartEntity.value,\n          isStable: !cartEntity.loading && cartEntity.processesCount === 0,\n          loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading\n        };\n      }),\n      // we want to emit empty carts even if those are not stable\n      // on merge cart action we want to switch to empty cart so no one would use old cartId which can be already obsolete\n      // so on merge action the resulting stream looks like this: old_cart -> {} -> new_cart\n      filter(({\n        isStable,\n        cart\n      }) => isStable || this.isEmpty(cart)));\n      // Responsible for loading cart when it's not (eg. app initialization when we have only cart id)\n      const activeCartLoading$ = activeCartValue$.pipe(withLatestFrom(this.activeCartId$, this.userIdService.getUserId()), tap(([{\n        cart,\n        loaded,\n        isStable\n      }, cartId, userId]) => {\n        if (isStable && this.isEmpty(cart) && !loaded && !isTempCartId(cartId)) {\n          this.load(cartId, userId);\n        }\n      }));\n      this.activeCart$ = using(() => activeCartLoading$.subscribe(), () => activeCartValue$).pipe(\n      // Normalization for empty cart value. It will always be returned as empty object.\n      map(({\n        cart\n      }) => cart ? cart : {}), distinctUntilChanged(), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    /**\n     * Returns active cart\n     */\n    getActive() {\n      return this.activeCart$;\n    }\n    /**\n     * Waits for the cart to be stable before returning the active cart.\n     */\n    takeActive() {\n      return this.isStable().pipe(filter(isStable => isStable), switchMap(() => this.getActive()), filter(cart => !!cart), take(1));\n    }\n    /**\n     * Returns active cart id\n     */\n    getActiveCartId() {\n      return this.activeCart$.pipe(withLatestFrom(this.userIdService.getUserId()), map(([cart, userId]) => getCartIdByUserId(cart, userId)), distinctUntilChanged());\n    }\n    /**\n     * Returns cart entries\n     */\n    getEntries() {\n      return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getEntries(cartId)), distinctUntilChanged());\n    }\n    /**\n     * Returns last cart entry for provided product code.\n     * Needed to cover processes where multiple entries can share the same product code\n     * (e.g. promotions or configurable products)\n     *\n     * @param productCode\n     */\n    getLastEntry(productCode) {\n      return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getLastEntry(cartId, productCode)), distinctUntilChanged());\n    }\n    /**\n     * Returns cart loading state\n     */\n    getLoading() {\n      return this.cartSelector$.pipe(map(cartEntity => cartEntity.loading), distinctUntilChanged());\n    }\n    /**\n     * Returns true when cart is stable (not loading and not pending processes on cart)\n     */\n    isStable() {\n      // Debounce is used here, to avoid flickering when we switch between different cart entities.\n      // For example during `addEntry` method. We might try to load current cart, so `current cart will be then active id.\n      // After load fails we might create new cart so we switch to `temp-${uuid}` cart entity used when creating cart.\n      // At the end we finally switch to cart `code` for cart id. Between those switches cart `isStable` function should not flicker.\n      return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.isStable(cartId)), debounce(state => state ? timer(0) : EMPTY), distinctUntilChanged());\n    }\n    /**\n     * Loads cart or upon login, whenever there's an existing cart, merge it into the current user cart\n     * cartId will be defined (not '', null, undefined)\n     */\n    loadOrMerge(cartId, userId, previousUserId) {\n      if (cartId === OCC_CART_ID_CURRENT) {\n        this.multiCartService.loadCart({\n          userId,\n          cartId: OCC_CART_ID_CURRENT,\n          extraData: {\n            active: true\n          }\n        });\n      } else if (this.isGuestCart()) {\n        this.guestCartMerge(cartId);\n      } else if (userId !== previousUserId && userId !== OCC_USER_ID_ANONYMOUS && previousUserId !== OCC_USER_ID_ANONYMOUS) {\n        // This case covers the case when you are logged in and then asm user logs in and you don't want to merge, but only load emulated user cart\n        // Similarly when you are logged in as asm user and you logout and want to resume previous user session\n        this.multiCartService.loadCart({\n          userId,\n          cartId,\n          extraData: {\n            active: true\n          }\n        });\n      } else {\n        // We have particular cart locally, but we logged in, so we need to combine this with current cart or make it ours.\n        this.multiCartService.mergeToCurrentCart({\n          userId,\n          cartId,\n          extraData: {\n            active: true\n          }\n        });\n      }\n    }\n    /**\n     * Loads cart in every case apart from anonymous user and current cart combination\n     */\n    load(cartId, userId) {\n      if (!(userId === OCC_USER_ID_ANONYMOUS && cartId === OCC_CART_ID_CURRENT)) {\n        this.multiCartService.loadCart({\n          userId,\n          cartId,\n          extraData: {\n            active: true\n          }\n        });\n      }\n    }\n    /**\n     * Adds entries from guest cart to user cart\n     */\n    addEntriesGuestMerge(cartEntries) {\n      const entriesToAdd = cartEntries.map(entry => ({\n        productCode: entry.product.code,\n        quantity: entry.quantity\n      }));\n      this.requireLoadedCartForGuestMerge().pipe(withLatestFrom(this.userIdService.getUserId())).subscribe(([cartState, userId]) => {\n        this.multiCartService.addEntries(userId, getCartIdByUserId(cartState.value, userId), entriesToAdd);\n      });\n    }\n    /**\n     * Helper method for requiring loaded cart that is not a guest cart (guest cart is filtered out).\n     * Used when merging guest cart with user cart.\n     */\n    requireLoadedCartForGuestMerge() {\n      return this.requireLoadedCart(this.cartSelector$.pipe(filter(() => !this.isGuestCart())));\n    }\n    isCartCreating(cartState, cartId) {\n      // cart creating is always represented with loading flags\n      // when all loading flags are false it means that we restored wrong cart id\n      // could happen on context change or reload right in the middle on cart create call\n      return isTempCartId(cartId) && (cartState.loading || cartState.success || cartState.error);\n    }\n    requireLoadedCart(customCartSelector$) {\n      // For guest cart merge we want to filter guest cart in the whole stream\n      // We have to wait with load/create/addEntry after guest cart will be deleted.\n      // That's why you can provide custom selector with this filter applied.\n      const cartSelector$ = customCartSelector$ ? customCartSelector$ : this.cartSelector$;\n      return cartSelector$.pipe(filter(cartState => !cartState.loading),\n      // Avoid load/create call when there are new cart creating at the moment\n      withLatestFrom(this.activeCartId$), filter(([cartState, cartId]) => !this.isCartCreating(cartState, cartId)), map(([cartState]) => cartState), take(1), withLatestFrom(this.userIdService.getUserId()), tap(([cartState, userId]) => {\n        // Try to load the cart, because it might have been created on another device between our login and add entry call\n        if (this.isEmpty(cartState.value) && userId !== OCC_USER_ID_ANONYMOUS) {\n          this.load(OCC_CART_ID_CURRENT, userId);\n        }\n      }), switchMap(() => {\n        return cartSelector$;\n      }), filter(cartState => !cartState.loading),\n      // create cart can happen to anonymous user if it is not empty or to any other user if it is loaded and empty\n      withLatestFrom(this.userIdService.getUserId()), filter(([cartState, userId]) => userId === OCC_USER_ID_ANONYMOUS || cartState.success || cartState.error), take(1), tap(([cartState, userId]) => {\n        if (this.isEmpty(cartState.value)) {\n          this.multiCartService.createCart({\n            userId,\n            extraData: {\n              active: true\n            }\n          });\n        }\n      }), switchMap(() => {\n        return cartSelector$;\n      }), filter(cartState => !cartState.loading), filter(cartState => cartState.success || cartState.error),\n      // wait for active cart id to point to code/guid to avoid some work on temp cart entity\n      withLatestFrom(this.activeCartId$), filter(([cartState, cartId]) => !this.isCartCreating(cartState, cartId)), map(([cartState]) => cartState), filter(cartState => !this.isEmpty(cartState.value)), take(1));\n    }\n    /**\n     * Add entry to active cart\n     *\n     * @param productCode\n     * @param quantity\n     */\n    addEntry(productCode, quantity) {\n      // TODO(#13645): Support multiple, simultaneous invocation of this function, when cart is not loaded/created\n      this.requireLoadedCart().pipe(withLatestFrom(this.userIdService.getUserId())).subscribe(([cartState, userId]) => {\n        this.multiCartService.addEntry(userId, getCartIdByUserId(cartState.value, userId), productCode, quantity);\n      });\n    }\n    /**\n     * Remove entry\n     *\n     * @param entry\n     */\n    removeEntry(entry) {\n      this.activeCartId$.pipe(withLatestFrom(this.userIdService.getUserId()), take(1)).subscribe(([cartId, userId]) => {\n        this.multiCartService.removeEntry(userId, cartId, entry.entryNumber);\n      });\n    }\n    /**\n     * Update entry\n     *\n     * @param entryNumber\n     * @param quantity\n     */\n    updateEntry(entryNumber, quantity) {\n      this.activeCartId$.pipe(withLatestFrom(this.userIdService.getUserId()), take(1)).subscribe(([cartId, userId]) => {\n        this.multiCartService.updateEntry(userId, cartId, entryNumber, quantity);\n      });\n    }\n    /**\n     * Returns cart entry\n     *\n     * @param productCode\n     */\n    getEntry(productCode) {\n      return this.activeCartId$.pipe(switchMap(cartId => this.multiCartService.getEntry(cartId, productCode)), distinctUntilChanged());\n    }\n    /**\n     * Assign email to cart\n     *\n     * @param email\n     */\n    addEmail(email) {\n      this.activeCartId$.pipe(withLatestFrom(this.userIdService.getUserId()), take(1)).subscribe(([cartId, userId]) => {\n        this.multiCartService.assignEmail(cartId, userId, email);\n      });\n    }\n    /**\n     * Get assigned user to cart\n     */\n    getAssignedUser() {\n      return this.getActive().pipe(map(cart => cart.user));\n    }\n    // TODO: Make cart required param in 4.0 and drop the subscribe/unsubscribe.\n    /**\n     * Returns true for guest cart\n     */\n    isGuestCart(cart) {\n      if (!cart) {\n        this.activeCart$.subscribe(activeCart => cart = activeCart).unsubscribe();\n      }\n      const cartUser = cart === null || cart === void 0 ? void 0 : cart.user;\n      return cartUser && (cartUser.name === OCC_USER_ID_GUEST || this.isEmail(cartUser.uid.split('|').slice(1).join('|')));\n    }\n    /**\n     * Add multiple entries to a cart\n     *\n     * @param cartEntries : list of entries to add (OrderEntry[])\n     */\n    addEntries(cartEntries) {\n      const entriesToAdd = cartEntries.map(entry => {\n        var _a;\n        return {\n          productCode: (_a = entry.product) === null || _a === void 0 ? void 0 : _a.code,\n          quantity: entry.quantity\n        };\n      });\n      this.requireLoadedCart().pipe(withLatestFrom(this.userIdService.getUserId())).subscribe(([cartState, userId]) => {\n        if (cartState.value) {\n          this.multiCartService.addEntries(userId, getCartIdByUserId(cartState.value, userId), entriesToAdd);\n        }\n      });\n    }\n    /**\n     * Indicates if given string is matching email pattern\n     */\n    isEmail(str) {\n      if (str) {\n        return str.match(EMAIL_PATTERN) ? true : false;\n      }\n      return false;\n    }\n    // TODO: Remove once backend is updated\n    /**\n     * Temporary method to merge guest cart with user cart because of backend limitation\n     * This is for an edge case\n     */\n    guestCartMerge(cartId) {\n      let cartEntries;\n      this.getEntries().pipe(take(1)).subscribe(entries => {\n        cartEntries = entries;\n        this.multiCartService.deleteCart(cartId, OCC_USER_ID_ANONYMOUS);\n        this.addEntriesGuestMerge(cartEntries);\n      });\n    }\n    /**\n     * Indicates if given cart is empty.\n     * Returns true is cart is undefined, null or is an empty object.\n     */\n    isEmpty(cart) {\n      return !cart || typeof cart === 'object' && Object.keys(cart).length === 0;\n    }\n    /**\n     * Indicates if a given user is logged in on account different than preceding user account\n     */\n    isJustLoggedIn(userId, previousUserId) {\n      return userId !== OCC_USER_ID_ANONYMOUS &&\n      // not logged out\n      previousUserId !== userId // *just* logged in / switched to ASM emulation\n      ;\n    }\n    /**\n     * Reloads active cart\n     */\n    reloadActiveCart() {\n      combineLatest([this.getActiveCartId(), this.userIdService.takeUserId()]).pipe(take(1), map(([cartId, userId]) => {\n        this.multiCartService.loadCart({\n          cartId,\n          userId\n        });\n      })).subscribe();\n    }\n  }\n  ActiveCartService.ɵfac = function ActiveCartService_Factory(t) {\n    return new (t || ActiveCartService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(MultiCartService), i0.ɵɵinject(UserIdService));\n  };\n  ActiveCartService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ActiveCartService,\n    factory: ActiveCartService.ɵfac,\n    providedIn: 'root'\n  });\n  return ActiveCartService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Registers events for the active cart\n */\nlet CartEventBuilder = /*#__PURE__*/(() => {\n  class CartEventBuilder {\n    constructor(actionsSubject, event, activeCartService) {\n      this.actionsSubject = actionsSubject;\n      this.event = event;\n      this.activeCartService = activeCartService;\n      this.register();\n    }\n    /**\n     * Registers events for the active cart\n     */\n    register() {\n      this.registerAddEntry();\n      this.registerRemoveEntry();\n      this.registerUpdateEntry();\n    }\n    /**\n     * Register events for adding entry to the active cart\n     */\n    registerAddEntry() {\n      this.registerMapped({\n        action: CART_ADD_ENTRY,\n        event: CartAddEntryEvent\n      });\n      this.registerMapped({\n        action: CART_ADD_ENTRY_SUCCESS,\n        event: CartAddEntrySuccessEvent\n      });\n      this.registerMapped({\n        action: CART_ADD_ENTRY_FAIL,\n        event: CartAddEntryFailEvent\n      });\n    }\n    registerRemoveEntry() {\n      this.registerMapped({\n        action: CART_REMOVE_ENTRY_SUCCESS,\n        event: CartRemoveEntrySuccessEvent\n      });\n      this.registerMapped({\n        action: CART_REMOVE_ENTRY_FAIL,\n        event: CartRemoveEntryFailEvent\n      });\n    }\n    registerUpdateEntry() {\n      this.registerMapped({\n        action: CART_UPDATE_ENTRY_SUCCESS,\n        event: CartUpdateEntrySuccessEvent\n      });\n      this.registerMapped({\n        action: CART_UPDATE_ENTRY_FAIL,\n        event: CartUpdateEntryFailEvent\n      });\n    }\n    /**\n     * Registers a stream of target events mapped from the source actions that contain the cart id equal to the active cart id.\n     *\n     * @param mapping mapping declaration - from `action` string type to `event` class type\n     *   (an with optional `factory` function - by default `action.payload` will be assigned to the properties of the event instance).\n     */\n    registerMapped(mapping) {\n      const eventStream$ = this.getAction(mapping.action).pipe(switchMap(action => {\n        // SwitchMap was used instead of withLatestFrom, because we only want to subscribe to cart stream when action is dispatched.\n        // Using withLatestFrom would trigger subscription to cart observables on event subscription and that causes side effects,\n        // such as loading cart when we don't yet need it.\n        return of(action).pipe(withLatestFrom(this.activeCartService.getActive(), this.activeCartService.getActiveCartId()));\n      }), filter(([action, _activeCart, activeCartId]) => action.payload['cartId'] === activeCartId), map(([action, activeCart]) => createFrom(mapping.event, Object.assign(Object.assign({}, action.payload), {\n        cartCode: activeCart.code,\n        entry: action.payload.entry ? action.payload.entry : activeCart.entries[Number(action.payload.entryNumber)]\n      }))));\n      return this.event.register(mapping.event, eventStream$);\n    }\n    /**\n     * Returns a stream of actions only of a given type(s)\n     *\n     * @param actionType type(s) of actions\n     */\n    getAction(actionType) {\n      return this.actionsSubject.pipe(ofType(...[].concat(actionType)));\n    }\n  }\n  CartEventBuilder.ɵfac = function CartEventBuilder_Factory(t) {\n    return new (t || CartEventBuilder)(i0.ɵɵinject(i1$2.ActionsSubject), i0.ɵɵinject(EventService), i0.ɵɵinject(ActiveCartService));\n  };\n  CartEventBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartEventBuilder,\n    factory: CartEventBuilder.ɵfac,\n    providedIn: 'root'\n  });\n  return CartEventBuilder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartEventModule = /*#__PURE__*/(() => {\n  class CartEventModule {\n    constructor(_CartEventBuilder) {}\n  }\n  CartEventModule.ɵfac = function CartEventModule_Factory(t) {\n    return new (t || CartEventModule)(i0.ɵɵinject(CartEventBuilder));\n  };\n  CartEventModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CartEventModule\n  });\n  CartEventModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return CartEventModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MultiCartEffects = /*#__PURE__*/(() => {\n  class MultiCartEffects {\n    constructor(actions$) {\n      this.actions$ = actions$;\n      this.setTempCart$ = this.actions$.pipe(ofType(SET_TEMP_CART), map(action => {\n        return new RemoveCart({\n          cartId: action.payload.tempCartId\n        });\n      }));\n      // TODO(#7241): Remove when we drop ADD_VOUCHER process and we sort out checkout and cart dependencies\n      this.processesIncrement$ = this.actions$.pipe(ofType(CART_ADD_VOUCHER), map(action => action.payload), map(payload => new CartProcessesIncrement(payload.cartId)));\n    }\n  }\n  MultiCartEffects.ɵfac = function MultiCartEffects_Factory(t) {\n    return new (t || MultiCartEffects)(i0.ɵɵinject(i1$4.Actions));\n  };\n  MultiCartEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MultiCartEffects,\n    factory: MultiCartEffects.ɵfac\n  });\n  __decorate([Effect()], MultiCartEffects.prototype, \"setTempCart$\", void 0);\n  __decorate([Effect()], MultiCartEffects.prototype, \"processesIncrement$\", void 0);\n  return MultiCartEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$3 = [CartEffects, CartEntryEffects, CartVoucherEffects, WishListEffects, MultiCartEffects];\nlet MultiCartStoreModule = /*#__PURE__*/(() => {\n  class MultiCartStoreModule {}\n  MultiCartStoreModule.ɵfac = function MultiCartStoreModule_Factory(t) {\n    return new (t || MultiCartStoreModule)();\n  };\n  MultiCartStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MultiCartStoreModule\n  });\n  MultiCartStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [multiCartReducerProvider],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(MULTI_CART_FEATURE, multiCartReducerToken, {\n      metaReducers: multiCartMetaReducers\n    }), EffectsModule.forFeature(effects$3)]]\n  });\n  return MultiCartStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartModule = /*#__PURE__*/(() => {\n  class CartModule {\n    static forRoot() {\n      return {\n        ngModule: CartModule\n      };\n    }\n  }\n  CartModule.ɵfac = function CartModule_Factory(t) {\n    return new (t || CartModule)();\n  };\n  CartModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CartModule\n  });\n  CartModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[MultiCartStoreModule, CartEventModule, CartPersistenceModule.forRoot()]]\n  });\n  return CartModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartConfig = /*#__PURE__*/(() => {\n  class CartConfig {}\n  CartConfig.ɵfac = function CartConfig_Factory(t) {\n    return new (t || CartConfig)();\n  };\n  CartConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartConfig,\n    factory: function CartConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || CartConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return CartConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CART_NORMALIZER = new InjectionToken('CartNormalizer');\nconst CART_MODIFICATION_NORMALIZER = new InjectionToken('CartModificationNormalizer');\nconst SAVE_CART_NORMALIZER = new InjectionToken('SaveCartNormalizer');\nconst CART_VOUCHER_NORMALIZER = new InjectionToken('CartVoucherNormalizer');\nconst CART_VALIDATION_NORMALIZER = new InjectionToken('CartValidationNormalizer');\nclass CartValidationAdapter {}\nlet CartValidationConnector = /*#__PURE__*/(() => {\n  class CartValidationConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    validate(cartId, userId) {\n      return this.adapter.validate(cartId, userId);\n    }\n  }\n  CartValidationConnector.ɵfac = function CartValidationConnector_Factory(t) {\n    return new (t || CartValidationConnector)(i0.ɵɵinject(CartValidationAdapter));\n  };\n  CartValidationConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartValidationConnector,\n    factory: CartValidationConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CartValidationConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartVoucherService = /*#__PURE__*/(() => {\n  class CartVoucherService {\n    constructor(store, activeCartService, userIdService) {\n      this.store = store;\n      this.activeCartService = activeCartService;\n      this.userIdService = userIdService;\n    }\n    addVoucher(voucherId, cartId) {\n      this.combineUserAndCartId(cartId).subscribe(([occUserId, cartIdentifier]) => this.store.dispatch(new CartAddVoucher({\n        userId: occUserId,\n        cartId: cartIdentifier,\n        voucherId: voucherId\n      })));\n    }\n    removeVoucher(voucherId, cartId) {\n      this.combineUserAndCartId(cartId).subscribe(([occUserId, cartIdentifier]) => this.store.dispatch(new CartRemoveVoucher({\n        userId: occUserId,\n        cartId: cartIdentifier,\n        voucherId: voucherId\n      })));\n    }\n    // TODO(#7241): Remove when switching to event system for add voucher\n    /**\n     * Get add voucher process error flag\n     * @deprecated since 2.0\n     */\n    getAddVoucherResultError() {\n      return this.store.pipe(select(getProcessErrorFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    // TODO(#7241): Remove when switching to event system for add voucher\n    /**\n     * Get add voucher process success flag\n     * @deprecated since 2.0\n     */\n    getAddVoucherResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    // TODO(#7241): Remove when switching to event system for add voucher\n    /**\n     * Get add voucher process loading flag\n     * @deprecated since 2.0\n     */\n    getAddVoucherResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(ADD_VOUCHER_PROCESS_ID)));\n    }\n    // TODO(#7241): Remove when switching to event system for add voucher\n    /**\n     * Reset add voucher process\n     * @deprecated since 2.0\n     */\n    resetAddVoucherProcessingState() {\n      this.store.dispatch(new CartResetAddVoucher());\n    }\n    combineUserAndCartId(cartId) {\n      if (cartId) {\n        return this.userIdService.getUserId().pipe(take(1), map(userId => [userId, cartId]));\n      } else {\n        return combineLatest([this.userIdService.getUserId(), this.activeCartService.getActiveCartId()]).pipe(take(1));\n      }\n    }\n  }\n  CartVoucherService.ɵfac = function CartVoucherService_Factory(t) {\n    return new (t || CartVoucherService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(ActiveCartService), i0.ɵɵinject(UserIdService));\n  };\n  CartVoucherService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartVoucherService,\n    factory: CartVoucherService.ɵfac,\n    providedIn: 'root'\n  });\n  return CartVoucherService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass UserAccountFacadeTransitionalToken {}\nclass UserProfileFacadeTransitionalToken {}\nlet UserService = /*#__PURE__*/(() => {\n  class UserService {\n    constructor(store, userIdService,\n    // TODO: Remove transitional tokens in 4.0 with #11607\n    userAccountFacade, userProfileFacade) {\n      this.store = store;\n      this.userIdService = userIdService;\n      this.userAccountFacade = userAccountFacade;\n      this.userProfileFacade = userProfileFacade;\n    }\n    /**\n     * Returns a user.\n     *\n     * @deprecated since 3.2, use `UserAccountFacade.get()` from `@spartacus/user` package.\n     */\n    get() {\n      if (this.userAccountFacade) {\n        return this.userAccountFacade.get();\n      }\n      throw Error('Cannot get a user. Install `@spartacus/user` library which provides required services.');\n    }\n    /**\n     * Returns titles.\n     *\n     * @deprecated since 3.2, use `UserProfileFacade.getTitles()` from `@spartacus/user` package.\n     */\n    getTitles() {\n      if (this.userProfileFacade) {\n        return this.userProfileFacade.getTitles();\n      }\n      throw Error('Cannot get a titles. Install `@spartacus/user` library which provides required services.');\n    }\n  }\n  UserService.ɵfac = function UserService_Factory(t) {\n    return new (t || UserService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService), i0.ɵɵinject(UserAccountFacadeTransitionalToken, 8), i0.ɵɵinject(UserProfileFacadeTransitionalToken, 8));\n  };\n  UserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserService,\n    factory: UserService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartConfigService = /*#__PURE__*/(() => {\n  class CartConfigService {\n    constructor(config) {\n      this.config = config;\n    }\n    isSelectiveCartEnabled() {\n      var _a, _b, _c;\n      return Boolean((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.cart) === null || _b === void 0 ? void 0 : _b.selectiveCart) === null || _c === void 0 ? void 0 : _c.enabled);\n    }\n    isCartValidationEnabled() {\n      var _a, _b, _c;\n      return Boolean((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.cart) === null || _b === void 0 ? void 0 : _b.validation) === null || _c === void 0 ? void 0 : _c.enabled);\n    }\n  }\n  CartConfigService.ɵfac = function CartConfigService_Factory(t) {\n    return new (t || CartConfigService)(i0.ɵɵinject(CartConfig));\n  };\n  CartConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartConfigService,\n    factory: CartConfigService.ɵfac,\n    providedIn: 'root'\n  });\n  return CartConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SelectiveCartService = /*#__PURE__*/(() => {\n  class SelectiveCartService {\n    constructor(store, userService, multiCartService, baseSiteService, cartConfigService, userIdService) {\n      this.store = store;\n      this.userService = userService;\n      this.multiCartService = multiCartService;\n      this.baseSiteService = baseSiteService;\n      this.cartConfigService = cartConfigService;\n      this.userIdService = userIdService;\n      this.cartId$ = new BehaviorSubject(undefined);\n      this.PREVIOUS_USER_ID_INITIAL_VALUE = 'PREVIOUS_USER_ID_INITIAL_VALUE';\n      this.previousUserId = this.PREVIOUS_USER_ID_INITIAL_VALUE;\n      this.cartSelector$ = this.cartId$.pipe(switchMap(cartId => {\n        this.cartId = cartId;\n        return this.multiCartService.getCartEntity(cartId);\n      }));\n      combineLatest([this.userService.get(), this.baseSiteService.getActive()]).subscribe(([user, activeBaseSite]) => {\n        if (user && user.customerId && activeBaseSite) {\n          this.customerId = user.customerId;\n          this.cartId$.next(`selectivecart${activeBaseSite}${this.customerId}`);\n        } else if (user && !user.customerId) {\n          this.cartId$.next(undefined);\n        }\n      });\n      this.userIdService.getUserId().subscribe(userId => {\n        this.userId = userId;\n        if (this.isJustLoggedIn(userId)) {\n          this.load();\n        }\n        this.previousUserId = userId;\n      });\n      this.selectiveCart$ = this.cartSelector$.pipe(map(cartEntity => {\n        return {\n          cart: cartEntity.value,\n          loading: cartEntity.loading,\n          loaded: (cartEntity.error || cartEntity.success) && !cartEntity.loading\n        };\n      }), filter(({\n        loading\n      }) => !loading), tap(({\n        cart,\n        loaded\n      }) => {\n        if (this.cartId && this.isEmpty(cart) && !loaded) {\n          this.load();\n        }\n      }), map(({\n        cart\n      }) => cart ? cart : {}), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    getCart() {\n      return this.selectiveCart$;\n    }\n    getEntries() {\n      return this.multiCartService.getEntries(this.cartId);\n    }\n    /**\n     * Returns true when selective cart is stable (not loading and not pending processes on cart)\n     */\n    isStable() {\n      return this.cartId$.pipe(switchMap(cartId => this.multiCartService.isStable(cartId)));\n    }\n    /**\n     * Loads logged user's selective cart\n     */\n    load() {\n      if (this.isLoggedIn(this.userId) && this.cartId) {\n        this.multiCartService.loadCart({\n          userId: this.userId,\n          cartId: this.cartId\n        });\n      }\n    }\n    addEntry(productCode, quantity) {\n      let loadAttempted = false;\n      this.cartSelector$.pipe(filter(() => !loadAttempted), switchMap(cartState => {\n        if (this.isEmpty(cartState.value) && !cartState.loading) {\n          loadAttempted = true;\n          this.load();\n        }\n        return of(cartState);\n      }), filter(cartState => !this.isEmpty(cartState.value)), take(1)).subscribe(() => {\n        this.multiCartService.addEntry(this.userId, this.cartId, productCode, quantity);\n      });\n    }\n    removeEntry(entry) {\n      this.multiCartService.removeEntry(this.userId, this.cartId, entry.entryNumber);\n    }\n    updateEntry(entryNumber, quantity) {\n      this.multiCartService.updateEntry(this.userId, this.cartId, entryNumber, quantity);\n    }\n    getEntry(productCode) {\n      return this.multiCartService.getEntry(this.cartId, productCode);\n    }\n    /**\n     * Indicates if selectiveCart feature is enabled based on cart configuration.\n     */\n    isEnabled() {\n      return this.cartConfigService.isSelectiveCartEnabled();\n    }\n    /**\n     * Indicates if given cart is empty.\n     * Returns true is cart is undefined, null or is an empty object.\n     */\n    isEmpty(cart) {\n      return !cart || typeof cart === 'object' && Object.keys(cart).length === 0;\n    }\n    /**\n     * Indicates if a given user is logged in on account different than preceding user account\n     */\n    isJustLoggedIn(userId) {\n      return this.isLoggedIn(userId) && this.previousUserId !== userId &&\n      // *just* logged in\n      this.previousUserId !== this.PREVIOUS_USER_ID_INITIAL_VALUE // not app initialization\n      ;\n    }\n    /**\n     * Indicates if given user is logged in\n     */\n    isLoggedIn(userId) {\n      return typeof userId !== 'undefined' && userId !== OCC_USER_ID_ANONYMOUS;\n    }\n  }\n  SelectiveCartService.ɵfac = function SelectiveCartService_Factory(t) {\n    return new (t || SelectiveCartService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserService), i0.ɵɵinject(MultiCartService), i0.ɵɵinject(BaseSiteService), i0.ɵɵinject(CartConfigService), i0.ɵɵinject(UserIdService));\n  };\n  SelectiveCartService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectiveCartService,\n    factory: SelectiveCartService.ɵfac,\n    providedIn: 'root'\n  });\n  return SelectiveCartService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet WishListService = /*#__PURE__*/(() => {\n  class WishListService {\n    constructor(store, userService, multiCartService, userIdService) {\n      this.store = store;\n      this.userService = userService;\n      this.multiCartService = multiCartService;\n      this.userIdService = userIdService;\n    }\n    createWishList(userId, name, description) {\n      this.store.dispatch(new CreateWishList({\n        userId,\n        name,\n        description\n      }));\n    }\n    getWishList() {\n      return combineLatest([this.getWishListId(), this.userService.get(), this.userIdService.getUserId()]).pipe(distinctUntilChanged(), tap(([wishListId, user, userId]) => {\n        if (!Boolean(wishListId) && userId !== OCC_USER_ID_ANONYMOUS && Boolean(user) && Boolean(user.customerId)) {\n          this.loadWishList(userId, user.customerId);\n        }\n      }), filter(([wishListId]) => Boolean(wishListId)), switchMap(([wishListId]) => this.multiCartService.getCart(wishListId)));\n    }\n    loadWishList(userId, customerId) {\n      this.store.dispatch(new LoadWishList({\n        userId,\n        customerId,\n        tempCartId: getWishlistName(customerId)\n      }));\n    }\n    addEntry(productCode) {\n      this.getWishListId().pipe(distinctUntilChanged(), withLatestFrom(this.userIdService.getUserId(), this.userService.get()), tap(([wishListId, userId, user]) => {\n        if (!Boolean(wishListId) && Boolean(user) && Boolean(user.customerId)) {\n          this.loadWishList(userId, user.customerId);\n        }\n      }), filter(([wishListId]) => Boolean(wishListId)), take(1)).subscribe(([wishListId, userId]) => this.multiCartService.addEntry(userId, wishListId, productCode, 1));\n    }\n    removeEntry(entry) {\n      this.getWishListId().pipe(distinctUntilChanged(), withLatestFrom(this.userIdService.getUserId(), this.userService.get()), tap(([wishListId, userId, user]) => {\n        if (!Boolean(wishListId) && Boolean(user) && Boolean(user.customerId)) {\n          this.loadWishList(userId, user.customerId);\n        }\n      }), filter(([wishListId]) => Boolean(wishListId)), take(1)).subscribe(([wishListId, userId]) => this.multiCartService.removeEntry(userId, wishListId, entry.entryNumber));\n    }\n    getWishListLoading() {\n      return this.getWishListId().pipe(switchMap(wishListId => this.multiCartService.isStable(wishListId).pipe(map(stable => !stable))));\n    }\n    getWishListId() {\n      return this.store.pipe(select(getWishListId));\n    }\n  }\n  WishListService.ɵfac = function WishListService_Factory(t) {\n    return new (t || WishListService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserService), i0.ɵɵinject(MultiCartService), i0.ɵɵinject(UserIdService));\n  };\n  WishListService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WishListService,\n    factory: WishListService.ɵfac,\n    providedIn: 'root'\n  });\n  return WishListService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass Command {}\nvar CommandStrategy = /*#__PURE__*/(() => {\n  (function (CommandStrategy) {\n    CommandStrategy[CommandStrategy[\"Parallel\"] = 0] = \"Parallel\";\n    CommandStrategy[CommandStrategy[\"Queue\"] = 1] = \"Queue\";\n    CommandStrategy[CommandStrategy[\"CancelPrevious\"] = 2] = \"CancelPrevious\";\n    CommandStrategy[CommandStrategy[\"ErrorPrevious\"] = 3] = \"ErrorPrevious\";\n    // SkipIfOngoing,\n    // ErrorIfOngoing\n  })(CommandStrategy || (CommandStrategy = {}));\n  return CommandStrategy;\n})();\nlet CommandService = /*#__PURE__*/(() => {\n  class CommandService {\n    constructor() {\n      this.subscriptions = new Subscription();\n    }\n    create(commandFactory, options) {\n      const commands$ = new Subject();\n      const results$ = new Subject();\n      let process$;\n      switch (options === null || options === void 0 ? void 0 : options.strategy) {\n        case CommandStrategy.CancelPrevious:\n        case CommandStrategy.ErrorPrevious:\n          process$ = zip(commands$, results$).pipe(switchMap(([cmd, notifier$]) => commandFactory(cmd).pipe(tap(notifier$), finalize(() => options.strategy === CommandStrategy.CancelPrevious ? notifier$.complete() : notifier$.error(new Error('Canceled by next command'))))), retry());\n          break;\n        case CommandStrategy.Parallel:\n          process$ = zip(commands$, results$).pipe(mergeMap(([cmd, notifier$]) => commandFactory(cmd).pipe(tap(notifier$))), retry());\n          break;\n        case CommandStrategy.Queue:\n        default:\n          process$ = zip(commands$, results$).pipe(concatMap(([cmd, notifier$]) => commandFactory(cmd).pipe(tap(notifier$))), retry());\n          break;\n      }\n      this.subscriptions.add(process$.subscribe());\n      const command = new class extends Command {\n        constructor() {\n          super(...arguments);\n          this.execute = parameters => {\n            const result$ = new ReplaySubject();\n            results$.next(result$);\n            commands$.next(parameters);\n            return result$;\n          };\n        }\n      }();\n      return command;\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  CommandService.ɵfac = function CommandService_Factory(t) {\n    return new (t || CommandService)();\n  };\n  CommandService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CommandService,\n    factory: CommandService.ɵfac,\n    providedIn: 'root'\n  });\n  return CommandService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartValidationService = /*#__PURE__*/(() => {\n  class CartValidationService {\n    constructor(cartValidationConnector, command, userIdService, activeCartService) {\n      this.cartValidationConnector = cartValidationConnector;\n      this.command = command;\n      this.userIdService = userIdService;\n      this.activeCartService = activeCartService;\n      this.validateCartCommand = this.command.create(() => combineLatest([this.activeCartService.getActiveCartId(), this.userIdService.takeUserId(), this.activeCartService.isStable()]).pipe(filter(([_, __, loaded]) => loaded), take(1), switchMap(([cartId, userId]) => this.cartValidationConnector.validate(cartId, userId))), {\n        strategy: CommandStrategy.CancelPrevious\n      });\n    }\n    /**\n     * Returns cart modification list.\n     *\n     * @param cartId\n     * @param userId\n     */\n    validateCart() {\n      return this.validateCartCommand.execute();\n    }\n  }\n  CartValidationService.ɵfac = function CartValidationService_Factory(t) {\n    return new (t || CartValidationService)(i0.ɵɵinject(CartValidationConnector), i0.ɵɵinject(CommandService), i0.ɵɵinject(UserIdService), i0.ɵɵinject(ActiveCartService));\n  };\n  CartValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CartValidationService,\n    factory: CartValidationService.ɵfac,\n    providedIn: 'root'\n  });\n  return CartValidationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ORDER_NORMALIZER = new InjectionToken('OrderNormalizer');\nconst POINT_OF_SERVICE_NORMALIZER = new InjectionToken('PointOfServiceNormalizer');\nconst PAYMENT_DETAILS_NORMALIZER = new InjectionToken('PaymentDetailsNormalizer');\nconst REPLENISHMENT_ORDER_NORMALIZER = new InjectionToken('ReplenishmentOrderNormalizer');\nconst defaultCmsModuleConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        component: 'cms/components/${id}',\n        components: 'cms/components',\n        pages: 'cms/pages',\n        page: 'cms/pages/${id}'\n      }\n    }\n  },\n  cmsComponents: {}\n};\nconst CMS_FEATURE = 'cms';\nconst NAVIGATION_DETAIL_ENTITY = '[Cms] Navigation Entity';\nconst COMPONENT_ENTITY = '[Cms] Component Entity';\nconst LOAD_CMS_COMPONENT = '[Cms] Load Component';\nconst LOAD_CMS_COMPONENT_FAIL = '[Cms] Load Component Fail';\nconst LOAD_CMS_COMPONENT_SUCCESS = '[Cms] Load Component Success';\nconst CMS_GET_COMPONENT_FROM_PAGE = '[Cms] Get Component from Page';\nclass LoadCmsComponent extends EntityLoadAction {\n  constructor(payload) {\n    super(COMPONENT_ENTITY, payload.uid);\n    this.payload = payload;\n    this.type = LOAD_CMS_COMPONENT;\n  }\n}\nclass LoadCmsComponentFail extends EntityFailAction {\n  constructor(payload) {\n    super(COMPONENT_ENTITY, payload.uid, payload.error);\n    this.payload = payload;\n    this.type = LOAD_CMS_COMPONENT_FAIL;\n  }\n}\nclass LoadCmsComponentSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(COMPONENT_ENTITY, payload.uid || payload.component.uid || '');\n    this.payload = payload;\n    this.type = LOAD_CMS_COMPONENT_SUCCESS;\n  }\n}\nclass CmsGetComponentFromPage extends EntitySuccessAction {\n  constructor(payload) {\n    super(COMPONENT_ENTITY, [].concat(payload).map(cmp => cmp.component.uid));\n    this.payload = payload;\n    this.type = CMS_GET_COMPONENT_FROM_PAGE;\n  }\n}\nconst LOAD_CMS_NAVIGATION_ITEMS = '[Cms] Load NavigationEntry items';\nconst LOAD_CMS_NAVIGATION_ITEMS_FAIL = '[Cms] Load NavigationEntry items Fail';\nconst LOAD_CMS_NAVIGATION_ITEMS_SUCCESS = '[Cms] Load NavigationEntry items Success';\nclass LoadCmsNavigationItems extends EntityLoadAction {\n  constructor(payload) {\n    super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);\n    this.payload = payload;\n    this.type = LOAD_CMS_NAVIGATION_ITEMS;\n  }\n}\nclass LoadCmsNavigationItemsFail extends EntityFailAction {\n  constructor(nodeId, payload) {\n    super(NAVIGATION_DETAIL_ENTITY, nodeId, payload);\n    this.payload = payload;\n    this.type = LOAD_CMS_NAVIGATION_ITEMS_FAIL;\n  }\n}\nclass LoadCmsNavigationItemsSuccess extends EntitySuccessAction {\n  constructor(payload) {\n    super(NAVIGATION_DETAIL_ENTITY, payload.nodeId);\n    this.payload = payload;\n    this.type = LOAD_CMS_NAVIGATION_ITEMS_SUCCESS;\n  }\n}\nconst LOAD_CMS_PAGE_DATA = '[Cms] Load Page Data';\nconst LOAD_CMS_PAGE_DATA_FAIL = '[Cms] Load Page Data Fail';\nconst LOAD_CMS_PAGE_DATA_SUCCESS = '[Cms] Load Page Data Success';\nconst CMS_SET_PAGE_SUCCESS_INDEX = '[Cms] Set Page Success Index';\nconst CMS_SET_PAGE_FAIL_INDEX = '[Cms] Set Page Fail Index';\nclass LoadCmsPageData extends EntityLoadAction {\n  constructor(payload) {\n    super(payload.type, payload.id);\n    this.payload = payload;\n    this.type = LOAD_CMS_PAGE_DATA;\n  }\n}\nclass LoadCmsPageDataFail extends EntityFailAction {\n  constructor(pageContext, error) {\n    super(pageContext.type, pageContext.id, error);\n    this.type = LOAD_CMS_PAGE_DATA_FAIL;\n  }\n}\nclass LoadCmsPageDataSuccess extends EntitySuccessAction {\n  constructor(pageContext, payload) {\n    super(pageContext.type, pageContext.id, payload);\n    this.type = LOAD_CMS_PAGE_DATA_SUCCESS;\n  }\n}\nclass CmsSetPageSuccessIndex extends EntitySuccessAction {\n  constructor(pageContext, payload) {\n    super(pageContext.type, pageContext.id, payload);\n    this.type = CMS_SET_PAGE_SUCCESS_INDEX;\n  }\n}\nclass CmsSetPageFailIndex extends EntityFailAction {\n  constructor(pageContext, payload) {\n    super(pageContext.type, pageContext.id);\n    this.payload = payload;\n    this.type = CMS_SET_PAGE_FAIL_INDEX;\n  }\n}\nvar cmsGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_CMS_COMPONENT: LOAD_CMS_COMPONENT,\n  LOAD_CMS_COMPONENT_FAIL: LOAD_CMS_COMPONENT_FAIL,\n  LOAD_CMS_COMPONENT_SUCCESS: LOAD_CMS_COMPONENT_SUCCESS,\n  CMS_GET_COMPONENT_FROM_PAGE: CMS_GET_COMPONENT_FROM_PAGE,\n  LoadCmsComponent: LoadCmsComponent,\n  LoadCmsComponentFail: LoadCmsComponentFail,\n  LoadCmsComponentSuccess: LoadCmsComponentSuccess,\n  CmsGetComponentFromPage: CmsGetComponentFromPage,\n  LOAD_CMS_NAVIGATION_ITEMS: LOAD_CMS_NAVIGATION_ITEMS,\n  LOAD_CMS_NAVIGATION_ITEMS_FAIL: LOAD_CMS_NAVIGATION_ITEMS_FAIL,\n  LOAD_CMS_NAVIGATION_ITEMS_SUCCESS: LOAD_CMS_NAVIGATION_ITEMS_SUCCESS,\n  LoadCmsNavigationItems: LoadCmsNavigationItems,\n  LoadCmsNavigationItemsFail: LoadCmsNavigationItemsFail,\n  LoadCmsNavigationItemsSuccess: LoadCmsNavigationItemsSuccess,\n  LOAD_CMS_PAGE_DATA: LOAD_CMS_PAGE_DATA,\n  LOAD_CMS_PAGE_DATA_FAIL: LOAD_CMS_PAGE_DATA_FAIL,\n  LOAD_CMS_PAGE_DATA_SUCCESS: LOAD_CMS_PAGE_DATA_SUCCESS,\n  CMS_SET_PAGE_SUCCESS_INDEX: CMS_SET_PAGE_SUCCESS_INDEX,\n  CMS_SET_PAGE_FAIL_INDEX: CMS_SET_PAGE_FAIL_INDEX,\n  LoadCmsPageData: LoadCmsPageData,\n  LoadCmsPageDataFail: LoadCmsPageDataFail,\n  LoadCmsPageDataSuccess: LoadCmsPageDataSuccess,\n  CmsSetPageSuccessIndex: CmsSetPageSuccessIndex,\n  CmsSetPageFailIndex: CmsSetPageFailIndex\n});\nconst getCmsState = createFeatureSelector(CMS_FEATURE);\nconst getComponentsState = createSelector(getCmsState, state => state.components);\nconst componentsContextSelectorFactory = uid => {\n  return createSelector(getComponentsState, componentsState => entitySelector(componentsState, uid));\n};\nconst componentsLoaderStateSelectorFactory = (uid, context) => {\n  return createSelector(componentsContextSelectorFactory(uid), componentsContext => componentsContext && componentsContext.pageContext && componentsContext.pageContext[context] || initialLoaderState);\n};\n/**\n * This selector will return:\n *   - true: component for this context exists\n *   - false: component for this context doesn't exist\n *   - undefined: if the exists status for component is unknown\n *\n * @param uid\n * @param context\n */\nconst componentsContextExistsSelectorFactory = (uid, context) => {\n  return createSelector(componentsLoaderStateSelectorFactory(uid, context), loaderState => loaderValueSelector(loaderState));\n};\nconst componentsDataSelectorFactory = uid => {\n  return createSelector(componentsContextSelectorFactory(uid), state => state ? state.component : undefined);\n};\n/**\n * This selector will return:\n *   - CmsComponent instance: if we have component data for specified context\n *   - null: if there is no component data for specified context\n *   - undefined: if status of component data for specified context is unknown\n *\n * @param uid\n * @param context\n */\nconst componentsSelectorFactory = (uid, context) => {\n  return createSelector(componentsDataSelectorFactory(uid), componentsContextExistsSelectorFactory(uid, context), (componentState, exists) => {\n    switch (exists) {\n      case true:\n        return componentState;\n      case false:\n        return null;\n      case undefined:\n        return undefined;\n    }\n  });\n};\nconst getNavigationEntryItemState = createSelector(getCmsState, state => state.navigation);\nconst getSelectedNavigationEntryItemState = nodeId => {\n  return createSelector(getNavigationEntryItemState, nodes => entityLoaderStateSelector(nodes, nodeId));\n};\nconst getNavigationEntryItems = nodeId => {\n  return createSelector(getSelectedNavigationEntryItemState(nodeId), itemState => loaderValueSelector(itemState));\n};\nconst getPageEntitiesSelector = state => state.pageData.entities;\nconst getIndexByType = (index, type) => {\n  switch (type) {\n    case PageType.CONTENT_PAGE:\n      {\n        return index.content;\n      }\n    case PageType.PRODUCT_PAGE:\n      {\n        return index.product;\n      }\n    case PageType.CATEGORY_PAGE:\n      {\n        return index.category;\n      }\n    case PageType.CATALOG_PAGE:\n      {\n        return index.catalog;\n      }\n  }\n  return {\n    entities: {}\n  };\n};\nconst getPageComponentTypesSelector = page => {\n  const componentTypes = new Set();\n  if (page && page.slots) {\n    for (const slot of Object.keys(page.slots)) {\n      for (const component of page.slots[slot].components || []) {\n        componentTypes.add(component.flexType);\n      }\n    }\n  }\n  return Array.from(componentTypes);\n};\nconst getPageState = createSelector(getCmsState, state => state.page);\nconst getPageStateIndex = createSelector(getPageState, page => page.index);\nconst getPageStateIndexEntityLoaderState = pageContext => createSelector(getPageStateIndex, index => getIndexByType(index, pageContext.type));\nconst getPageStateIndexLoaderState = pageContext => createSelector(getPageStateIndexEntityLoaderState(pageContext), indexState => entityLoaderStateSelector(indexState, pageContext.id));\nconst getPageStateIndexValue = pageContext => createSelector(getPageStateIndexLoaderState(pageContext), entity => loaderValueSelector(entity));\nconst getPageEntities = createSelector(getPageState, getPageEntitiesSelector);\nconst getPageData = pageContext => createSelector(getPageEntities, getPageStateIndexValue(pageContext), (entities, indexValue) => entities[indexValue]);\nconst getPageComponentTypes = pageContext => createSelector(getPageData(pageContext), pageData => getPageComponentTypesSelector(pageData));\nconst getCurrentSlotSelectorFactory = (pageContext, position) => {\n  return createSelector(getPageData(pageContext), entity => {\n    if (entity) {\n      return entity.slots[position] || {\n        components: []\n      };\n    }\n  });\n};\nvar cmsGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getComponentsState: getComponentsState,\n  componentsContextSelectorFactory: componentsContextSelectorFactory,\n  componentsLoaderStateSelectorFactory: componentsLoaderStateSelectorFactory,\n  componentsContextExistsSelectorFactory: componentsContextExistsSelectorFactory,\n  componentsDataSelectorFactory: componentsDataSelectorFactory,\n  componentsSelectorFactory: componentsSelectorFactory,\n  getCmsState: getCmsState,\n  getNavigationEntryItemState: getNavigationEntryItemState,\n  getSelectedNavigationEntryItemState: getSelectedNavigationEntryItemState,\n  getNavigationEntryItems: getNavigationEntryItems,\n  getPageState: getPageState,\n  getPageStateIndex: getPageStateIndex,\n  getPageStateIndexEntityLoaderState: getPageStateIndexEntityLoaderState,\n  getPageStateIndexLoaderState: getPageStateIndexLoaderState,\n  getPageStateIndexValue: getPageStateIndexValue,\n  getPageEntities: getPageEntities,\n  getPageData: getPageData,\n  getPageComponentTypes: getPageComponentTypes,\n  getCurrentSlotSelectorFactory: getCurrentSlotSelectorFactory\n});\nconst CURRENT_CONTEXT_KEY = 'current';\n/**\n *\n * Serializes the provided page context.\n * The pattern used for serialization is: `pageContext.type-pageContext.id`.\n *\n * @param pageContext to serialize\n * @param ignoreContentPageId if set to true, and the PageType is of type ContentPage, then the serialized page context will not contain the ID.\n * Otherwise, the page context if fully serialized.\n */\nfunction serializePageContext(pageContext, ignoreContentPageId) {\n  if (!pageContext) {\n    return CURRENT_CONTEXT_KEY;\n  }\n  if (ignoreContentPageId && pageContext.type === PageType.CONTENT_PAGE) {\n    return `${pageContext.type}`;\n  }\n  return `${pageContext.type}-${pageContext.id}`;\n}\nlet CmsService = /*#__PURE__*/(() => {\n  class CmsService {\n    constructor(store, routingService) {\n      this.store = store;\n      this.routingService = routingService;\n      this.components = {};\n    }\n    /**\n     * Get current CMS page data\n     */\n    getCurrentPage() {\n      return this.routingService.getPageContext().pipe(switchMap(pageContext => this.store.select(getPageData(pageContext))));\n    }\n    /**\n     * Get CMS component data by uid\n     *\n     * This method can be safely and optimally used to load multiple components data at the same time.\n     * Calling getComponentData multiple times for different components will always result in optimized\n     * back-end request: all components requested at the same time (in one event loop) will be loaded in one network call.\n     *\n     * In case the component data is not present, the method will load it.\n     * Otherwise, if the page context is not provided, the current page context from the router state will be used instead.\n     *\n     * @param uid CMS component uid\n     * @param pageContext if provided, it will be used to lookup the component data.\n     */\n    getComponentData(uid, pageContext) {\n      const context = serializePageContext(pageContext, true);\n      if (!this.components[uid]) {\n        // create the component data structure, if it doesn't already exist\n        this.components[uid] = {};\n      }\n      const component = this.components[uid];\n      if (!component[context]) {\n        // create the component data and assign it to the component's context\n        component[context] = this.createComponentData(uid, pageContext);\n      }\n      return component[context];\n    }\n    createComponentData(uid, pageContext) {\n      if (!pageContext) {\n        return this.routingService.getPageContext().pipe(filter(currentContext => !!currentContext), switchMap(currentContext => this.getComponentData(uid, currentContext)));\n      }\n      const context = serializePageContext(pageContext, true);\n      const loading$ = combineLatest([this.routingService.getNextPageContext(), this.store.pipe(select(componentsLoaderStateSelectorFactory(uid, context)))]).pipe(observeOn(queueScheduler), tap(([nextContext, loadingState]) => {\n        const attemptedLoad = loadingState.loading || loadingState.success || loadingState.error;\n        // if the requested context is the same as the one that's currently being navigated to\n        // (as it might already been triggered and might be available shortly from page data)\n        // TODO(issue:3649), TODO(issue:3668) - this optimization could be removed\n        const couldBeLoadedWithPageData = nextContext ? serializePageContext(nextContext, true) === context : false;\n        if (!attemptedLoad && !couldBeLoadedWithPageData) {\n          this.store.dispatch(new LoadCmsComponent({\n            uid,\n            pageContext\n          }));\n        }\n      }));\n      const component$ = this.store.pipe(select(componentsSelectorFactory(uid, context)), filter(isNotUndefined));\n      return using(() => loading$.subscribe(), () => component$).pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    /**\n     * Given the position, get the content slot data\n     * @param position : content slot position\n     */\n    getContentSlot(position) {\n      return this.routingService.getPageContext().pipe(switchMap(pageContext => this.store.pipe(select(getCurrentSlotSelectorFactory(pageContext, position)), filter(Boolean))));\n    }\n    /**\n     * Given navigation node uid, get items (with id and type) inside the navigation entries\n     * @param navigationNodeUid : uid of the navigation node\n     */\n    getNavigationEntryItems(navigationNodeUid) {\n      return this.store.pipe(select(getNavigationEntryItems(navigationNodeUid)));\n    }\n    /**\n     * Load navigation items data\n     * @param rootUid : the uid of the root navigation node\n     * @param itemList : list of items (with id and type)\n     */\n    loadNavigationItems(rootUid, itemList) {\n      this.store.dispatch(new LoadCmsNavigationItems({\n        nodeId: rootUid,\n        items: itemList\n      }));\n    }\n    /**\n     * Refresh the content of the latest cms page\n     */\n    refreshLatestPage() {\n      this.routingService.getPageContext().pipe(take(1)).subscribe(pageContext => this.store.dispatch(new LoadCmsPageData(pageContext)));\n    }\n    /**\n     * Refresh the cms page content by page Id\n     * @param pageId\n     */\n    refreshPageById(pageId) {\n      const pageContext = {\n        id: pageId\n      };\n      this.store.dispatch(new LoadCmsPageData(pageContext));\n    }\n    /**\n     * Refresh cms component's content\n     * @param uid component uid\n     * @param pageContext an optional parameter that enables the caller to specify for which context the component should be refreshed.\n     * If not specified, 'current' page context is used.\n     */\n    refreshComponent(uid, pageContext) {\n      this.store.dispatch(new LoadCmsComponent({\n        uid,\n        pageContext\n      }));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     * @param pageContext\n     */\n    getPageState(pageContext) {\n      return this.store.pipe(select(getPageData(pageContext)));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     * @param pageContext\n     */\n    getPageComponentTypes(pageContext) {\n      return this.store.pipe(select(getPageComponentTypes(pageContext)));\n    }\n    /**\n     * Given pageContext, return whether the CMS page data exists or not\n     * @param pageContext\n     */\n    hasPage(pageContext, forceReload = false) {\n      return this.store.pipe(select(getPageStateIndexLoaderState(pageContext)), tap(entity => {\n        const attemptedLoad = entity.loading || entity.success || entity.error;\n        const shouldReload = forceReload && !entity.loading;\n        if (!attemptedLoad || shouldReload) {\n          this.store.dispatch(new LoadCmsPageData(pageContext));\n          forceReload = false;\n        }\n      }), filter(entity => {\n        if (!entity.hasOwnProperty('value')) {\n          // if we have incomplete state from SSR failed load transfer state,\n          // we should wait for reload and actual value\n          return false;\n        }\n        return entity.success || entity.error && !entity.loading;\n      }), pluck('success'), catchError(() => of(false)));\n    }\n    /**\n     * Given pageContext, return the CMS page data\n     **/\n    getPage(pageContext, forceReload = false) {\n      return this.hasPage(pageContext, forceReload).pipe(switchMap(hasPage => hasPage ? this.getPageState(pageContext) : of(null)));\n    }\n    getPageIndex(pageContext) {\n      return this.store.pipe(select(getPageStateIndexValue(pageContext)));\n    }\n    setPageFailIndex(pageContext, value) {\n      this.store.dispatch(new CmsSetPageFailIndex(pageContext, value));\n    }\n  }\n  CmsService.ɵfac = function CmsService_Factory(t) {\n    return new (t || CmsService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(RoutingService));\n  };\n  CmsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsService,\n    factory: CmsService.ɵfac,\n    providedIn: 'root'\n  });\n  return CmsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultPageMetaConfig = {\n  pageMeta: {\n    resolvers: [{\n      property: 'title',\n      method: 'resolveTitle'\n    }, {\n      property: 'heading',\n      method: 'resolveHeading'\n    }, {\n      property: 'breadcrumbs',\n      method: 'resolveBreadcrumbs'\n    }, {\n      property: 'description',\n      method: 'resolveDescription',\n      disabledInCsr: true\n    }, {\n      property: 'image',\n      method: 'resolveImage',\n      disabledInCsr: true\n    }, {\n      property: 'robots',\n      method: 'resolveRobots',\n      disabledInCsr: true\n    }, {\n      property: 'canonicalUrl',\n      method: 'resolveCanonicalUrl',\n      disabledInCsr: true\n    }],\n    canonicalUrl: {\n      forceHttps: true,\n      forceWww: false,\n      removeQueryParams: true,\n      forceTrailingSlash: true\n    }\n  }\n};\n\n/**\n * Abstract class that can be used to resolve meta data for specific pages.\n * The `getScore` method is used to select the right resolver for a specific\n * page, based on a score. The score is calculated by the (non)matching page\n * type and page template.\n */\nclass PageMetaResolver {\n  /**\n   * Returns the matching score for a resolver class, based on\n   * the page type and page template.\n   */\n  getScore(page) {\n    let score = 0;\n    if (this.pageType) {\n      score += page.type === this.pageType ? 1 : -1;\n    }\n    if (this.pageTemplate) {\n      score += page.template === this.pageTemplate ? 1 : -1;\n    }\n    return score;\n  }\n  hasMatch(page) {\n    return this.getScore(page) > 0;\n  }\n  getPriority(page) {\n    return this.getScore(page);\n  }\n}\nclass TranslationService {}\n\n/**\n * Resolves the breadcrumb for the Angular ActivatedRouteSnapshot\n */\nlet DefaultRoutePageMetaResolver = /*#__PURE__*/(() => {\n  class DefaultRoutePageMetaResolver {\n    constructor(translation) {\n      this.translation = translation;\n    }\n    /**\n     * Resolves breadcrumb based on the given url and the breadcrumb config.\n     *\n     * - When breadcrumb config is empty, it returns an empty breadcrumb.\n     * - When breadcrumb config is a string or object with `i18n` property,\n     *    it translates it and use as a label of the returned breadcrumb.\n     * - When breadcrumb config is an object with property `raw`, then\n     *    it's used as a label of the returned breadcrumb.\n     */\n    resolveBreadcrumbs({\n      url,\n      pageMetaConfig\n    }) {\n      const breadcrumbConfig = pageMetaConfig === null || pageMetaConfig === void 0 ? void 0 : pageMetaConfig.breadcrumb;\n      if (!breadcrumbConfig) {\n        return of([]);\n      }\n      if (typeof breadcrumbConfig !== 'string' && breadcrumbConfig.raw) {\n        return of([{\n          link: url,\n          label: breadcrumbConfig.raw\n        }]);\n      }\n      return this.translateBreadcrumbLabel(breadcrumbConfig).pipe(map(label => [{\n        label,\n        link: url\n      }]));\n    }\n    /**\n     * Translates the configured breadcrumb label\n     */\n    translateBreadcrumbLabel(breadcrumbConfig) {\n      const i18nKey = typeof breadcrumbConfig === 'string' ? breadcrumbConfig : breadcrumbConfig.i18n;\n      return this.getParams().pipe(switchMap(params => this.translation.translate(i18nKey, params !== null && params !== void 0 ? params : {})));\n    }\n    /**\n     * Resolves dynamic data for the whole resolver.\n     */\n    getParams() {\n      return of({});\n    }\n  }\n  DefaultRoutePageMetaResolver.ɵfac = function DefaultRoutePageMetaResolver_Factory(t) {\n    return new (t || DefaultRoutePageMetaResolver)(i0.ɵɵinject(TranslationService));\n  };\n  DefaultRoutePageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultRoutePageMetaResolver,\n    factory: DefaultRoutePageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return DefaultRoutePageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves the page meta based on the Angular Activated Routes\n */\nlet RoutingPageMetaResolver = /*#__PURE__*/(() => {\n  class RoutingPageMetaResolver {\n    constructor(activatedRoutesService, injector) {\n      this.activatedRoutesService = activatedRoutesService;\n      this.injector = injector;\n      /**\n       * Array of activated routes, excluding the special Angular `root` route.\n       */\n      this.routes$ = this.activatedRoutesService.routes$.pipe(\n      // drop the first route - the special `root` route:\n      map(routes => routes = routes.slice(1, routes.length)));\n      /**\n       * Array of activated routes together with precalculated extras:\n       *\n       * - route's page meta resolver\n       * - route's absolute string URL\n       *\n       * In case when there is no page meta resolver configured for a specific route,\n       * it inherits its parent's resolver.\n       *\n       * When there is no page meta resolver configured for the highest parent in the hierarchy,\n       * it uses the `DefaultRoutePageMetaResolver`.\n       */\n      this.routesWithExtras$ = this.routes$.pipe(map(routes => routes.reduce((results, route) => {\n        var _a;\n        const parent = results.length ? results[results.length - 1] : {\n          route: null,\n          resolver: this.injector.get(DefaultRoutePageMetaResolver),\n          url: ''\n        };\n        const resolver = (_a = this.getResolver(route)) !== null && _a !== void 0 ? _a : parent.resolver; // fallback to parent's resolver\n        const urlPart = this.getUrlPart(route);\n        const url = parent.url + (urlPart ? `/${urlPart}` : ''); // don't add slash for a route with path '', to avoid double slash ...//...\n        return results.concat({\n          route,\n          resolver,\n          url\n        });\n      }, [])), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    /**\n     * Array of breadcrumbs defined for all the activated routes (from the root route to the leaf route).\n     * It emits on every completed routing navigation.\n     */\n    resolveBreadcrumbs(options) {\n      return this.routesWithExtras$.pipe(map(routesWithExtras => (options === null || options === void 0 ? void 0 : options.includeCurrentRoute) ? routesWithExtras : this.trimCurrentRoute(routesWithExtras)), switchMap(routesWithExtras => routesWithExtras.length ? combineLatest(routesWithExtras.map(routeWithExtras => this.resolveRouteBreadcrumb(routeWithExtras))) : of([])), map(breadcrumbArrays => breadcrumbArrays.flat()));\n    }\n    /**\n     * Returns the instance of the RoutePageMetaResolver configured for the given activated route.\n     * Returns null in case there the resolver can't be injected or is undefined.\n     *\n     * @param route route to resolve\n     */\n    getResolver(route) {\n      const pageMetaConfig = this.getPageMetaConfig(route);\n      if (typeof pageMetaConfig !== 'string' && (pageMetaConfig === null || pageMetaConfig === void 0 ? void 0 : pageMetaConfig.resolver)) {\n        return this.injector.get(pageMetaConfig.resolver, null);\n      }\n      return null;\n    }\n    /**\n     * Resolvers breadcrumb for a specific route\n     */\n    resolveRouteBreadcrumb({\n      route,\n      resolver,\n      url\n    }) {\n      const breadcrumbResolver = resolver;\n      if (typeof breadcrumbResolver.resolveBreadcrumbs === 'function') {\n        return breadcrumbResolver.resolveBreadcrumbs({\n          route,\n          url,\n          pageMetaConfig: this.getPageMetaConfig(route)\n        });\n      }\n      return of([]);\n    }\n    /**\n     * By default in breadcrumbs list we don't want to show a link to the current page, so this function\n     * trims the last breadcrumb (the breadcrumb of the current route).\n     *\n     * This function also handles special case when the current route has a configured empty path ('' route).\n     * The '' routes are often a _technical_ routes to organize other routes, assign common guards for its children, etc.\n     * It shouldn't happen that '' route has a defined breadcrumb config.\n     *\n     * In that case, we trim not only the last route ('' route), but also its parent route with non-empty path\n     * (which likely defines the breadcrumb config).\n     */\n    trimCurrentRoute(routesWithExtras) {\n      // If the last route is '', we trim:\n      // - the '' route\n      // - all parent '' routes (until we meet route with non-empty path)\n      var _a, _b;\n      let i = routesWithExtras.length - 1;\n      while (((_b = (_a = routesWithExtras[i]) === null || _a === void 0 ? void 0 : _a.route) === null || _b === void 0 ? void 0 : _b.url.length) === 0 && i >= 0) {\n        i--;\n      }\n      // Finally we trim the last route (the one with non-empty path)\n      return routesWithExtras.slice(0, i);\n    }\n    /**\n     * Returns the URL path for the given activated route in a string format.\n     * (ActivatedRouteSnapshot#url contains an array of `UrlSegment`s, not a string)\n     */\n    getUrlPart(route) {\n      return route.url.map(urlSegment => urlSegment.path).join('/');\n    }\n    /**\n     * Returns the breadcrumb config placed in the route's `data` configuration.\n     */\n    getPageMetaConfig(route) {\n      var _a, _b;\n      // Note: we use `route.routeConfig.data` (not `route.data`) to save us from\n      // an edge case bug. In Angular, by design the `data` of ActivatedRoute is inherited\n      // from the parent route, if only the child has an empty path ''.\n      // But in any case we don't want the page meta configs to be inherited, so we\n      // read data from the original `routeConfig` which is static.\n      //\n      // Note: we may inherit the parent's page meta resolver in case we don't define it,\n      // but we don't want to inherit parent's page meta config!\n      return (_b = (_a = route === null || route === void 0 ? void 0 : route.routeConfig) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.cxPageMeta;\n    }\n  }\n  RoutingPageMetaResolver.ɵfac = function RoutingPageMetaResolver_Factory(t) {\n    return new (t || RoutingPageMetaResolver)(i0.ɵɵinject(ActivatedRoutesService), i0.ɵɵinject(i0.Injector));\n  };\n  RoutingPageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RoutingPageMetaResolver,\n    factory: RoutingPageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return RoutingPageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageMetaConfig = /*#__PURE__*/(() => {\n  class PageMetaConfig {}\n  PageMetaConfig.ɵfac = function PageMetaConfig_Factory(t) {\n    return new (t || PageMetaConfig)();\n  };\n  PageMetaConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PageMetaConfig,\n    factory: function PageMetaConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || PageMetaConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return PageMetaConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service to add links to the page meta data, such canonical URLs.\n */\nlet PageLinkService = /*#__PURE__*/(() => {\n  class PageLinkService {\n    constructor(pageMetaConfig, winRef) {\n      this.pageMetaConfig = pageMetaConfig;\n      this.winRef = winRef;\n    }\n    /**\n     * Returns the canonical for the page.\n     *\n     * The canonical url is created by the help of the default `CanonicalUrlOptions` from\n     * the pageMeta options. The options can be further adjusted by the options argument.\n     */\n    getCanonicalUrl(options, url) {\n      var _a, _b, _c;\n      const config = Object.assign(Object.assign({}, (_b = (_a = this.pageMetaConfig) === null || _a === void 0 ? void 0 : _a.pageMeta) === null || _b === void 0 ? void 0 : _b.canonicalUrl), options);\n      return this.buildCanonicalUrl((_c = url !== null && url !== void 0 ? url : this.winRef.location.href) !== null && _c !== void 0 ? _c : '', config);\n    }\n    buildCanonicalUrl(url, options) {\n      if (options.forceHttps) {\n        url = url.replace(/^http(?!s):/i, 'https:');\n      }\n      if (options.forceWww) {\n        // this will not allow for not adding wwww. in case of a subdomain\n        url = url.replace(/^(https?:\\/\\/)(?!www\\.)(.*)/i, '$1www.$2');\n      }\n      if (options.removeQueryParams) {\n        url = this.removeQueryParams(url, options);\n      }\n      if (options.forceTrailingSlash) {\n        url = url.replace(/^([^\\?]+[^\\/\\?]$)$/i, '$1/');\n      }\n      return url;\n    }\n    removeQueryParams(url, config) {\n      const queryPos = url.indexOf('?');\n      if (queryPos > -1) {\n        const urlBeforeQueryParam = url.substr(0, queryPos);\n        const params = new URLSearchParams(url.substr(queryPos));\n        url = urlBeforeQueryParam;\n        if (Array.isArray(config.removeQueryParams)) {\n          config.removeQueryParams.forEach(param => {\n            params.delete(param);\n          });\n          if (params.toString().length > 0) {\n            url = `${urlBeforeQueryParam}?${params.toString()}`;\n          }\n        }\n      }\n      return url;\n    }\n  }\n  PageLinkService.ɵfac = function PageLinkService_Factory(t) {\n    return new (t || PageLinkService)(i0.ɵɵinject(PageMetaConfig), i0.ɵɵinject(WindowRef));\n  };\n  PageLinkService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PageLinkService,\n    factory: PageLinkService.ɵfac,\n    providedIn: 'root'\n  });\n  return PageLinkService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BasePageMetaResolver = /*#__PURE__*/(() => {\n  class BasePageMetaResolver {\n    constructor(cmsService, translation, routingPageMetaResolver, router, pageLinkService) {\n      this.cmsService = cmsService;\n      this.translation = translation;\n      this.routingPageMetaResolver = routingPageMetaResolver;\n      this.router = router;\n      this.pageLinkService = pageLinkService;\n      /**\n       * Helper to provide access to the current CMS page\n       */\n      this.page$ = defer(() => this.cmsService.getCurrentPage()).pipe(filter(p => Boolean(p)));\n      this.title$ = this.page$.pipe(map(p => p.title));\n      this.description$ = this.page$.pipe(map(p => p.description));\n      this.robots$ = this.page$.pipe(map(page => page.robots || []));\n      /**\n       * Breadcrumb for the home page.\n       */\n      this.homeBreadcrumb$ = this.translation.translate('common.home').pipe(map(label => [{\n        label: label,\n        link: '/'\n      }]));\n      /**\n       * All the resolved breadcrumbs (including those from Angular child routes).\n       */\n      this.breadcrumb$ = combineLatest([this.homeBreadcrumb$, defer(() => {\n        var _a;\n        return (_a = this.routingPageMetaResolver) === null || _a === void 0 ? void 0 : _a.resolveBreadcrumbs();\n      })]).pipe(map(breadcrumbs => breadcrumbs.flat()), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    resolveTitle() {\n      return this.title$;\n    }\n    resolveDescription() {\n      return this.description$;\n    }\n    /**\n     * Resolves a single breadcrumb item to the home page for each `ContentPage`.\n     * The home page label is resolved from the translation service.\n     */\n    resolveBreadcrumbs() {\n      return this.breadcrumb$;\n    }\n    resolveRobots() {\n      return this.robots$;\n    }\n    resolveCanonicalUrl(options) {\n      return this.router.events.pipe(filter(ev => ev instanceof NavigationEnd), startWith(null), map(() => this.pageLinkService.getCanonicalUrl(options)));\n    }\n  }\n  BasePageMetaResolver.ɵfac = function BasePageMetaResolver_Factory(t) {\n    return new (t || BasePageMetaResolver)(i0.ɵɵinject(CmsService), i0.ɵɵinject(TranslationService), i0.ɵɵinject(RoutingPageMetaResolver), i0.ɵɵinject(i1$1.Router), i0.ɵɵinject(PageLinkService));\n  };\n  BasePageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BasePageMetaResolver,\n    factory: BasePageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return BasePageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves the page data for all Content Pages based on the `PageType.CONTENT_PAGE`.\n * More specific resolvers for content pages can be implemented by making them more\n * specific, for example by using the page template (see `CartPageMetaResolver`).\n *\n * The page title, description, breadcrumbs and robot information are resolved from the\n * content page data. The canonical URL is resolved from the URL.\n */\nlet ContentPageMetaResolver = /*#__PURE__*/(() => {\n  class ContentPageMetaResolver extends PageMetaResolver {\n    constructor(basePageMetaResolver) {\n      super();\n      this.basePageMetaResolver = basePageMetaResolver;\n      this.pageType = PageType.CONTENT_PAGE;\n    }\n    resolveTitle() {\n      return this.basePageMetaResolver.resolveTitle();\n    }\n    resolveDescription() {\n      return this.basePageMetaResolver.resolveDescription();\n    }\n    resolveBreadcrumbs() {\n      return this.basePageMetaResolver.resolveBreadcrumbs();\n    }\n    resolveRobots() {\n      return this.basePageMetaResolver.resolveRobots();\n    }\n    resolveCanonicalUrl() {\n      return this.basePageMetaResolver.resolveCanonicalUrl();\n    }\n  }\n  ContentPageMetaResolver.ɵfac = function ContentPageMetaResolver_Factory(t) {\n    return new (t || ContentPageMetaResolver)(i0.ɵɵinject(BasePageMetaResolver));\n  };\n  ContentPageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContentPageMetaResolver,\n    factory: ContentPageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return ContentPageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageMetaModule = /*#__PURE__*/(() => {\n  class PageMetaModule {\n    static forRoot() {\n      return {\n        ngModule: PageMetaModule,\n        providers: [provideDefaultConfig(defaultPageMetaConfig)]\n      };\n    }\n  }\n  PageMetaModule.ɵfac = function PageMetaModule_Factory(t) {\n    return new (t || PageMetaModule)();\n  };\n  PageMetaModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PageMetaModule\n  });\n  PageMetaModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: PageMetaResolver,\n      useExisting: ContentPageMetaResolver,\n      multi: true\n    }]\n  });\n  return PageMetaModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction bufferDebounceTime(time = 0, scheduler) {\n  return source => {\n    let bufferedValues = [];\n    return source.pipe(tap(value => bufferedValues.push(value)), debounceTime(time, scheduler), map(() => bufferedValues), tap(() => bufferedValues = []));\n  };\n}\nconst JSP_INCLUDE_CMS_COMPONENT_TYPE = 'JspIncludeComponent';\nconst CMS_FLEX_COMPONENT_TYPE = 'CMSFlexComponent';\n/** Strategy to control the loading strategy of DOM elements. */\nvar DeferLoadingStrategy = /*#__PURE__*/(() => {\n  (function (DeferLoadingStrategy) {\n    /** Defers loading of DOM elements until element is near/in the users view port */\n    DeferLoadingStrategy[\"DEFER\"] = \"DEFERRED-LOADING\";\n    /** Renders the DOM instantly without being concerned with the view port */\n    DeferLoadingStrategy[\"INSTANT\"] = \"INSTANT-LOADING\";\n  })(DeferLoadingStrategy || (DeferLoadingStrategy = {}));\n  return DeferLoadingStrategy;\n})();\nlet CmsConfig = /*#__PURE__*/(() => {\n  class CmsConfig extends OccConfig {}\n  CmsConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵCmsConfig_BaseFactory;\n    return function CmsConfig_Factory(t) {\n      return (ɵCmsConfig_BaseFactory || (ɵCmsConfig_BaseFactory = i0.ɵɵgetInheritedFactory(CmsConfig)))(t || CmsConfig);\n    };\n  }();\n  CmsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsConfig,\n    factory: function CmsConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || CmsConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return CmsConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The `CmsStructureConfig` is used to build pages in Spartacus by configuration\n * instead of using a backend CMS system. The configuration can be used to build\n * complete pages or parts of a page. The `CmsStructureConfig` is optimized to\n * only require the necessary properties. Adapter logic is applied to serialize\n * the `CmsStructureConfig` into the required UI model.\n */\nlet CmsStructureConfig = /*#__PURE__*/(() => {\n  class CmsStructureConfig extends CmsConfig {}\n  CmsStructureConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵCmsStructureConfig_BaseFactory;\n    return function CmsStructureConfig_Factory(t) {\n      return (ɵCmsStructureConfig_BaseFactory || (ɵCmsStructureConfig_BaseFactory = i0.ɵɵgetInheritedFactory(CmsStructureConfig)))(t || CmsStructureConfig);\n    };\n  }();\n  CmsStructureConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsStructureConfig,\n    factory: function CmsStructureConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || CmsStructureConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return CmsStructureConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service that provides access to CMS structure from a static\n * configuration or configuration file. This class uses static\n * configuration is designed in async fashion so that configurations\n * can be loaded from a file or stream.\n *\n * The intent of the `CmsStructureConfigService` however is to provide\n * fast loading pages and default cms structure for commodity commerce.\n */\nlet CmsStructureConfigService = /*#__PURE__*/(() => {\n  class CmsStructureConfigService {\n    constructor(cmsDataConfig) {\n      this.cmsDataConfig = cmsDataConfig;\n    }\n    /**\n     * Merge the cms structure to the pageStructure. The page structure\n     * can either hold complete page structures or global structures that\n     * might apply to all pages (such has header coponents).\n     */\n    mergePageStructure(pageId, pageStructure) {\n      return this.mergePage(pageId, pageStructure).pipe(switchMap(page => this.mergeSlots(page)));\n    }\n    /**\n     *\n     * Returns boolean observable to indicate whether the page should not be\n     * loaded from the backend. This is useful for pages which are comoditized\n     * and follow best practice.\n     *\n     * By default, configurable pages are driven by static configuration,\n     * in order to allow for fast loading pages (preventing network delays).\n     */\n    shouldIgnoreBackend(pageId) {\n      return this.getPageFromConfig(pageId).pipe(map(page => !!page && !!page.ignoreBackend));\n    }\n    /**\n     * returns an Observable component data from the static configuration.\n     */\n    getComponentFromConfig(componentId) {\n      return of(this.getComponentById(componentId));\n    }\n    /**\n     * returns an Observable components data from the static configuration.\n     */\n    getComponentsFromConfig(ids) {\n      return of(ids.map(id => this.getComponentById(id)));\n    }\n    /**\n     * returns an observable with the `PageConfig`.\n     */\n    getPageFromConfig(pageId) {\n      return of(this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.pages ? this.cmsDataConfig.cmsStructure.pages.find(p => p.pageId === pageId) : null);\n    }\n    /**\n     * Merge page data from the configuration into the given structure, if any.\n     * If the given page structure is empty, a page is created and the page slots are\n     * are merged into the page.\n     */\n    mergePage(pageId, pageStructure) {\n      return this.getPageFromConfig(pageId).pipe(switchMap(page => {\n        if (page) {\n          // serialize page data\n          if (!pageStructure.page) {\n            pageStructure.page = Object.assign({}, page);\n            pageStructure.page.slots = {};\n          }\n          if (!pageStructure.page.slots) {\n            pageStructure.page.slots = {};\n          }\n          return this.mergeSlots(pageStructure, page.slots);\n        } else {\n          return of(pageStructure);\n        }\n      }));\n    }\n    /**\n     * Adds any pre-configured slots for pages that do not use them.\n     * If pages have a slot for the given position, the configiuration\n     * is ingored. Even if the slot does not have inner structure (such as\n     * components), so that the cms structure is able to override the (static)\n     * configuration.\n     */\n    mergeSlots(pageStructure, slots) {\n      // if no slots have been given, we use the global configured slots\n      if (!slots && this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.slots) {\n        slots = this.cmsDataConfig.cmsStructure.slots;\n      }\n      if (!slots) {\n        return of(pageStructure);\n      }\n      for (const position of Object.keys(slots)) {\n        if (!Object.keys(pageStructure.page.slots).includes(position)) {\n          // the global slot isn't yet part of the page structure\n          pageStructure.page.slots[position] = {};\n          for (const component of this.getComponentsByPosition(slots, position)) {\n            if (!pageStructure.page.slots[position].components) {\n              pageStructure.page.slots[position].components = [];\n            }\n            pageStructure.page.slots[position].components.push({\n              uid: component.uid,\n              flexType: component.flexType,\n              typeCode: component.typeCode\n            });\n            if (!pageStructure.components) {\n              pageStructure.components = [];\n            }\n            pageStructure.components.push(component);\n          }\n        }\n      }\n      return of(pageStructure);\n    }\n    getComponentsByPosition(slots, position) {\n      const components = [];\n      if (slots[position] && slots[position].componentIds) {\n        for (const componentId of slots[position].componentIds) {\n          if (this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.components) {\n            const component = this.cmsDataConfig.cmsStructure.components[componentId];\n            if (component) {\n              components.push(Object.assign({\n                uid: componentId\n              }, component));\n            }\n          }\n        }\n      }\n      return components;\n    }\n    getComponentById(componentId) {\n      return this.cmsDataConfig.cmsStructure && this.cmsDataConfig.cmsStructure.components ? this.cmsDataConfig.cmsStructure.components[componentId] : undefined;\n    }\n  }\n  CmsStructureConfigService.ɵfac = function CmsStructureConfigService_Factory(t) {\n    return new (t || CmsStructureConfigService)(i0.ɵɵinject(CmsStructureConfig));\n  };\n  CmsStructureConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsStructureConfigService,\n    factory: CmsStructureConfigService.ɵfac,\n    providedIn: 'root'\n  });\n  return CmsStructureConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass CmsComponentAdapter {}\nlet CmsComponentConnector = /*#__PURE__*/(() => {\n  class CmsComponentConnector {\n    constructor(cmsStructureConfigService, cmsComponentAdapter, config) {\n      this.cmsStructureConfigService = cmsStructureConfigService;\n      this.cmsComponentAdapter = cmsComponentAdapter;\n      this.config = config;\n    }\n    get(id, pageContext) {\n      return this.cmsStructureConfigService.getComponentFromConfig(id).pipe(switchMap(configuredComponent => configuredComponent ? of(configuredComponent) : this.cmsComponentAdapter.load(id, pageContext)));\n    }\n    getList(ids, pageContext) {\n      return this.cmsStructureConfigService.getComponentsFromConfig(ids).pipe(switchMap(configuredComponents => {\n        // check if we have some components that are not loaded from configuration\n        const missingIds = configuredComponents.reduce((acc, component, index) => {\n          if (component === undefined) {\n            acc.push(ids[index]);\n          }\n          return acc;\n        }, []);\n        if (missingIds.length > 0) {\n          return this.cmsComponentAdapter.findComponentsByIds(missingIds, pageContext).pipe(map(loadedComponents => [...configuredComponents.filter(Boolean), ...loadedComponents]));\n        } else {\n          return of(configuredComponents);\n        }\n      }));\n    }\n  }\n  CmsComponentConnector.ɵfac = function CmsComponentConnector_Factory(t) {\n    return new (t || CmsComponentConnector)(i0.ɵɵinject(CmsStructureConfigService), i0.ɵɵinject(CmsComponentAdapter), i0.ɵɵinject(OccConfig));\n  };\n  CmsComponentConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsComponentConnector,\n    factory: CmsComponentConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CmsComponentConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ComponentsEffects = /*#__PURE__*/(() => {\n  class ComponentsEffects {\n    constructor(actions$, cmsComponentConnector) {\n      this.actions$ = actions$;\n      this.cmsComponentConnector = cmsComponentConnector;\n      this.contextChange$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN));\n      this.loadComponent$ = createEffect(() => ({\n        scheduler,\n        debounce = 0\n      } = {}) => this.actions$.pipe(ofType(LOAD_CMS_COMPONENT), groupBy(actions => serializePageContext(actions.payload.pageContext)), mergeMap(actionGroup => actionGroup.pipe(bufferDebounceTime(debounce, scheduler), mergeMap(actions => this.loadComponentsEffect(actions.map(action => action.payload.uid), actions[0].payload.pageContext)))), withdrawOn(this.contextChange$)));\n    }\n    loadComponentsEffect(componentUids, pageContext) {\n      return this.cmsComponentConnector.getList(componentUids, pageContext).pipe(switchMap(components => {\n        const actions = [];\n        const uidsLeft = new Set(componentUids);\n        for (const component of components) {\n          actions.push(new LoadCmsComponentSuccess({\n            component,\n            uid: component.uid,\n            pageContext\n          }));\n          uidsLeft.delete(component.uid);\n        }\n        // we have to emit LoadCmsComponentFail for all component's uids that\n        // are missing from the response\n        uidsLeft.forEach(uid => {\n          actions.push(new LoadCmsComponentFail({\n            uid,\n            pageContext\n          }));\n        });\n        return from(actions);\n      }), catchError(error => from(componentUids.map(uid => new LoadCmsComponentFail({\n        uid,\n        error: normalizeHttpError(error),\n        pageContext\n      })))));\n    }\n  }\n  ComponentsEffects.ɵfac = function ComponentsEffects_Factory(t) {\n    return new (t || ComponentsEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CmsComponentConnector));\n  };\n  ComponentsEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ComponentsEffects,\n    factory: ComponentsEffects.ɵfac\n  });\n  return ComponentsEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @license\n * The MIT License\n * Copyright (c) 2010-2019 Google LLC. http://angular.io/license\n *\n * See:\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/glob.ts\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/aio/tests/deployment/shared/helpers.ts#L17\n * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/service-worker/config/src/generator.ts#L86\n */\nconst QUESTION_MARK = '[^/]';\nconst WILD_SINGLE = '[^/]*';\nconst WILD_OPEN = '(?:.+\\\\/)?';\nconst TO_ESCAPE_BASE = [{\n  replace: /\\./g,\n  with: '\\\\.'\n}, {\n  replace: /\\+/g,\n  with: '\\\\+'\n}, {\n  replace: /\\*/g,\n  with: WILD_SINGLE\n}];\nconst TO_ESCAPE_WILDCARD_QM = [...TO_ESCAPE_BASE, {\n  replace: /\\?/g,\n  with: QUESTION_MARK\n}];\nconst TO_ESCAPE_LITERAL_QM = [...TO_ESCAPE_BASE, {\n  replace: /\\?/g,\n  with: '\\\\?'\n}];\n/**\n * Converts the glob-like pattern into regex string.\n *\n * Patterns use a limited glob format:\n * `**` matches 0 or more path segments\n * `*` matches 0 or more characters excluding `/`\n * `?` matches exactly one character excluding `/` (but when @param literalQuestionMark is true, `?` is treated as normal character)\n * The `!` prefix marks the pattern as being negative, meaning that only URLs that don't match the pattern will be included\n *\n * @param glob glob-like pattern\n * @param literalQuestionMark when true, it tells that `?` is treated as a normal character\n */\nfunction globToRegex(glob, literalQuestionMark = false) {\n  const toEscape = literalQuestionMark ? TO_ESCAPE_LITERAL_QM : TO_ESCAPE_WILDCARD_QM;\n  const segments = glob.split('/').reverse();\n  let regex = '';\n  while (segments.length > 0) {\n    const segment = segments.pop();\n    if (segment === '**') {\n      if (segments.length > 0) {\n        regex += WILD_OPEN;\n      } else {\n        regex += '.*';\n      }\n    } else {\n      const processed = toEscape.reduce((seg, escape) => seg.replace(escape.replace, escape.with), segment);\n      regex += processed;\n      if (segments.length > 0) {\n        regex += '\\\\/';\n      }\n    }\n  }\n  return regex;\n}\n/**\n * For given list of glob-like patterns, returns a matcher function.\n *\n * The matcher returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.\n */\nfunction getGlobMatcher(patterns) {\n  const processedPatterns = processGlobPatterns(patterns).map(({\n    positive,\n    regex\n  }) => ({\n    positive,\n    regex: new RegExp(regex)\n  }));\n  const includePatterns = processedPatterns.filter(spec => spec.positive);\n  const excludePatterns = processedPatterns.filter(spec => !spec.positive);\n  return url => includePatterns.some(pattern => pattern.regex.test(url)) && !excludePatterns.some(pattern => pattern.regex.test(url));\n}\n/**\n * Converts list of glob-like patterns into list of RegExps with information whether the glob pattern is positive or negative\n */\nfunction processGlobPatterns(urls) {\n  return urls.map(url => {\n    const positive = !url.startsWith('!');\n    url = positive ? url : url.substr(1);\n    return {\n      positive,\n      regex: `^${globToRegex(url)}$`\n    };\n  });\n}\nlet GlobService = /*#__PURE__*/(() => {\n  class GlobService {\n    /**\n     * For given list of glob-like patterns, returns a validator function.\n     *\n     * The validator returns true for given URL only when ANY of the positive patterns is matched and NONE of the negative ones.\n     */\n    getValidator(patterns) {\n      const processedPatterns = processGlobPatterns(patterns).map(({\n        positive,\n        regex\n      }) => ({\n        positive,\n        regex: new RegExp(regex)\n      }));\n      const includePatterns = processedPatterns.filter(spec => spec.positive);\n      const excludePatterns = processedPatterns.filter(spec => !spec.positive);\n      return url => includePatterns.some(pattern => pattern.regex.test(url)) && !excludePatterns.some(pattern => pattern.regex.test(url));\n    }\n  }\n  GlobService.ɵfac = function GlobService_Factory(t) {\n    return new (t || GlobService)();\n  };\n  GlobService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GlobService,\n    factory: GlobService.ɵfac,\n    providedIn: 'root'\n  });\n  return GlobService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UrlMatcherService = /*#__PURE__*/(() => {\n  class UrlMatcherService {\n    constructor(globService) {\n      this.globService = globService;\n    }\n    /**\n     * Returns a matcher that is always fails\n     */\n    getFalsy() {\n      return function falsyUrlMatcher() {\n        return null;\n      };\n    }\n    /**\n     * Returns a matcher for given list of paths\n     */\n    getFromPaths(paths) {\n      const matchers = paths.map(path => this.getFromPath(path));\n      const matcher = this.getCombined(matchers);\n      if (isDevMode()) {\n        matcher['_paths'] = paths; // property added for easier debugging of routes\n      }\n\n      return matcher;\n    }\n    /**\n     * Returns a matcher that combines the given matchers\n     * */\n    getCombined(matchers) {\n      const matcher = function combinedUrlMatchers(segments, segmentGroup, route) {\n        for (let i = 0; i < matchers.length; i++) {\n          const result = matchers[i](segments, segmentGroup, route);\n          if (result) {\n            return result;\n          }\n        }\n        return null;\n      };\n      if (isDevMode()) {\n        matcher['_matchers'] = matchers; // property added for easier debugging of routes\n      }\n\n      return matcher;\n    }\n    /**\n     * Similar to Angular's defaultUrlMatcher. Differences:\n     * - the `path` comes from function's argument, not from `route.path`\n     * - the empty path `''` is handled here, but in Angular is handled one level higher in the match() function\n     */\n    getFromPath(path = '') {\n      const matcher = function pathUrlMatcher(segments, segmentGroup, route) {\n        /**\n         * @license\n         * The MIT License\n         * Copyright (c) 2010-2019 Google LLC. http://angular.io/license\n         *\n         * See:\n         * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/router/src/shared.ts#L121\n         */\n        // use function's argument, not the `route.path`\n        if (path === '') {\n          if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return null;\n          }\n          return {\n            consumed: [],\n            posParams: {}\n          };\n        }\n        const parts = path.split('/'); // use function's argument, not the `route.path`\n        if (parts.length > segments.length) {\n          // The actual URL is shorter than the config, no match\n          return null;\n        }\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n          // The config is longer than the actual URL but we are looking for a full match, return null\n          return null;\n        }\n        const posParams = {};\n        // Check each config part against the actual URL\n        for (let index = 0; index < parts.length; index++) {\n          const part = parts[index];\n          const segment = segments[index];\n          const isParameter = part.startsWith(':');\n          if (isParameter) {\n            posParams[part.substring(1)] = segment;\n          } else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n          }\n        }\n        return {\n          consumed: segments.slice(0, parts.length),\n          posParams\n        };\n      };\n      if (isDevMode()) {\n        matcher['_path'] = path; // property added for easier debugging of routes\n      }\n\n      return matcher;\n    }\n    /**\n     * Returns URL matcher that accepts almost everything (like `**` route), but not paths accepted by the given matcher\n     */\n    getOpposite(originalMatcher) {\n      const matcher = function oppositeUrlMatcher(segments, group, route) {\n        return originalMatcher(segments, group, route) ? null : {\n          consumed: segments,\n          posParams: {}\n        };\n      };\n      if (isDevMode()) {\n        matcher['_originalMatcher'] = originalMatcher; // property added for easier debugging of routes\n      }\n\n      return matcher;\n    }\n    /**\n     * Returns URL matcher for the given list of glob-like patterns. Each pattern must start with `/` or `!/`.\n     */\n    getFromGlob(globPatterns) {\n      const globValidator = this.globService.getValidator(globPatterns);\n      const matcher = function globUrlMatcher(segments) {\n        const fullPath = `/${segments.map(s => s.path).join('/')}`;\n        return globValidator(fullPath) ? {\n          consumed: segments,\n          posParams: {}\n        } : null;\n      };\n      if (isDevMode()) {\n        matcher['_globPatterns'] = globPatterns; // property added for easier debugging of routes\n      }\n\n      return matcher;\n    }\n  }\n  UrlMatcherService.ɵfac = function UrlMatcherService_Factory(t) {\n    return new (t || UrlMatcherService)(i0.ɵɵinject(GlobService));\n  };\n  UrlMatcherService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlMatcherService,\n    factory: UrlMatcherService.ɵfac,\n    providedIn: 'root'\n  });\n  return UrlMatcherService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ConfigurableRoutesService = /*#__PURE__*/(() => {\n  class ConfigurableRoutesService {\n    constructor(injector, routingConfigService, urlMatcherService) {\n      this.injector = injector;\n      this.routingConfigService = routingConfigService;\n      this.urlMatcherService = urlMatcherService;\n      this.initCalled = false; // guard not to call init() more than once\n    }\n    /**\n     * Enhances existing Angular routes using the routing config of Spartacus.\n     * Can be called only once.\n     */\n    init() {\n      if (!this.initCalled) {\n        this.initCalled = true;\n        this.configure();\n      }\n    }\n    /**\n     * Enhances existing Angular routes using the routing config of Spartacus.\n     */\n    configure() {\n      // Router could not be injected in constructor due to cyclic dependency with APP_INITIALIZER:\n      const router = this.injector.get(Router);\n      router.resetConfig(this.configureRoutes(router.config));\n    }\n    /**\n     * Sets the property `path` or `matcher` for the given routes, based on the Spartacus' routing configuration.\n     *\n     * @param routes list of Angular `Route` objects\n     */\n    configureRoutes(routes) {\n      return routes.map(route => {\n        const configuredRoute = this.configureRoute(route);\n        if (route.children && route.children.length) {\n          configuredRoute.children = this.configureRoutes(route.children);\n        }\n        return configuredRoute;\n      });\n    }\n    /**\n     * Sets the property `path` or `matcher` of the `Route`, based on the Spartacus' routing configuration.\n     * Uses the property `data.cxRoute` to determine the name of the route.\n     * It's the same name used as a key in the routing configuration: `routing.routes[ROUTE NAME]`.\n     *\n     * @param route Angular `Route` object\n     */\n    configureRoute(route) {\n      var _a;\n      const routeName = this.getRouteName(route);\n      if (routeName) {\n        const routeConfig = this.routingConfigService.getRouteConfig(routeName);\n        this.validateRouteConfig(routeConfig, routeName, route);\n        if (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.disabled) {\n          delete route.path;\n          return Object.assign(Object.assign({}, route), {\n            matcher: this.urlMatcherService.getFalsy()\n          });\n        } else if (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers) {\n          delete route.path;\n          return Object.assign(Object.assign({}, route), {\n            matcher: this.resolveUrlMatchers(route, routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers)\n          });\n        } else if (((_a = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || _a === void 0 ? void 0 : _a.length) === 1) {\n          delete route.matcher;\n          return Object.assign(Object.assign({}, route), {\n            path: routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths[0]\n          });\n        } else {\n          delete route.path;\n          return Object.assign(Object.assign({}, route), {\n            matcher: this.urlMatcherService.getFromPaths((routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) || [])\n          });\n        }\n      }\n      return route; // if route doesn't have a name, just pass the original route\n    }\n    /**\n     * Creates a single `UrlMatcher` based on given matchers and factories of matchers.\n     *\n     * @param route Route object\n     * @param matchersOrFactories `UrlMatcher`s or injection tokens with a factory functions\n     *  that create UrlMatchers based on the given route.\n     */\n    resolveUrlMatchers(route, matchersOrFactories) {\n      const matchers = matchersOrFactories.map(matcherOrFactory => {\n        return typeof matcherOrFactory === 'function' ? matcherOrFactory // matcher\n        : this.resolveUrlMatcherFactory(route, matcherOrFactory); // factory injection token\n      });\n\n      return this.urlMatcherService.getCombined(matchers);\n    }\n    /**\n     * Creates an `UrlMatcher` based on the given route, using the factory function coming from the given injection token.\n     *\n     * @param route Route object\n     * @param factoryToken injection token with a factory function that will create an UrlMatcher using given route\n     */\n    resolveUrlMatcherFactory(route, factoryToken) {\n      const factory = this.injector.get(factoryToken);\n      return factory(route);\n    }\n    /**\n     * Returns the name of the Route stored in its property `data.cxRoute`\n     * @param route\n     */\n    getRouteName(route) {\n      return route.data && route.data.cxRoute;\n    }\n    validateRouteConfig(routeConfig, routeName, route) {\n      if (isDevMode()) {\n        // - null value of routeConfig or routeConfig.paths means explicit switching off the route - it's valid config\n        // - routeConfig with defined `matchers` is valid, even if `paths` are undefined\n        if (routeConfig === null || (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.matchers)) {\n          return;\n        }\n        // undefined value of routeConfig or routeConfig.paths is a misconfiguration\n        if (!(routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths)) {\n          this.warn(`Could not configure the named route '${routeName}'`, route, `due to undefined config or undefined 'paths' property for this route`);\n          return;\n        }\n      }\n    }\n    warn(...args) {\n      if (isDevMode()) {\n        console.warn(...args);\n      }\n    }\n  }\n  ConfigurableRoutesService.ɵfac = function ConfigurableRoutesService_Factory(t) {\n    return new (t || ConfigurableRoutesService)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(RoutingConfigService), i0.ɵɵinject(UrlMatcherService));\n  };\n  ConfigurableRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConfigurableRoutesService,\n    factory: ConfigurableRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConfigurableRoutesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductURLPipe = /*#__PURE__*/(() => {\n  class ProductURLPipe {\n    constructor(semanticPath) {\n      this.semanticPath = semanticPath;\n    }\n    transform(product) {\n      return this.semanticPath.transform({\n        cxRoute: 'product',\n        params: product\n      });\n    }\n  }\n  ProductURLPipe.ɵfac = function ProductURLPipe_Factory(t) {\n    return new (t || ProductURLPipe)(i0.ɵɵdirectiveInject(SemanticPathService, 16));\n  };\n  ProductURLPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxProductUrl\",\n    type: ProductURLPipe,\n    pure: true\n  });\n  return ProductURLPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UrlPipe = /*#__PURE__*/(() => {\n  class UrlPipe {\n    constructor(urlService) {\n      this.urlService = urlService;\n    }\n    transform(commands) {\n      return this.urlService.transform(commands);\n    }\n  }\n  UrlPipe.ɵfac = function UrlPipe_Factory(t) {\n    return new (t || UrlPipe)(i0.ɵɵdirectiveInject(SemanticPathService, 16));\n  };\n  UrlPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxUrl\",\n    type: UrlPipe,\n    pure: true\n  });\n  return UrlPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UrlModule = /*#__PURE__*/(() => {\n  class UrlModule {}\n  UrlModule.ɵfac = function UrlModule_Factory(t) {\n    return new (t || UrlModule)();\n  };\n  UrlModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UrlModule\n  });\n  UrlModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return UrlModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ExternalRoutesConfig = /*#__PURE__*/(() => {\n  class ExternalRoutesConfig {}\n  ExternalRoutesConfig.ɵfac = function ExternalRoutesConfig_Factory(t) {\n    return new (t || ExternalRoutesConfig)();\n  };\n  ExternalRoutesConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExternalRoutesConfig,\n    factory: function ExternalRoutesConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || ExternalRoutesConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return ExternalRoutesConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ExternalRoutesGuard = /*#__PURE__*/(() => {\n  class ExternalRoutesGuard {\n    constructor(winRef, platformId) {\n      this.winRef = winRef;\n      this.platformId = platformId;\n    }\n    /**\n     * Redirects to different storefront system for anticipated URL\n     */\n    canActivate(route, state) {\n      if (isPlatformBrowser(this.platformId)) {\n        this.redirect(route, state);\n      }\n      return false;\n    }\n    /**\n     * Redirects to anticipated URL using full page reload, not Angular routing\n     */\n    redirect(_, state) {\n      const window = this.winRef.nativeWindow;\n      if (window && window.location) {\n        window.location.href = state.url;\n      }\n    }\n  }\n  ExternalRoutesGuard.ɵfac = function ExternalRoutesGuard_Factory(t) {\n    return new (t || ExternalRoutesGuard)(i0.ɵɵinject(WindowRef), i0.ɵɵinject(PLATFORM_ID));\n  };\n  ExternalRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExternalRoutesGuard,\n    factory: ExternalRoutesGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return ExternalRoutesGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction addExternalRoutesFactory(service) {\n  const result = () => {\n    service.addRoutes();\n  };\n  return result;\n}\n\n/**\n * Service that helps redirecting to different storefront systems for configured URLs\n */\nlet ExternalRoutesService = /*#__PURE__*/(() => {\n  class ExternalRoutesService {\n    constructor(config, urlMatcherService, injector) {\n      this.config = config;\n      this.urlMatcherService = urlMatcherService;\n      this.injector = injector;\n    }\n    get internalUrlPatterns() {\n      return this.config && this.config.routing && this.config.routing.internal || [];\n    }\n    /**\n     * Prepends routes (to the Router.config) that are responsible for redirecting to a different storefront system\n     */\n    addRoutes() {\n      const router = this.injector.get(Router);\n      const newRoutes = this.getRoutes();\n      if (newRoutes.length) {\n        router.resetConfig([...newRoutes, ...router.config]);\n      }\n    }\n    /**\n     * Returns routes that are responsible for redirection to different storefront systems\n     */\n    getRoutes() {\n      if (!this.internalUrlPatterns.length) {\n        return [];\n      }\n      const routes = [];\n      routes.push({\n        pathMatch: 'full',\n        matcher: this.getUrlMatcher(),\n        canActivate: [ExternalRoutesGuard],\n        component: {}\n      });\n      return routes;\n    }\n    /**\n     * Returns the URL matcher for the external route\n     */\n    getUrlMatcher() {\n      const matcher = this.urlMatcherService.getFromGlob(this.internalUrlPatterns);\n      return this.urlMatcherService.getOpposite(matcher); // the external route should be activated only when it's NOT an internal route\n    }\n  }\n\n  ExternalRoutesService.ɵfac = function ExternalRoutesService_Factory(t) {\n    return new (t || ExternalRoutesService)(i0.ɵɵinject(ExternalRoutesConfig), i0.ɵɵinject(UrlMatcherService), i0.ɵɵinject(i0.Injector));\n  };\n  ExternalRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ExternalRoutesService,\n    factory: ExternalRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return ExternalRoutesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Prepends the external route that redirects to a different storefront system for configured URLs\n */\nlet ExternalRoutesModule = /*#__PURE__*/(() => {\n  class ExternalRoutesModule {\n    static forRoot() {\n      return {\n        ngModule: ExternalRoutesModule,\n        providers: [{\n          provide: APP_INITIALIZER,\n          multi: true,\n          useFactory: addExternalRoutesFactory,\n          deps: [ExternalRoutesService]\n        }]\n      };\n    }\n  }\n  ExternalRoutesModule.ɵfac = function ExternalRoutesModule_Factory(t) {\n    return new (t || ExternalRoutesModule)();\n  };\n  ExternalRoutesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ExternalRoutesModule\n  });\n  ExternalRoutesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ExternalRoutesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The homepage id for the CMS homepage is not required when we query the backend.\n * CMS business users can have multiple pages, that they might switch quickly without\n * changing the page id. Therefore, we use a constant to keep track of the page in the\n * store, but are able to ignore the id while querying the backend.\n */\nconst HOME_PAGE_CONTEXT = '__HOMEPAGE__';\n/**\n * SmartEdit preview page is loaded by previewToken which is added by interceptor\n */\nconst SMART_EDIT_CONTEXT = 'smartedit-preview';\nclass PageContext {\n  constructor(id, type) {\n    this.id = id;\n    this.type = type;\n  }\n}\nlet ProtectedRoutesService = /*#__PURE__*/(() => {\n  class ProtectedRoutesService {\n    constructor(config, urlParsingService) {\n      this.config = config;\n      this.urlParsingService = urlParsingService;\n      this.nonProtectedPaths = []; // arrays of paths' segments list\n      if (this.shouldProtect) {\n        // pre-process config for performance:\n        this.nonProtectedPaths = this.getNonProtectedPaths().map(path => this.getSegments(path));\n      }\n    }\n    get routingConfig() {\n      return this.config && this.config.routing;\n    }\n    /**\n     * Returns 'protected' property (boolean) from routing config\n     *\n     * @returns boolean\n     */\n    get shouldProtect() {\n      var _a;\n      return !!((_a = this.routingConfig) === null || _a === void 0 ? void 0 : _a.protected);\n    }\n    /**\n     * Tells if the url is protected\n     */\n    isUrlProtected(urlSegments) {\n      return this.shouldProtect && !this.matchAnyPath(urlSegments, this.nonProtectedPaths);\n    }\n    /**\n     * Tells whether the url matches at least one of the paths\n     */\n    matchAnyPath(urlSegments, pathsSegments) {\n      return pathsSegments.some(pathSegments => this.matchPath(urlSegments, pathSegments));\n    }\n    /**\n     * Tells whether the url matches the path\n     */\n    matchPath(urlSegments, pathSegments) {\n      return this.urlParsingService.matchPath(urlSegments, pathSegments);\n    }\n    /**\n     * Returns a list of paths that are not protected\n     */\n    getNonProtectedPaths() {\n      var _a, _b;\n      return Object.values((_b = (_a = this.routingConfig) === null || _a === void 0 ? void 0 : _a.routes) !== null && _b !== void 0 ? _b : {}).reduce((acc, routeConfig) => {\n        var _a;\n        return routeConfig.protected === false &&\n        // must be explicitly false, ignore undefined\n        routeConfig.paths && routeConfig.paths.length ? acc.concat((_a = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) !== null && _a !== void 0 ? _a : []) : acc;\n      }, []);\n    }\n    /**\n     * Splits the url by slashes\n     */\n    getSegments(url) {\n      return (url || '').split('/');\n    }\n  }\n  ProtectedRoutesService.ɵfac = function ProtectedRoutesService_Factory(t) {\n    return new (t || ProtectedRoutesService)(i0.ɵɵinject(RoutingConfig), i0.ɵɵinject(UrlParsingService));\n  };\n  ProtectedRoutesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProtectedRoutesService,\n    factory: ProtectedRoutesService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProtectedRoutesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProtectedRoutesGuard = /*#__PURE__*/(() => {\n  class ProtectedRoutesGuard {\n    constructor(service, authGuard) {\n      this.service = service;\n      this.authGuard = authGuard;\n    }\n    /**\n     * When the anticipated url is protected, it switches to the AuthGuard. Otherwise emits true.\n     */\n    canActivate(route) {\n      let urlSegments = route.url.map(seg => seg.path);\n      // For the root path `/` ActivatedRoute contains an empty array of segments:\n      urlSegments = urlSegments.length ? urlSegments : [''];\n      if (this.service.isUrlProtected(urlSegments)) {\n        return this.authGuard.canActivate();\n      }\n      return of(true);\n    }\n  }\n  ProtectedRoutesGuard.ɵfac = function ProtectedRoutesGuard_Factory(t) {\n    return new (t || ProtectedRoutesGuard)(i0.ɵɵinject(ProtectedRoutesService), i0.ɵɵinject(AuthGuard));\n  };\n  ProtectedRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProtectedRoutesGuard,\n    factory: ProtectedRoutesGuard.ɵfac,\n    providedIn: 'root'\n  });\n  return ProtectedRoutesGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RouterEffects = /*#__PURE__*/(() => {\n  class RouterEffects {\n    constructor(actions$, router) {\n      this.actions$ = actions$;\n      this.router = router;\n      this.clearCmsRoutes$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), tap(() => {\n        const filteredConfig = this.router.config.filter(route => !(route.data && route.data.cxCmsRouteContext));\n        if (filteredConfig.length !== this.router.config.length) {\n          this.router.resetConfig(filteredConfig);\n        }\n      }));\n    }\n  }\n  RouterEffects.ɵfac = function RouterEffects_Factory(t) {\n    return new (t || RouterEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(i1$1.Router));\n  };\n  RouterEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RouterEffects,\n    factory: RouterEffects.ɵfac\n  });\n  __decorate([Effect({\n    dispatch: false\n  })], RouterEffects.prototype, \"clearCmsRoutes$\", void 0);\n  return RouterEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$2 = [RouterEffects];\nconst initialState$o = {\n  navigationId: 0,\n  state: {\n    url: '',\n    queryParams: {},\n    params: {},\n    context: {\n      id: ''\n    },\n    cmsRequired: false,\n    semanticRoute: undefined\n  },\n  nextState: undefined\n};\nfunction getReducers$5() {\n  return {\n    router: reducer$o\n  };\n}\nfunction reducer$o(state = initialState$o, action) {\n  var _a, _b;\n  switch (action.type) {\n    case fromNgrxRouter.ROUTER_NAVIGATION:\n      {\n        return Object.assign(Object.assign({}, state), {\n          nextState: action.payload.routerState,\n          navigationId: action.payload.event.id\n        });\n      }\n    case fromNgrxRouter.ROUTER_ERROR:\n    case fromNgrxRouter.ROUTER_CANCEL:\n      {\n        return Object.assign(Object.assign({}, state), {\n          nextState: undefined\n        });\n      }\n    case CHANGE_NEXT_PAGE_CONTEXT:\n      {\n        return state.nextState ? Object.assign(Object.assign({}, state), {\n          nextState: Object.assign(Object.assign({}, state.nextState), {\n            context: action.payload\n          })\n        }) : state;\n      }\n    case fromNgrxRouter.ROUTER_NAVIGATED:\n      {\n        return {\n          state: Object.assign(Object.assign({}, action.payload.routerState), {\n            context:\n            // we want to preserve already resolved context,\n            // in case it was changed while navigating\n            (_b = (_a = state.nextState) === null || _a === void 0 ? void 0 : _a.context) !== null && _b !== void 0 ? _b : action.payload.routerState.context\n          }),\n          navigationId: action.payload.event.id,\n          nextState: undefined\n        };\n      }\n    default:\n      {\n        return state;\n      }\n  }\n}\nconst reducerToken$5 = new InjectionToken('RouterReducers');\nconst reducerProvider$5 = {\n  provide: reducerToken$5,\n  useFactory: getReducers$5\n};\n/* The serializer is there to parse the RouterStateSnapshot,\nand to reduce the amount of properties to be passed to the reducer.\n */\nlet CustomSerializer = /*#__PURE__*/(() => {\n  class CustomSerializer {\n    constructor(routingConfig) {\n      this.routingConfig = routingConfig;\n    }\n    serialize(routerState) {\n      var _a, _b;\n      let state = routerState.root;\n      let cmsRequired = false;\n      let context;\n      let semanticRoute;\n      let urlString = '';\n      while (state.firstChild) {\n        state = state.firstChild;\n        urlString += '/' + state.url.map(urlSegment => urlSegment.path).join('/');\n        // we use semantic route information embedded from any parent route\n        if ((_a = state.data) === null || _a === void 0 ? void 0 : _a.cxRoute) {\n          semanticRoute = (_b = state.data) === null || _b === void 0 ? void 0 : _b.cxRoute;\n        }\n        // we use context information embedded in Cms driven routes from any parent route\n        if (state.data && state.data.cxCmsRouteContext) {\n          context = state.data.cxCmsRouteContext;\n        }\n        // we assume, that any route that has CmsPageGuard or it's child\n        // is cmsRequired\n        if (!cmsRequired && (context || state.routeConfig && state.routeConfig.canActivate && state.routeConfig.canActivate.find(x => x && x.guardName === 'CmsPageGuard'))) {\n          cmsRequired = true;\n        }\n      }\n      // If `semanticRoute` couldn't be already recognized using `data.cxRoute` property\n      // let's lookup the routing configuration to find the semantic route that has exactly the same configured path as the current URL.\n      // This will work only for simple URLs without any dynamic routing parameters.\n      semanticRoute = semanticRoute || this.lookupSemanticRoute(urlString);\n      const {\n        params\n      } = state;\n      // we give smartedit preview page a PageContext\n      if (state.url.length > 0 && state.url[0].path === 'cx-preview') {\n        context = {\n          id: SMART_EDIT_CONTEXT,\n          type: PageType.CONTENT_PAGE\n        };\n      } else {\n        if (params['productCode']) {\n          context = {\n            id: params['productCode'],\n            type: PageType.PRODUCT_PAGE\n          };\n        } else if (params['categoryCode']) {\n          context = {\n            id: params['categoryCode'],\n            type: PageType.CATEGORY_PAGE\n          };\n        } else if (params['brandCode']) {\n          context = {\n            id: params['brandCode'],\n            type: PageType.CATEGORY_PAGE\n          };\n        } else if (state.data.pageLabel !== undefined) {\n          context = {\n            id: state.data.pageLabel,\n            type: PageType.CONTENT_PAGE\n          };\n        } else if (!context) {\n          if (state.url.length > 0) {\n            const pageLabel = '/' + state.url.map(urlSegment => urlSegment.path).join('/');\n            context = {\n              id: pageLabel,\n              type: PageType.CONTENT_PAGE\n            };\n          } else {\n            context = {\n              // We like URLs to be driven by the backend, the CMS actually returns the homepage\n              // if no page label is given. Our logic however requires an id. undefined doesn't work.\n              id: HOME_PAGE_CONTEXT,\n              // We currently need to support a hardcoded page type, since the internal store uses the page\n              // type to store the content.\n              type: PageType.CONTENT_PAGE\n            };\n          }\n        }\n      }\n      return {\n        url: routerState.url,\n        queryParams: routerState.root.queryParams,\n        params,\n        context,\n        cmsRequired,\n        semanticRoute\n      };\n    }\n    /**\n     * Returns the semantic route name for given page label.\n     *\n     * *NOTE*: It works only for simple static urls that are equal to the page label\n     * of cms-driven content page. For example: `/my-account/address-book`.\n     *\n     * It doesn't work for URLs with dynamic parameters. But such case can be handled\n     * by reading the defined `data.cxRoute` from the Angular Routes.\n     *\n     * @param path path to be found in the routing config\n     */\n    lookupSemanticRoute(path) {\n      // Page label is assumed to start with `/`, but Spartacus configured paths\n      // don't start with slash. So we remove the leading slash:\n      return this.routingConfig.getRouteName(path.substr(1));\n    }\n  }\n  CustomSerializer.ɵfac = function CustomSerializer_Factory(t) {\n    return new (t || CustomSerializer)(i0.ɵɵinject(RoutingConfigService));\n  };\n  CustomSerializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CustomSerializer,\n    factory: CustomSerializer.ɵfac\n  });\n  return CustomSerializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction initConfigurableRoutes(service) {\n  const result = () => service.init(); // workaround for AOT compilation (see https://stackoverflow.com/a/51977115)\n  return result;\n}\nlet RoutingModule = /*#__PURE__*/(() => {\n  class RoutingModule {\n    static forRoot() {\n      return {\n        ngModule: RoutingModule,\n        providers: [reducerProvider$5, {\n          provide: RouterStateSerializer,\n          useClass: CustomSerializer\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: initConfigurableRoutes,\n          deps: [ConfigurableRoutesService],\n          multi: true\n        }]\n      };\n    }\n  }\n  RoutingModule.ɵfac = function RoutingModule_Factory(t) {\n    return new (t || RoutingModule)();\n  };\n  RoutingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RoutingModule\n  });\n  RoutingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[StoreModule.forFeature(ROUTING_FEATURE, reducerToken$5), EffectsModule.forFeature(effects$2), StoreRouterConnectingModule.forRoot({\n      routerState: 1 /* Minimal */,\n      stateKey: ROUTING_FEATURE // name of reducer key\n    })]]\n  });\n  return RoutingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getDefaultUrlMatcherFactory(routingConfigService, urlMatcherService) {\n  const factory = route => {\n    const routeName = route.data && route.data['cxRoute'];\n    const routeConfig = routingConfigService.getRouteConfig(routeName);\n    const paths = routeConfig && routeConfig.paths || [];\n    return urlMatcherService.getFromPaths(paths);\n  };\n  return factory;\n}\n/**\n * Injection token with url matcher factory for spartacus routes containing property `data.cxRoute`.\n * The provided url matcher matches the configured `paths` from routing config.\n *\n * If this matcher doesn't fit the requirements, it can be replaced with custom matcher\n * or additional matchers can be added for a specific route. See for example PRODUCT_DETAILS_URL_MATCHER.\n *\n * Note: Matchers will \"match\" a route, but do not contribute to the creation of the route, nor do they guard routes.\n */\nconst DEFAULT_URL_MATCHER = new InjectionToken('DEFAULT_URL_MATCHER', {\n  providedIn: 'root',\n  factory: () => getDefaultUrlMatcherFactory(inject(RoutingConfigService), inject(UrlMatcherService))\n});\nlet NavigationEntryItemEffects = /*#__PURE__*/(() => {\n  class NavigationEntryItemEffects {\n    constructor(actions$, cmsComponentConnector, routingService) {\n      this.actions$ = actions$;\n      this.cmsComponentConnector = cmsComponentConnector;\n      this.routingService = routingService;\n      this.loadNavigationItems$ = this.actions$.pipe(ofType(LOAD_CMS_NAVIGATION_ITEMS), map(action => action.payload), map(payload => {\n        return {\n          ids: this.getIdListByItemType(payload.items),\n          nodeId: payload.nodeId\n        };\n      }), mergeMap(data => {\n        if (data.ids.componentIds.length > 0) {\n          return this.routingService.getRouterState().pipe(filter(isNotUndefined), map(routerState => routerState.state.context), take(1), mergeMap(pageContext =>\n          // download all items in one request\n          this.cmsComponentConnector.getList(data.ids.componentIds, pageContext).pipe(map(components => new LoadCmsNavigationItemsSuccess({\n            nodeId: data.nodeId,\n            components: components\n          })), catchError(error => of(new LoadCmsNavigationItemsFail(data.nodeId, normalizeHttpError(error)))))));\n        } else if (data.ids.pageIds.length > 0) {\n          // TODO: future work\n          // dispatch action to load cms page one by one\n        } else if (data.ids.mediaIds.length > 0) {\n          // TODO: future work\n          // send request to get list of media\n        } else {\n          return of(new LoadCmsNavigationItemsFail(data.nodeId, 'navigation nodes are empty'));\n        }\n      }));\n    }\n    // We only consider 3 item types: cms page, cms component, and media.\n    getIdListByItemType(itemList) {\n      const pageIds = [];\n      const componentIds = [];\n      const mediaIds = [];\n      itemList.forEach(item => {\n        if (item.superType === 'AbstractCMSComponent') {\n          componentIds.push(item.id);\n        } else if (item.superType === 'AbstractPage') {\n          pageIds.push(item.id);\n        } else if (item.superType === 'AbstractMedia') {\n          mediaIds.push(item.id);\n        }\n      });\n      return {\n        pageIds: pageIds,\n        componentIds: componentIds,\n        mediaIds: mediaIds\n      };\n    }\n  }\n  NavigationEntryItemEffects.ɵfac = function NavigationEntryItemEffects_Factory(t) {\n    return new (t || NavigationEntryItemEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CmsComponentConnector), i0.ɵɵinject(RoutingService));\n  };\n  NavigationEntryItemEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NavigationEntryItemEffects,\n    factory: NavigationEntryItemEffects.ɵfac\n  });\n  __decorate([Effect()], NavigationEntryItemEffects.prototype, \"loadNavigationItems$\", void 0);\n  return NavigationEntryItemEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Abstract class that can be used to implement custom loader logic\n * in order to load CMS structure from third-party CMS system.\n */\nclass CmsPageAdapter {}\nlet CmsPageConnector = /*#__PURE__*/(() => {\n  class CmsPageConnector {\n    constructor(cmsPageAdapter, cmsStructureConfigService) {\n      this.cmsPageAdapter = cmsPageAdapter;\n      this.cmsStructureConfigService = cmsStructureConfigService;\n    }\n    /**\n     * Returns an observable with the page structure. The page structure is\n     * typically loaded from a backend, but can also be returned from static\n     * configuration (see `CmsStructureConfigService`).\n     */\n    get(pageContext) {\n      return this.cmsStructureConfigService.shouldIgnoreBackend(pageContext.id).pipe(switchMap(loadFromConfig => {\n        if (!loadFromConfig) {\n          return this.cmsPageAdapter.load(pageContext).pipe(catchError(error => {\n            if (error instanceof HttpErrorResponse && error.status === 400) {\n              return of({});\n            } else {\n              return throwError(error);\n            }\n          }));\n        } else {\n          return of({});\n        }\n      }), switchMap(page => this.mergeDefaultPageStructure(pageContext, page)));\n    }\n    /**\n     *\n     * Merge default page structure to the given `CmsStructureModel`.\n     * This is beneficial for a fast setup of the UI without necessary\n     * fine-grained CMS setup.\n     */\n    mergeDefaultPageStructure(pageContext, pageStructure) {\n      return this.cmsStructureConfigService.mergePageStructure(pageContext.id, pageStructure);\n    }\n  }\n  CmsPageConnector.ɵfac = function CmsPageConnector_Factory(t) {\n    return new (t || CmsPageConnector)(i0.ɵɵinject(CmsPageAdapter), i0.ɵɵinject(CmsStructureConfigService));\n  };\n  CmsPageConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CmsPageConnector,\n    factory: CmsPageConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CmsPageConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PageEffects = /*#__PURE__*/(() => {\n  class PageEffects {\n    constructor(actions$, cmsPageConnector, routingService) {\n      this.actions$ = actions$;\n      this.cmsPageConnector = cmsPageConnector;\n      this.routingService = routingService;\n      this.refreshPage$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, LOGOUT, LOGIN), switchMap(() => this.routingService.getRouterState().pipe(filter(routerState => routerState && routerState.state && routerState.state.cmsRequired && !routerState.nextState), take(1), map(routerState => routerState.state.context), mergeMap(context => of(new LoadCmsPageData(context))))));\n      this.loadPageData$ = this.actions$.pipe(ofType(LOAD_CMS_PAGE_DATA), map(action => action.payload), groupBy(pageContext => serializePageContext(pageContext)), mergeMap(group => group.pipe(switchMap(pageContext => this.cmsPageConnector.get(pageContext).pipe(mergeMap(cmsStructure => {\n        const actions = [new CmsGetComponentFromPage(cmsStructure.components.map(component => ({\n          component,\n          pageContext\n        }))), new LoadCmsPageDataSuccess(pageContext, cmsStructure.page)];\n        const pageLabel = cmsStructure.page.label;\n        // For content pages the page label returned from backend can be different than page ID initially assumed from route.\n        // In such a case let's save the success response not only for initially assumed page ID, but also for correct page label.\n        if (pageLabel && pageLabel !== pageContext.id) {\n          actions.unshift(new CmsSetPageSuccessIndex({\n            id: pageLabel,\n            type: pageContext.type\n          }, cmsStructure.page));\n        }\n        return actions;\n      }), catchError(error => of(new LoadCmsPageDataFail(pageContext, normalizeHttpError(error)))))))));\n    }\n  }\n  PageEffects.ɵfac = function PageEffects_Factory(t) {\n    return new (t || PageEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CmsPageConnector), i0.ɵɵinject(RoutingService));\n  };\n  PageEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PageEffects,\n    factory: PageEffects.ɵfac\n  });\n  __decorate([Effect()], PageEffects.prototype, \"refreshPage$\", void 0);\n  __decorate([Effect()], PageEffects.prototype, \"loadPageData$\", void 0);\n  return PageEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects$1 = [PageEffects, ComponentsEffects, NavigationEntryItemEffects];\nconst initialState$n = {\n  component: undefined,\n  pageContext: {}\n};\nfunction componentExistsReducer(state, action) {\n  switch (action.type) {\n    case LOAD_CMS_COMPONENT_FAIL:\n      return false;\n    case CMS_GET_COMPONENT_FROM_PAGE:\n    case LOAD_CMS_COMPONENT_SUCCESS:\n      return true;\n  }\n  return state;\n}\nfunction reducer$n(state = initialState$n, action) {\n  switch (action.type) {\n    case LOAD_CMS_COMPONENT:\n      {\n        const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n        const context = serializePageContext(action.payload.pageContext, true);\n        return Object.assign(Object.assign({}, state), {\n          pageContext: Object.assign(Object.assign({}, state.pageContext), {\n            [context]: pageContextReducer(state.pageContext[context], action)\n          })\n        });\n      }\n    case LOAD_CMS_COMPONENT_FAIL:\n      {\n        const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n        const context = serializePageContext(action.payload.pageContext, true);\n        return Object.assign(Object.assign({}, state), {\n          pageContext: Object.assign(Object.assign({}, state.pageContext), {\n            [context]: pageContextReducer(state.pageContext[context], action)\n          })\n        });\n      }\n    case LOAD_CMS_COMPONENT_SUCCESS:\n      {\n        const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n        const context = serializePageContext(action.payload.pageContext, true);\n        return Object.assign(Object.assign({}, state), {\n          component: action.payload.component,\n          pageContext: Object.assign(Object.assign({}, state.pageContext), {\n            [context]: pageContextReducer(state.pageContext[context], action)\n          })\n        });\n      }\n    case CMS_GET_COMPONENT_FROM_PAGE:\n      {\n        const pageContextReducer = loaderReducer(action.meta.entityType, componentExistsReducer);\n        if (!Array.isArray(action.payload)) {\n          const context = serializePageContext(action.payload.pageContext, true);\n          return Object.assign(Object.assign({}, state), {\n            component: action.payload.component,\n            pageContext: Object.assign(Object.assign({}, state.pageContext), {\n              [context]: pageContextReducer(state.pageContext[context], action)\n            })\n          });\n        }\n      }\n  }\n  return state;\n}\nconst initialState$m = undefined;\nfunction reducer$m(state = initialState$m, action) {\n  switch (action.type) {\n    case LOAD_CMS_NAVIGATION_ITEMS_SUCCESS:\n      {\n        if (action.payload.components) {\n          const components = action.payload.components;\n          const newItem = components.reduce((compItems, component) => {\n            return Object.assign(Object.assign({}, compItems), {\n              [`${component.uid}_AbstractCMSComponent`]: component\n            });\n          }, Object.assign({}));\n          return Object.assign(Object.assign({}, state), newItem);\n        }\n      }\n  }\n  return state;\n}\nconst initialState$l = {\n  entities: {}\n};\nfunction reducer$l(state = initialState$l, action) {\n  switch (action.type) {\n    case LOAD_CMS_PAGE_DATA_SUCCESS:\n      {\n        const page = action.payload;\n        return Object.assign(Object.assign({}, state), {\n          entities: Object.assign(Object.assign({}, state.entities), {\n            [page.pageId]: page\n          })\n        });\n      }\n  }\n  return state;\n}\nconst initialState$k = undefined;\nfunction reducer$k(entityType) {\n  return (state = initialState$k, action) => {\n    if (action.meta && action.meta.entityType === entityType) {\n      switch (action.type) {\n        case LOAD_CMS_PAGE_DATA_SUCCESS:\n          {\n            return action.payload.pageId;\n          }\n        case LOAD_CMS_PAGE_DATA_FAIL:\n          {\n            return initialState$k;\n          }\n        case CMS_SET_PAGE_FAIL_INDEX:\n          {\n            return action.payload;\n          }\n        case CMS_SET_PAGE_SUCCESS_INDEX:\n          {\n            return action.payload.pageId;\n          }\n      }\n    }\n    return state;\n  };\n}\nfunction getReducers$4() {\n  return {\n    page: combineReducers({\n      pageData: reducer$l,\n      index: combineReducers({\n        content: entityLoaderReducer(PageType.CONTENT_PAGE, reducer$k(PageType.CONTENT_PAGE)),\n        product: entityLoaderReducer(PageType.PRODUCT_PAGE, reducer$k(PageType.PRODUCT_PAGE)),\n        category: entityLoaderReducer(PageType.CATEGORY_PAGE, reducer$k(PageType.CATEGORY_PAGE)),\n        catalog: entityLoaderReducer(PageType.CATALOG_PAGE, reducer$k(PageType.CATALOG_PAGE))\n      })\n    }),\n    components: entityReducer(COMPONENT_ENTITY, reducer$n),\n    navigation: entityLoaderReducer(NAVIGATION_DETAIL_ENTITY, reducer$m)\n  };\n}\nconst reducerToken$4 = new InjectionToken('CmsReducers');\nconst reducerProvider$4 = {\n  provide: reducerToken$4,\n  useFactory: getReducers$4\n};\nfunction clearCmsState(reducer) {\n  return function (state, action) {\n    if (action.type === LANGUAGE_CHANGE || action.type === LOGOUT || action.type === LOGIN) {\n      state = undefined;\n    }\n    return reducer(state, action);\n  };\n}\nconst metaReducers$2 = [clearCmsState];\nfunction cmsStoreConfigFactory() {\n  // if we want to reuse CMS_FEATURE const in config, we have to use factory instead of plain object\n  const config = {\n    state: {\n      ssrTransfer: {\n        keys: {\n          [CMS_FEATURE]: StateTransferType.TRANSFER_STATE\n        }\n      }\n    }\n  };\n  return config;\n}\nlet CmsStoreModule = /*#__PURE__*/(() => {\n  class CmsStoreModule {}\n  CmsStoreModule.ɵfac = function CmsStoreModule_Factory(t) {\n    return new (t || CmsStoreModule)();\n  };\n  CmsStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CmsStoreModule\n  });\n  CmsStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfigFactory(cmsStoreConfigFactory), reducerProvider$4],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(CMS_FEATURE, reducerToken$4, {\n      metaReducers: metaReducers$2\n    }), EffectsModule.forFeature(effects$1)]]\n  });\n  return CmsStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CmsModule = /*#__PURE__*/(() => {\n  class CmsModule {\n    static forRoot() {\n      return {\n        ngModule: CmsModule,\n        providers: [CmsService, provideDefaultConfig(defaultCmsModuleConfig)]\n      };\n    }\n  }\n  CmsModule.ɵfac = function CmsModule_Factory(t) {\n    return new (t || CmsModule)();\n  };\n  CmsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CmsModule\n  });\n  CmsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CmsStoreModule, PageMetaModule.forRoot()]]\n  });\n  return CmsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CMS_PAGE_NORMALIZER = new InjectionToken('CmsPageNormalizer');\nconst CMS_COMPONENT_NORMALIZER = new InjectionToken('CmsComponentNormalizer');\nlet ComponentDecorator = /*#__PURE__*/(() => {\n  class ComponentDecorator {}\n  ComponentDecorator.ɵfac = function ComponentDecorator_Factory(t) {\n    return new (t || ComponentDecorator)();\n  };\n  ComponentDecorator.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ComponentDecorator,\n    factory: ComponentDecorator.ɵfac\n  });\n  return ComponentDecorator;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SlotDecorator = /*#__PURE__*/(() => {\n  class SlotDecorator {}\n  SlotDecorator.ɵfac = function SlotDecorator_Factory(t) {\n    return new (t || SlotDecorator)();\n  };\n  SlotDecorator.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SlotDecorator,\n    factory: SlotDecorator.ɵfac\n  });\n  return SlotDecorator;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Helper logic to resolve best matching Applicable\n *\n * Finding best match is a two step process:\n * 1. Find all matching applicables\n *    - all applicables for which hasMatch(...matchParams) will return true\n *    - all applicables without hasMatch method (implicit always match)\n * 2. Find the applicable with highest priority\n *    - applicable with highest getPriority(...priorityParams) will win\n *    - applicable without getPriority method is treated as Priority.NORMAL or 0\n *    - applicables with the same priority are sorted by order of providers, the applicable that was provided later wins\n *\n * @param applicables - array or applicable-like instances\n * @param matchParams - array of parameters passed for hasMatch calls\n * @param priorityParams - array of parameters passed for getPriority calls\n */\nfunction resolveApplicable(applicables, matchParams = [], priorityParams = []) {\n  const matchedApplicables = (applicables !== null && applicables !== void 0 ? applicables : []).filter(applicable => !applicable.hasMatch || applicable.hasMatch(...matchParams));\n  if (matchedApplicables.length < 2) {\n    return matchedApplicables[0];\n  }\n  let lastPriority = -Infinity;\n  return matchedApplicables.reduce((acc, curr) => {\n    const currPriority = curr.getPriority ? curr.getPriority(...priorityParams) : 0 /* NORMAL */;\n    if (lastPriority > currPriority) {\n      return acc;\n    }\n    lastPriority = currPriority;\n    return curr;\n  }, undefined);\n}\n\n/**\n * uniteLatest is an alternative to combineLatest. The first emission is\n * emitted synchronously (just like combineLatest) and all following emissions\n * are audited and emitted using asapScheduler.\n *\n * It effectively smooths out emissions when multiple sources will emit at the\n * same time: uniteLatest will have only one emission, where combine latest will\n * have more than one (one per source changed).\n *\n * @param sources\n */\nfunction uniteLatest(sources) {\n  return defer(() => {\n    let subNo = 0;\n    const trigger = new Observable(subscriber => {\n      const action = () => {\n        subscriber.next();\n        subscriber.complete();\n      };\n      if (subNo) {\n        asapScheduler.schedule(action);\n      } else {\n        action();\n      }\n      subNo++;\n    });\n    return combineLatest(sources).pipe(audit(() => trigger));\n  });\n}\n\n/**\n * Service that collects the page meta data by using injected page resolvers.\n */\nlet PageMetaService = /*#__PURE__*/(() => {\n  class PageMetaService {\n    constructor(cms, unifiedInjector, pageMetaConfig, platformId) {\n      this.cms = cms;\n      this.unifiedInjector = unifiedInjector;\n      this.pageMetaConfig = pageMetaConfig;\n      this.platformId = platformId;\n      this.resolvers$ = this.unifiedInjector.getMulti(PageMetaResolver).pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n      this.meta$ = defer(() => this.cms.getCurrentPage()).pipe(filter(page => Boolean(page)), switchMap(page => this.getMetaResolver(page)), switchMap(metaResolver => metaResolver ? this.resolve(metaResolver) : of(null)), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    /**\n     * Returns the observed page meta data for the current page.\n     *\n     * The data is resolved by various PageResolvers, which are configurable.\n     */\n    getMeta() {\n      return this.meta$;\n    }\n    /**\n     * If a `PageResolver` has implemented a resolver interface, the resolved data\n     * is merged into the `PageMeta` object.\n     * @param metaResolver\n     */\n    resolve(metaResolver) {\n      const resolverMethods = this.getResolverMethods();\n      const resolvedData = Object.keys(resolverMethods)\n      // TODO: Revisit if typing is possible here with Template Literal Types when we update to TS >=4.1\n      .filter(key => metaResolver[resolverMethods[key]]).map(key => {\n        return metaResolver[resolverMethods[key]]().pipe(map(data => ({\n          [key]: data\n        })));\n      });\n      if (resolvedData.length === 0) {\n        // uniteLatest will fail otherwise\n        return of({});\n      } else {\n        return uniteLatest(resolvedData).pipe(map(data => Object.assign({}, ...data)));\n      }\n    }\n    /**\n     * Returns an object with resolvers. The object properties represent the `PageMeta` property, i.e.:\n     *\n     * ```\n     * {\n     *   title: 'resolveTitle',\n     *   robots: 'resolveRobots'\n     * }\n     * ```\n     *\n     * This list of resolvers is filtered for CSR vs SSR processing since not all resolvers are\n     * relevant during browsing.\n     */\n    getResolverMethods() {\n      var _a, _b, _c;\n      let resolverMethods = {};\n      // filter the resolvers to avoid unnecessary processing in CSR\n      (_c = (_b = (_a = this.pageMetaConfig) === null || _a === void 0 ? void 0 : _a.pageMeta) === null || _b === void 0 ? void 0 : _b.resolvers) === null || _c === void 0 ? void 0 : _c.filter(resolver => {\n        var _a, _b, _c;\n        return (\n          // always resolve in SSR\n          !isPlatformBrowser((_a = this.platformId) !== null && _a !== void 0 ? _a : '') ||\n          // resolve in CSR when it's not disabled\n          !resolver.disabledInCsr ||\n          // resolve in CSR when resolver is enabled in devMode\n          isDevMode() && ((_c = (_b = this.pageMetaConfig) === null || _b === void 0 ? void 0 : _b.pageMeta) === null || _c === void 0 ? void 0 : _c.enableInDevMode)\n        );\n      }).forEach(resolver => resolverMethods[resolver.property] = resolver.method);\n      return resolverMethods;\n    }\n    /**\n     * Return the resolver with the best match, based on a score\n     * generated by the resolver.\n     *\n     * Resolvers match by default on `PageType` and `page.template`.\n     */\n    getMetaResolver(page) {\n      return this.resolvers$.pipe(map(resolvers => resolveApplicable(resolvers, [page], [page])));\n    }\n  }\n  PageMetaService.ɵfac = function PageMetaService_Factory(t) {\n    return new (t || PageMetaService)(i0.ɵɵinject(CmsService), i0.ɵɵinject(UnifiedInjector), i0.ɵɵinject(PageMetaConfig), i0.ɵɵinject(PLATFORM_ID));\n  };\n  PageMetaService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PageMetaService,\n    factory: PageMetaService.ɵfac,\n    providedIn: 'root'\n  });\n  return PageMetaService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar PageRobotsMeta = /*#__PURE__*/(() => {\n  (function (PageRobotsMeta) {\n    PageRobotsMeta[\"INDEX\"] = \"INDEX\";\n    PageRobotsMeta[\"NOINDEX\"] = \"NOINDEX\";\n    PageRobotsMeta[\"FOLLOW\"] = \"FOLLOW\";\n    PageRobotsMeta[\"NOFOLLOW\"] = \"NOFOLLOW\";\n  })(PageRobotsMeta || (PageRobotsMeta = {}));\n  return PageRobotsMeta;\n})();\n/**\n * Will grab last synchronously available value from the observable stream\n * at the time of the call.\n *\n * Should be used with caution, as it's not a legitimate way for getting value\n * from the observable. Observable composition or standard subscribe method\n * should be used for most of the cases.\n *\n * @param source\n */\nfunction getLastValueSync(source) {\n  let value;\n  source.subscribe(emission => value = emission).unsubscribe();\n  return value;\n}\n\n/**\n * Service that used to add dynamic attributes to CMS component\n * and slot elements.\n */\nlet DynamicAttributeService = /*#__PURE__*/(() => {\n  class DynamicAttributeService {\n    constructor(unifiedInjector) {\n      this.unifiedInjector = unifiedInjector;\n      this.componentDecorators$ = this.unifiedInjector.getMulti(ComponentDecorator).pipe(shareReplay(1));\n      this.slotDecorators$ = this.unifiedInjector.getMulti(SlotDecorator).pipe(shareReplay(1));\n    }\n    /**\n     * Add dynamic attributes to CMS component element\n     * @param element: CMS component element\n     * @param renderer\n     * @param componentData: component data\n     */\n    addAttributesToComponent(element, renderer, componentData) {\n      (getLastValueSync(this.componentDecorators$) || []).forEach(decorator => decorator.decorate(element, renderer, componentData));\n    }\n    /**\n     * Add dynamic attributes to CMS slot element\n     * @param element: CMS slot element\n     * @param renderer\n     * @param slotData: slot data\n     */\n    addAttributesToSlot(element, renderer, slotData) {\n      (getLastValueSync(this.slotDecorators$) || []).forEach(decorator => decorator.decorate(element, renderer, slotData));\n    }\n  }\n  DynamicAttributeService.ɵfac = function DynamicAttributeService_Factory(t) {\n    return new (t || DynamicAttributeService)(i0.ɵɵinject(UnifiedInjector));\n  };\n  DynamicAttributeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DynamicAttributeService,\n    factory: DynamicAttributeService.ɵfac,\n    providedIn: 'root'\n  });\n  return DynamicAttributeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GlobalMessageConfig = /*#__PURE__*/(() => {\n  class GlobalMessageConfig {}\n  GlobalMessageConfig.ɵfac = function GlobalMessageConfig_Factory(t) {\n    return new (t || GlobalMessageConfig)();\n  };\n  GlobalMessageConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GlobalMessageConfig,\n    factory: function GlobalMessageConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || GlobalMessageConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return GlobalMessageConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar HttpResponseStatus = /*#__PURE__*/(() => {\n  (function (HttpResponseStatus) {\n    HttpResponseStatus[HttpResponseStatus[\"UNKNOWN\"] = -1] = \"UNKNOWN\";\n    HttpResponseStatus[HttpResponseStatus[\"BAD_REQUEST\"] = 400] = \"BAD_REQUEST\";\n    HttpResponseStatus[HttpResponseStatus[\"UNAUTHORIZED\"] = 401] = \"UNAUTHORIZED\";\n    HttpResponseStatus[HttpResponseStatus[\"FORBIDDEN\"] = 403] = \"FORBIDDEN\";\n    HttpResponseStatus[HttpResponseStatus[\"NOT_FOUND\"] = 404] = \"NOT_FOUND\";\n    HttpResponseStatus[HttpResponseStatus[\"CONFLICT\"] = 409] = \"CONFLICT\";\n    HttpResponseStatus[HttpResponseStatus[\"BAD_GATEWAY\"] = 502] = \"BAD_GATEWAY\";\n    HttpResponseStatus[HttpResponseStatus[\"GATEWAY_TIMEOUT\"] = 504] = \"GATEWAY_TIMEOUT\";\n    HttpResponseStatus[HttpResponseStatus[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n  })(HttpResponseStatus || (HttpResponseStatus = {}));\n  return HttpResponseStatus;\n})();\nlet HttpErrorHandler = /*#__PURE__*/(() => {\n  class HttpErrorHandler {\n    constructor(globalMessageService, platformId) {\n      this.globalMessageService = globalMessageService;\n      this.platformId = platformId;\n    }\n    /**\n     * Error handlers are matched by the error `responseStatus` (i.e. 404). On top of the matching status\n     * a priority can be added to distinguish multiple handles for the same response status.\n     */\n    hasMatch(errorResponse) {\n      return errorResponse.status === this.responseStatus;\n    }\n    /**\n     * Returns true when invoked on the server (SSR).\n     *\n     * Added in 3.2, depends on the injected `platformId`.\n     */\n    isSsr() {\n      if (this.platformId) {\n        return !isPlatformBrowser(this.platformId);\n      }\n      return false;\n    }\n  }\n  HttpErrorHandler.ɵfac = function HttpErrorHandler_Factory(t) {\n    return new (t || HttpErrorHandler)(i0.ɵɵinject(GlobalMessageService), i0.ɵɵinject(PLATFORM_ID));\n  };\n  HttpErrorHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HttpErrorHandler,\n    factory: HttpErrorHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return HttpErrorHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BadGatewayHandler = /*#__PURE__*/(() => {\n  class BadGatewayHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.BAD_GATEWAY;\n    }\n    handleError() {\n      this.globalMessageService.add({\n        key: 'httpHandlers.badGateway'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  BadGatewayHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵBadGatewayHandler_BaseFactory;\n    return function BadGatewayHandler_Factory(t) {\n      return (ɵBadGatewayHandler_BaseFactory || (ɵBadGatewayHandler_BaseFactory = i0.ɵɵgetInheritedFactory(BadGatewayHandler)))(t || BadGatewayHandler);\n    };\n  }();\n  BadGatewayHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BadGatewayHandler,\n    factory: BadGatewayHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return BadGatewayHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst OAUTH_ENDPOINT = '/authorizationserver/oauth/token';\nlet BadRequestHandler = /*#__PURE__*/(() => {\n  class BadRequestHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.BAD_REQUEST;\n    }\n    handleError(request, response) {\n      this.handleBadPassword(request, response);\n      this.handleBadLoginResponse(request, response);\n      this.handleBadCartRequest(request, response);\n      this.handleValidationError(request, response);\n      this.handleVoucherOperationError(request, response);\n      this.handleGuestDuplicateEmail(request, response);\n    }\n    handleBadPassword(request, response) {\n      var _a, _b, _c;\n      if (((_a = response.url) === null || _a === void 0 ? void 0 : _a.includes(OAUTH_ENDPOINT)) && ((_b = response.error) === null || _b === void 0 ? void 0 : _b.error) === 'invalid_grant' && ((_c = request.body) === null || _c === void 0 ? void 0 : _c.get('grant_type')) === 'password') {\n        this.globalMessageService.add({\n          key: 'httpHandlers.badRequestPleaseLoginAgain',\n          params: {\n            errorMessage: response.error.error_description || response.message || ''\n          }\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n        this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_CONFIRMATION);\n      }\n    }\n    handleBadLoginResponse(_request, response) {\n      this.getErrors(response).filter(error => error.type === 'PasswordMismatchError').forEach(() => {\n        this.globalMessageService.add({\n          key: 'httpHandlers.badRequestOldPasswordIncorrect'\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    handleValidationError(_request, response) {\n      this.getErrors(response).filter(e => e.type === 'ValidationError').forEach(error => {\n        this.globalMessageService.add({\n          key: `httpHandlers.validationErrors.${error.reason}.${error.subject}`\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    handleBadCartRequest(_request, response) {\n      this.getErrors(response).filter(e => isCartNotFoundError(e)).forEach(() => {\n        this.globalMessageService.add({\n          key: 'httpHandlers.cartNotFound'\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    handleVoucherOperationError(_request, response) {\n      this.getErrors(response).filter(e => e.message === 'coupon.invalid.code.provided' && e.type === 'VoucherOperationError').forEach(() => {\n        this.globalMessageService.add({\n          key: 'httpHandlers.invalidCodeProvided'\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    handleGuestDuplicateEmail(_request, response) {\n      this.getErrors(response).filter(e => e.type === 'DuplicateUidError').forEach(error => {\n        this.globalMessageService.add({\n          key: 'httpHandlers.badRequestGuestDuplicateEmail',\n          params: {\n            errorMessage: error.message || ''\n          }\n        }, GlobalMessageType.MSG_TYPE_ERROR);\n      });\n    }\n    getErrors(response) {\n      var _a;\n      return (((_a = response.error) === null || _a === void 0 ? void 0 : _a.errors) || []).filter(error => error.type !== 'JaloObjectNoLongerValidError');\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  BadRequestHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵBadRequestHandler_BaseFactory;\n    return function BadRequestHandler_Factory(t) {\n      return (ɵBadRequestHandler_BaseFactory || (ɵBadRequestHandler_BaseFactory = i0.ɵɵgetInheritedFactory(BadRequestHandler)))(t || BadRequestHandler);\n    };\n  }();\n  BadRequestHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BadRequestHandler,\n    factory: BadRequestHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return BadRequestHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ConflictHandler = /*#__PURE__*/(() => {\n  class ConflictHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.CONFLICT;\n    }\n    handleError() {\n      this.globalMessageService.add({\n        key: 'httpHandlers.conflict'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  ConflictHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵConflictHandler_BaseFactory;\n    return function ConflictHandler_Factory(t) {\n      return (ɵConflictHandler_BaseFactory || (ɵConflictHandler_BaseFactory = i0.ɵɵgetInheritedFactory(ConflictHandler)))(t || ConflictHandler);\n    };\n  }();\n  ConflictHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConflictHandler,\n    factory: ConflictHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return ConflictHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ForbiddenHandler = /*#__PURE__*/(() => {\n  class ForbiddenHandler extends HttpErrorHandler {\n    constructor(globalMessageService, authService, occEndpoints) {\n      super(globalMessageService);\n      this.globalMessageService = globalMessageService;\n      this.authService = authService;\n      this.occEndpoints = occEndpoints;\n      this.responseStatus = HttpResponseStatus.FORBIDDEN;\n    }\n    handleError(request) {\n      if (request.url.endsWith(this.occEndpoints.buildUrl('user', {\n        urlParams: {\n          userId: 'current'\n        }\n      }))) {\n        this.authService.logout();\n      }\n      this.globalMessageService.add({\n        key: 'httpHandlers.forbidden'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  ForbiddenHandler.ɵfac = function ForbiddenHandler_Factory(t) {\n    return new (t || ForbiddenHandler)(i0.ɵɵinject(GlobalMessageService), i0.ɵɵinject(AuthService), i0.ɵɵinject(OccEndpointsService));\n  };\n  ForbiddenHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ForbiddenHandler,\n    factory: ForbiddenHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return ForbiddenHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet GatewayTimeoutHandler = /*#__PURE__*/(() => {\n  class GatewayTimeoutHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.GATEWAY_TIMEOUT;\n    }\n    handleError() {\n      this.globalMessageService.add({\n        key: 'httpHandlers.gatewayTimeout'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  GatewayTimeoutHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵGatewayTimeoutHandler_BaseFactory;\n    return function GatewayTimeoutHandler_Factory(t) {\n      return (ɵGatewayTimeoutHandler_BaseFactory || (ɵGatewayTimeoutHandler_BaseFactory = i0.ɵɵgetInheritedFactory(GatewayTimeoutHandler)))(t || GatewayTimeoutHandler);\n    };\n  }();\n  GatewayTimeoutHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GatewayTimeoutHandler,\n    factory: GatewayTimeoutHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return GatewayTimeoutHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InternalServerErrorHandler = /*#__PURE__*/(() => {\n  class InternalServerErrorHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.INTERNAL_SERVER_ERROR;\n    }\n    handleError() {\n      this.globalMessageService.add({\n        key: 'httpHandlers.internalServerError'\n      }, GlobalMessageType.MSG_TYPE_ERROR);\n    }\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  InternalServerErrorHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵInternalServerErrorHandler_BaseFactory;\n    return function InternalServerErrorHandler_Factory(t) {\n      return (ɵInternalServerErrorHandler_BaseFactory || (ɵInternalServerErrorHandler_BaseFactory = i0.ɵɵgetInheritedFactory(InternalServerErrorHandler)))(t || InternalServerErrorHandler);\n    };\n  }();\n  InternalServerErrorHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalServerErrorHandler,\n    factory: InternalServerErrorHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalServerErrorHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NotFoundHandler = /*#__PURE__*/(() => {\n  class NotFoundHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.NOT_FOUND;\n    }\n    // empty error handler to avoid we fallabck to the unknown error handler\n    handleError() {}\n    getPriority() {\n      return -10 /* LOW */;\n    }\n  }\n\n  NotFoundHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵNotFoundHandler_BaseFactory;\n    return function NotFoundHandler_Factory(t) {\n      return (ɵNotFoundHandler_BaseFactory || (ɵNotFoundHandler_BaseFactory = i0.ɵɵgetInheritedFactory(NotFoundHandler)))(t || NotFoundHandler);\n    };\n  }();\n  NotFoundHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NotFoundHandler,\n    factory: NotFoundHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return NotFoundHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Unknown Error Handler works as an fallback, to handle errors that were\n * not handled by any other error handlers\n */\nlet UnknownErrorHandler = /*#__PURE__*/(() => {\n  class UnknownErrorHandler extends HttpErrorHandler {\n    constructor() {\n      super(...arguments);\n      this.responseStatus = HttpResponseStatus.UNKNOWN;\n    }\n    /**\n     * hasMatch always returns true, to mach all errors\n     */\n    hasMatch(_errorResponse) {\n      return true;\n    }\n    handleError(_request, errorResponse) {\n      if (isDevMode() || this.isSsr()) {\n        console.warn(`An unknown http error occurred\\n`, errorResponse.message);\n      }\n    }\n    /**\n     * Fallback priority assures that the handler is used as a last resort\n     */\n    getPriority() {\n      return -50 /* FALLBACK */;\n    }\n  }\n\n  UnknownErrorHandler.ɵfac = /* @__PURE__ */function () {\n    let ɵUnknownErrorHandler_BaseFactory;\n    return function UnknownErrorHandler_Factory(t) {\n      return (ɵUnknownErrorHandler_BaseFactory || (ɵUnknownErrorHandler_BaseFactory = i0.ɵɵgetInheritedFactory(UnknownErrorHandler)))(t || UnknownErrorHandler);\n    };\n  }();\n  UnknownErrorHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UnknownErrorHandler,\n    factory: UnknownErrorHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return UnknownErrorHandler;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HttpErrorInterceptor = /*#__PURE__*/(() => {\n  class HttpErrorInterceptor {\n    constructor(handlers) {\n      this.handlers = handlers;\n    }\n    intercept(request, next) {\n      return next.handle(request).pipe(catchError(response => {\n        if (response instanceof HttpErrorResponse) {\n          this.handleErrorResponse(request, response);\n          return throwError(response);\n        }\n      }));\n    }\n    handleErrorResponse(request, response) {\n      const handler = this.getResponseHandler(response);\n      if (handler) {\n        handler.handleError(request, response);\n      }\n    }\n    /**\n     * return the error handler that matches the `HttpResponseStatus` code.\n     * If no handler is available, the UNKNOWN handler is returned.\n     */\n    getResponseHandler(response) {\n      return resolveApplicable(this.handlers, [response]);\n    }\n  }\n  HttpErrorInterceptor.ɵfac = function HttpErrorInterceptor_Factory(t) {\n    return new (t || HttpErrorInterceptor)(i0.ɵɵinject(HttpErrorHandler));\n  };\n  HttpErrorInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: HttpErrorInterceptor,\n    factory: HttpErrorInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return HttpErrorInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst errorHandlers = [{\n  provide: HttpErrorHandler,\n  useExisting: UnknownErrorHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: BadGatewayHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: BadRequestHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: ConflictHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: ForbiddenHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: GatewayTimeoutHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: InternalServerErrorHandler,\n  multi: true\n}, {\n  provide: HttpErrorHandler,\n  useExisting: NotFoundHandler,\n  multi: true\n}];\nconst httpErrorInterceptors = [{\n  provide: HTTP_INTERCEPTORS,\n  useExisting: HttpErrorInterceptor,\n  multi: true\n}];\nconst initialState$j = {\n  entities: {}\n};\nfunction reducer$j(state = initialState$j, action) {\n  switch (action.type) {\n    case ADD_MESSAGE:\n      {\n        const message = action.payload;\n        if (state.entities[message.type] === undefined) {\n          return Object.assign(Object.assign({}, state), {\n            entities: Object.assign(Object.assign({}, state.entities), {\n              [message.type]: [message.text]\n            })\n          });\n        } else {\n          const currentMessages = state.entities[message.type];\n          return Object.assign(Object.assign({}, state), {\n            entities: Object.assign(Object.assign({}, state.entities), {\n              [message.type]: [...currentMessages, message.text]\n            })\n          });\n        }\n      }\n    case REMOVE_MESSAGE:\n      {\n        const msgType = action.payload.type;\n        const msgIndex = action.payload.index;\n        if (Object.keys(state.entities).length === 0 || !state.entities[msgType]) {\n          return state;\n        }\n        const messages = [...state.entities[msgType]];\n        messages.splice(msgIndex, 1);\n        return Object.assign(Object.assign({}, state), {\n          entities: Object.assign(Object.assign({}, state.entities), {\n            [msgType]: messages\n          })\n        });\n      }\n    case REMOVE_MESSAGES_BY_TYPE:\n      {\n        const entities = Object.assign(Object.assign({}, state.entities), {\n          [action.payload]: []\n        });\n        return Object.assign(Object.assign({}, state), {\n          entities\n        });\n      }\n  }\n  return state;\n}\nfunction getReducers$3() {\n  return reducer$j;\n}\nconst reducerToken$3 = new InjectionToken('GlobalMessageReducers');\nconst reducerProvider$3 = {\n  provide: reducerToken$3,\n  useFactory: getReducers$3\n};\nlet GlobalMessageStoreModule = /*#__PURE__*/(() => {\n  class GlobalMessageStoreModule {}\n  GlobalMessageStoreModule.ɵfac = function GlobalMessageStoreModule_Factory(t) {\n    return new (t || GlobalMessageStoreModule)();\n  };\n  GlobalMessageStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GlobalMessageStoreModule\n  });\n  GlobalMessageStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerProvider$3],\n    imports: [[StateModule, StoreModule.forFeature(GLOBAL_MESSAGE_FEATURE, reducerToken$3)]]\n  });\n  return GlobalMessageStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction shallowEqualObjects(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  if (!objA || !objB) {\n    return false;\n  }\n  const aKeys = Object.keys(objA);\n  const bKeys = Object.keys(objB);\n  const aKeysLen = aKeys.length;\n  const bKeysLen = bKeys.length;\n  if (aKeysLen !== bKeysLen) {\n    return false;\n  }\n  for (let i = 0; i < aKeysLen; i++) {\n    const key = aKeys[i];\n    if (objA[key] !== objB[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepEqualObjects(objA, objB) {\n  if (objA === objB) {\n    return true; // if both objA and objB are null or undefined and exactly the same\n  } else if (!(objA instanceof Object) || !(objB instanceof Object)) {\n    return false; // if they are not strictly equal, they both need to be Objects\n  } else if (objA.constructor !== objB.constructor) {\n    // they must have the exact same prototype chain, the closest we can do is\n    // test their constructor.\n    return false;\n  } else {\n    for (const key in objA) {\n      if (!objA.hasOwnProperty(key)) {\n        continue; // other properties were tested using objA.constructor === y.constructor\n      }\n\n      if (!objB.hasOwnProperty(key)) {\n        return false; // allows to compare objA[ key ] and objB[ key ] when set to undefined\n      }\n\n      if (objA[key] === objB[key]) {\n        continue; // if they have the same strict value or identity then they are equal\n      }\n\n      if (typeof objA[key] !== 'object') {\n        return false; // Numbers, Strings, Functions, Booleans must be strictly equal\n      }\n\n      if (!deepEqualObjects(objA[key], objB[key])) {\n        return false;\n      }\n    }\n    for (const key in objB) {\n      if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfunction countOfDeepEqualObjects(obj, arr) {\n  return arr.reduce((acc, curr) => {\n    if (deepEqualObjects(obj, curr)) {\n      acc++;\n    }\n    return acc;\n  }, 0);\n}\nfunction indexOfFirstOccurrence(obj, arr) {\n  for (let index = 0; index < arr.length; index++) {\n    if (deepEqualObjects(arr[index], obj)) {\n      return index;\n    }\n  }\n}\nlet GlobalMessageEffect = /*#__PURE__*/(() => {\n  class GlobalMessageEffect {\n    constructor(actions$, store, config, platformId) {\n      this.actions$ = actions$;\n      this.store = store;\n      this.config = config;\n      this.platformId = platformId;\n      this.removeDuplicated$ = this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload'), switchMap(message => of(message.text).pipe(withLatestFrom(this.store.pipe(select(getGlobalMessageEntitiesByType(message.type)))), filter(([text, messages]) => countOfDeepEqualObjects(text, messages) > 1), map(([text, messages]) => new RemoveMessage({\n        type: message.type,\n        index: indexOfFirstOccurrence(text, messages)\n      })))));\n      this.hideAfterDelay$ = isPlatformBrowser(this.platformId) // we don't want to run this logic when doing SSR\n      ? this.actions$.pipe(ofType(ADD_MESSAGE), pluck('payload'), concatMap(message => {\n        const config = this.config.globalMessages[message.type];\n        return this.store.pipe(select(getGlobalMessageCountByType(message.type)), take(1), filter(count => (config && config.timeout !== undefined || message.timeout) && count && count > 0), delay(message.timeout || config.timeout), switchMap(() => of(new RemoveMessage({\n          type: message.type,\n          index: 0\n        }))));\n      })) : EMPTY;\n    }\n  }\n  GlobalMessageEffect.ɵfac = function GlobalMessageEffect_Factory(t) {\n    return new (t || GlobalMessageEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(GlobalMessageConfig), i0.ɵɵinject(PLATFORM_ID));\n  };\n  GlobalMessageEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: GlobalMessageEffect,\n    factory: GlobalMessageEffect.ɵfac\n  });\n  __decorate([Effect()], GlobalMessageEffect.prototype, \"removeDuplicated$\", void 0);\n  __decorate([Effect()], GlobalMessageEffect.prototype, \"hideAfterDelay$\", void 0);\n  return GlobalMessageEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction defaultGlobalMessageConfigFactory() {\n  return {\n    globalMessages: {\n      [GlobalMessageType.MSG_TYPE_CONFIRMATION]: {\n        timeout: 3000\n      },\n      [GlobalMessageType.MSG_TYPE_INFO]: {\n        timeout: 3000\n      },\n      [GlobalMessageType.MSG_TYPE_ERROR]: {\n        timeout: 7000\n      },\n      [GlobalMessageType.MSG_TYPE_WARNING]: {\n        timeout: 7000\n      }\n    }\n  };\n}\nlet GlobalMessageModule = /*#__PURE__*/(() => {\n  class GlobalMessageModule {\n    static forRoot() {\n      return {\n        ngModule: GlobalMessageModule,\n        providers: [...errorHandlers, ...httpErrorInterceptors]\n      };\n    }\n  }\n  GlobalMessageModule.ɵfac = function GlobalMessageModule_Factory(t) {\n    return new (t || GlobalMessageModule)();\n  };\n  GlobalMessageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GlobalMessageModule\n  });\n  GlobalMessageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfigFactory(defaultGlobalMessageConfigFactory)],\n    imports: [[GlobalMessageStoreModule, EffectsModule.forFeature([GlobalMessageEffect])]]\n  });\n  return GlobalMessageModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet I18nConfig = /*#__PURE__*/(() => {\n  class I18nConfig {}\n  I18nConfig.ɵfac = function I18nConfig_Factory(t) {\n    return new (t || I18nConfig)();\n  };\n  I18nConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: I18nConfig,\n    factory: function I18nConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || I18nConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return I18nConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet I18nConfigInitializer = /*#__PURE__*/(() => {\n  class I18nConfigInitializer {\n    constructor(configInit) {\n      this.configInit = configInit;\n      this.scopes = ['i18n.fallbackLang'];\n      this.configFactory = () => this.resolveConfig().toPromise();\n    }\n    /**\n     * Resolves the `fallbackLang` based on the default language from config `context.language` .\n     */\n    resolveConfig() {\n      return this.configInit.getStable('context.language').pipe(map(config => {\n        var _a, _b;\n        return {\n          i18n: {\n            // the first language in the array is the default one\n            fallbackLang: (_b = (_a = config === null || config === void 0 ? void 0 : config.context) === null || _a === void 0 ? void 0 : _a.language) === null || _b === void 0 ? void 0 : _b[0]\n          }\n        };\n      }));\n    }\n  }\n  I18nConfigInitializer.ɵfac = function I18nConfigInitializer_Factory(t) {\n    return new (t || I18nConfigInitializer)(i0.ɵɵinject(ConfigInitializerService));\n  };\n  I18nConfigInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: I18nConfigInitializer,\n    factory: I18nConfigInitializer.ɵfac,\n    providedIn: 'root'\n  });\n  return I18nConfigInitializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// type CxDatePipe, not DatePipe, due to conflict with Angular's DatePipe - problem occurs for the backward compatibility compiler of Ivy\nlet CxDatePipe = /*#__PURE__*/(() => {\n  class CxDatePipe extends DatePipe {\n    constructor(language) {\n      super(null);\n      this.language = language;\n    }\n    transform(value, format, timezone) {\n      return super.transform(value, format, timezone, this.getLang());\n    }\n    getLang() {\n      const lang = this.getActiveLang();\n      try {\n        getLocaleId(lang);\n        return lang;\n      } catch (_a) {\n        this.reportMissingLocaleData(lang);\n        return 'en';\n      }\n    }\n    getActiveLang() {\n      let result;\n      this.language.getActive().subscribe(lang => result = lang).unsubscribe();\n      return result;\n    }\n    reportMissingLocaleData(lang) {\n      if (isDevMode()) {\n        console.warn(`cxDate pipe: No locale data registered for '${lang}' (see https://angular.io/api/common/registerLocaleData).`);\n      }\n    }\n  }\n  CxDatePipe.ɵfac = function CxDatePipe_Factory(t) {\n    return new (t || CxDatePipe)(i0.ɵɵdirectiveInject(LanguageService, 16));\n  };\n  CxDatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxDate\",\n    type: CxDatePipe,\n    pure: true\n  });\n  return CxDatePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CxNumericPipe = /*#__PURE__*/(() => {\n  class CxNumericPipe extends DecimalPipe {\n    constructor(language) {\n      super(null);\n      this.language = language;\n    }\n    transform(value, digitsInfo) {\n      return super.transform(value, digitsInfo, this.getLang());\n    }\n    getLang() {\n      const lang = this.getActiveLang();\n      try {\n        getLocaleId(lang);\n        return lang;\n      } catch (_a) {\n        this.reportMissingLocaleData(lang);\n        return 'en';\n      }\n    }\n    getActiveLang() {\n      let result;\n      this.language.getActive().subscribe(lang => result = lang).unsubscribe();\n      return result;\n    }\n    reportMissingLocaleData(lang) {\n      if (isDevMode()) {\n        console.warn(`cxNumeric pipe: No locale data registered for '${lang}' (see https://angular.io/api/common/registerLocaleData).`);\n      }\n    }\n  }\n  CxNumericPipe.ɵfac = function CxNumericPipe_Factory(t) {\n    return new (t || CxNumericPipe)(i0.ɵɵdirectiveInject(LanguageService, 16));\n  };\n  CxNumericPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxNumeric\",\n    type: CxNumericPipe,\n    pure: true\n  });\n  return CxNumericPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultI18nConfig = {\n  i18n: {\n    fallbackLang: undefined,\n    debug: false\n  }\n};\nfunction i18nextInit(i18next, configInit, languageService, httpClient, serverRequestOrigin, siteContextI18nextSynchronizer) {\n  return () => configInit.getStable('i18n').pipe(tap(config => {\n    var _a, _b, _c, _d;\n    let i18nextConfig = {\n      ns: [],\n      fallbackLng: (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.fallbackLang,\n      debug: (_b = config.i18n) === null || _b === void 0 ? void 0 : _b.debug,\n      interpolation: {\n        escapeValue: false\n      }\n    };\n    if ((_d = (_c = config.i18n) === null || _c === void 0 ? void 0 : _c.backend) === null || _d === void 0 ? void 0 : _d.loadPath) {\n      i18next = i18next.use(i18nextHttpBackend);\n      const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);\n      const backend = {\n        loadPath,\n        request: i18nextGetHttpClient(httpClient),\n        // Disable the periodical reloading. Otherwise SSR would not finish due to the pending task `setInterval()`\n        // See source code of `i18next-http-backend` : https://github.com/i18next/i18next-http-backend/blob/00b7e8f67abf8372af17529b51190a7e8b17e3d8/lib/index.js#L40-L41\n        reloadInterval: false\n      };\n      i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), {\n        backend\n      });\n    }\n    return i18next.init(i18nextConfig, () => {\n      var _a;\n      // Don't use i18next's 'resources' config key for adding static translations,\n      // because it will disable loading chunks from backend. We add resources here, in the init's callback.\n      i18nextAddTranslations(i18next, (_a = config.i18n) === null || _a === void 0 ? void 0 : _a.resources);\n      siteContextI18nextSynchronizer.init(i18next, languageService);\n    });\n  })).toPromise();\n}\nfunction i18nextAddTranslations(i18next, resources = {}) {\n  Object.keys(resources).forEach(lang => {\n    Object.keys(resources[lang]).forEach(chunkName => {\n      i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);\n    });\n  });\n}\nlet SiteContextI18nextSynchronizer = /*#__PURE__*/(() => {\n  class SiteContextI18nextSynchronizer {\n    init(i18next, language) {\n      var _a;\n      // always update language of i18next on site context (language) change\n      this.sub = (_a = this.sub) !== null && _a !== void 0 ? _a : language.getActive().subscribe(lang => i18next.changeLanguage(lang));\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n  }\n  SiteContextI18nextSynchronizer.ɵfac = function SiteContextI18nextSynchronizer_Factory(t) {\n    return new (t || SiteContextI18nextSynchronizer)();\n  };\n  SiteContextI18nextSynchronizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextI18nextSynchronizer,\n    factory: SiteContextI18nextSynchronizer.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteContextI18nextSynchronizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Returns a function appropriate for i18next to make http calls for JSON files.\n * See docs for `i18next-http-backend`: https://github.com/i18next/i18next-http-backend#backend-options\n *\n * It uses Angular HttpClient under the hood, so it works in SSR.\n * @param httpClient Angular http client\n */\nfunction i18nextGetHttpClient(httpClient) {\n  return (_options, url, _payload, callback) => {\n    httpClient.get(url, {\n      responseType: 'text'\n    }).subscribe(data => callback(null, {\n      status: 200,\n      data\n    }), error => callback(error, {\n      // a workaround for https://github.com/i18next/i18next-http-backend/issues/82\n      data: null,\n      status: error.status\n    }));\n  };\n}\n/**\n * Resolves the relative path to the absolute one in SSR, using the server request's origin.\n * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:\n * - https://github.com/angular/angular/issues/19224\n * - https://github.com/angular/universal/issues/858\n */\nfunction getLoadPath(path, serverRequestOrigin) {\n  if (serverRequestOrigin && !path.match(/^http(s)?:\\/\\//)) {\n    if (path.startsWith('/')) {\n      path = path.slice(1);\n    }\n    if (path.startsWith('./')) {\n      path = path.slice(2);\n    }\n    const result = `${serverRequestOrigin}/${path}`;\n    return result;\n  }\n  return path;\n}\n\n/**\n * The instance of i18next.\n *\n * Each SSR request gets its own instance of i18next.\n *\n * The reference to the static global instance of `i18next` (`import i18next from 'i18next`)\n * should not be used anywhere else, because otherwise it would be shared in between all SSR requests\n * and can cause concurrency issues.\n */\nconst I18NEXT_INSTANCE = new InjectionToken('I18NEXT_INSTANCE', {\n  providedIn: 'root',\n  factory: () => i18next.createInstance()\n});\nconst i18nextProviders = [{\n  provide: APP_INITIALIZER,\n  useFactory: i18nextInit,\n  deps: [I18NEXT_INSTANCE, ConfigInitializerService, LanguageService, HttpClient, [new Optional(), SERVER_REQUEST_ORIGIN], SiteContextI18nextSynchronizer],\n  multi: true\n}];\nlet TranslationChunkService = /*#__PURE__*/(() => {\n  class TranslationChunkService {\n    constructor(config) {\n      this.config = config;\n      this.duplicates = {};\n      this.chunks = {};\n      this.KEY_SEPARATOR = '.';\n      const chunks = config.i18n && config.i18n.chunks || {};\n      Object.keys(chunks).forEach(chunk => {\n        chunks[chunk].forEach(key => {\n          if (this.chunks.hasOwnProperty(key)) {\n            if (!this.duplicates[key]) {\n              this.duplicates[key] = [this.chunks[key]];\n            }\n            this.duplicates[key].push(chunk);\n          } else {\n            this.chunks[key] = chunk;\n          }\n        });\n      });\n      if (Object.keys(this.duplicates).length > 0 && isDevMode()) {\n        this.warnDuplicates(this.duplicates);\n      }\n    }\n    getChunkNameForKey(key) {\n      const mainKey = (key || '').split(this.KEY_SEPARATOR)[0];\n      const chunk = this.chunks && this.chunks[mainKey];\n      if (!chunk) {\n        return mainKey; // fallback to main key as a chunk\n      }\n\n      return chunk;\n    }\n    warnDuplicates(items) {\n      const dupes = [];\n      Object.keys(items).forEach(key => {\n        dupes.push(`* '${key}' found in chunks: ${items[key].join(', ')}. Used '${this.chunks[key]}.${key}'.`);\n      });\n      console.warn(`Duplicated keys has been found in the config of i18n chunks:\\n${dupes.join('\\n')}`);\n    }\n  }\n  TranslationChunkService.ɵfac = function TranslationChunkService_Factory(t) {\n    return new (t || TranslationChunkService)(i0.ɵɵinject(I18nConfig));\n  };\n  TranslationChunkService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TranslationChunkService,\n    factory: TranslationChunkService.ɵfac,\n    providedIn: 'root'\n  });\n  return TranslationChunkService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet I18nextTranslationService = /*#__PURE__*/(() => {\n  class I18nextTranslationService {\n    constructor(config, translationChunk,\n    // Required param added in 3.0.x as a critical bug fix, not subject to the breaking changes policy\n    i18next) {\n      this.config = config;\n      this.translationChunk = translationChunk;\n      this.i18next = i18next;\n      this.NON_BREAKING_SPACE = String.fromCharCode(160);\n      this.NAMESPACE_SEPARATOR = ':';\n    }\n    translate(key, options = {}, whitespaceUntilLoaded = false) {\n      // If we've already loaded the chunk (or failed to load), we should immediately emit the value\n      // (or the fallback value in case the key is missing).\n      // Moreover, we SHOULD emit a value (or a fallback value) synchronously (not in a promise/setTimeout).\n      // Otherwise, we the will trigger additional deferred change detection in a view that consumes the returned observable,\n      // which together with `switchMap` operator may lead to an infinite loop.\n      const chunkName = this.translationChunk.getChunkNameForKey(key);\n      const namespacedKey = this.getNamespacedKey(key, chunkName);\n      return new Observable(subscriber => {\n        const translate = () => {\n          if (!this.i18next.isInitialized) {\n            return;\n          }\n          if (this.i18next.exists(namespacedKey, options)) {\n            subscriber.next(this.i18next.t(namespacedKey, options));\n          } else {\n            if (whitespaceUntilLoaded) {\n              subscriber.next(this.NON_BREAKING_SPACE);\n            }\n            this.i18next.loadNamespaces(chunkName, () => {\n              if (!this.i18next.exists(namespacedKey, options)) {\n                this.reportMissingKey(key, chunkName);\n                subscriber.next(this.getFallbackValue(namespacedKey));\n              } else {\n                subscriber.next(this.i18next.t(namespacedKey, options));\n              }\n            });\n          }\n        };\n        translate();\n        this.i18next.on('languageChanged', translate);\n        return () => this.i18next.off('languageChanged', translate);\n      });\n    }\n    loadChunks(chunkNames) {\n      return this.i18next.loadNamespaces(chunkNames);\n    }\n    /**\n     * Returns a fallback value in case when the given key is missing\n     * @param key\n     */\n    getFallbackValue(key) {\n      return isDevMode() ? `[${key}]` : this.NON_BREAKING_SPACE;\n    }\n    reportMissingKey(key, chunkName) {\n      if (isDevMode()) {\n        console.warn(`Translation key missing '${key}' in the chunk '${chunkName}'`);\n      }\n    }\n    getNamespacedKey(key, chunk) {\n      return chunk + this.NAMESPACE_SEPARATOR + key;\n    }\n  }\n  I18nextTranslationService.ɵfac = function I18nextTranslationService_Factory(t) {\n    return new (t || I18nextTranslationService)(i0.ɵɵinject(I18nConfig), i0.ɵɵinject(TranslationChunkService), i0.ɵɵinject(I18NEXT_INSTANCE));\n  };\n  I18nextTranslationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: I18nextTranslationService,\n    factory: I18nextTranslationService.ɵfac,\n    providedIn: 'root'\n  });\n  return I18nextTranslationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TranslatePipe = /*#__PURE__*/(() => {\n  class TranslatePipe {\n    constructor(service, cd) {\n      this.service = service;\n      this.cd = cd;\n    }\n    transform(input, options = {}) {\n      if (!input) {\n        if (isDevMode()) {\n          console.error(`The given input for the cxTranslate pipe (${input}) is invalid and cannot be translated`);\n        }\n        return;\n      }\n      if (input.raw) {\n        return input.raw;\n      }\n      const key = typeof input === 'string' ? input : input.key;\n      if (typeof input !== 'string') {\n        options = Object.assign(Object.assign({}, options), input.params);\n      }\n      this.translate(key, options);\n      return this.translatedValue;\n    }\n    translate(key, options) {\n      if (key !== this.lastKey || !shallowEqualObjects(options, this.lastOptions)) {\n        this.lastKey = key;\n        this.lastOptions = options;\n        if (this.sub) {\n          this.sub.unsubscribe();\n        }\n        this.sub = this.service.translate(key, options, true).subscribe(val => this.markForCheck(val));\n      }\n    }\n    markForCheck(value) {\n      this.translatedValue = value;\n      this.cd.markForCheck();\n    }\n    ngOnDestroy() {\n      if (this.sub) {\n        this.sub.unsubscribe();\n      }\n    }\n  }\n  TranslatePipe.ɵfac = function TranslatePipe_Factory(t) {\n    return new (t || TranslatePipe)(i0.ɵɵdirectiveInject(TranslationService, 16), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  };\n  TranslatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxTranslate\",\n    type: TranslatePipe,\n    pure: false\n  });\n  return TranslatePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction initI18nConfig(configInitializer, config) {\n  var _a;\n  /**\n   * If `fallbackLang` was already configured statically\n   */\n  if (((_a = config === null || config === void 0 ? void 0 : config.i18n) === null || _a === void 0 ? void 0 : _a.fallbackLang) !== undefined) {\n    return null;\n  }\n  return configInitializer;\n}\nlet I18nModule = /*#__PURE__*/(() => {\n  class I18nModule {\n    static forRoot() {\n      return {\n        ngModule: I18nModule,\n        providers: [provideDefaultConfig(defaultI18nConfig), {\n          provide: TranslationService,\n          useExisting: I18nextTranslationService\n        }, ...i18nextProviders, {\n          provide: CONFIG_INITIALIZER,\n          useFactory: initI18nConfig,\n          deps: [I18nConfigInitializer, I18nConfig],\n          multi: true\n        }]\n      };\n    }\n  }\n  I18nModule.ɵfac = function I18nModule_Factory(t) {\n    return new (t || I18nModule)();\n  };\n  I18nModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: I18nModule\n  });\n  I18nModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return I18nModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction mockTranslate(key, options = {}) {\n  const optionsString = Object.keys(options).sort().map(optionName => `${optionName}:${options[optionName]}`).join(' ');\n  return optionsString ? `${key} ${optionsString}` : key;\n}\nlet MockTranslatePipe = /*#__PURE__*/(() => {\n  class MockTranslatePipe {\n    transform(input, options = {}) {\n      if (input.raw) {\n        return input.raw;\n      }\n      const key = typeof input === 'string' ? input : input.key;\n      if (typeof input !== 'string') {\n        options = Object.assign(Object.assign({}, options), input.params);\n      }\n      return mockTranslate(key, options);\n    }\n  }\n  MockTranslatePipe.ɵfac = function MockTranslatePipe_Factory(t) {\n    return new (t || MockTranslatePipe)();\n  };\n  MockTranslatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxTranslate\",\n    type: MockTranslatePipe,\n    pure: true\n  });\n  return MockTranslatePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MockTranslationService = /*#__PURE__*/(() => {\n  class MockTranslationService {\n    translate(key, options = {}, _whitespaceUntilLoaded = false) {\n      return new Observable(subscriber => {\n        const value = mockTranslate(key, options);\n        subscriber.next(value);\n        subscriber.complete();\n      });\n    }\n    loadChunks(_chunks) {\n      return Promise.resolve();\n    }\n  }\n  MockTranslationService.ɵfac = function MockTranslationService_Factory(t) {\n    return new (t || MockTranslationService)();\n  };\n  MockTranslationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MockTranslationService,\n    factory: MockTranslationService.ɵfac\n  });\n  return MockTranslationService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MockDatePipe = /*#__PURE__*/(() => {\n  class MockDatePipe extends DatePipe {\n    // Overload to support stricter type check from angular 11 onwards\n    transform(value, format, timezone, locale = 'en') {\n      return super.transform(value, format, timezone, locale);\n    }\n  }\n  MockDatePipe.ɵfac = /* @__PURE__ */function () {\n    let ɵMockDatePipe_BaseFactory;\n    return function MockDatePipe_Factory(t) {\n      return (ɵMockDatePipe_BaseFactory || (ɵMockDatePipe_BaseFactory = i0.ɵɵgetInheritedFactory(MockDatePipe)))(t || MockDatePipe);\n    };\n  }();\n  MockDatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"cxDate\",\n    type: MockDatePipe,\n    pure: true\n  });\n  return MockDatePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet I18nTestingModule = /*#__PURE__*/(() => {\n  class I18nTestingModule {}\n  I18nTestingModule.ɵfac = function I18nTestingModule_Factory(t) {\n    return new (t || I18nTestingModule)();\n  };\n  I18nTestingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: I18nTestingModule\n  });\n  I18nTestingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: TranslationService,\n      useClass: MockTranslationService\n    }]\n  });\n  return I18nTestingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst COST_CENTER_NORMALIZER = new InjectionToken('CostCenterNormalizer');\nconst COST_CENTERS_NORMALIZER = new InjectionToken('CostCentersListNormalizer');\nconst COST_CENTER_SERIALIZER = new InjectionToken('CostCenterSerializer');\nlet CostCenterModule = /*#__PURE__*/(() => {\n  class CostCenterModule {\n    static forRoot() {\n      return {\n        ngModule: CostCenterModule,\n        providers: []\n      };\n    }\n  }\n  CostCenterModule.ɵfac = function CostCenterModule_Factory(t) {\n    return new (t || CostCenterModule)();\n  };\n  CostCenterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CostCenterModule\n  });\n  CostCenterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return CostCenterModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRODUCT_NORMALIZER = new InjectionToken('ProductNormalizer');\nlet ConverterService = /*#__PURE__*/(() => {\n  class ConverterService {\n    constructor(unifiedInjector) {\n      this.unifiedInjector = unifiedInjector;\n      this.subscriptions = new Subscription();\n      this.converters = new Map();\n      // Clear cached converters when new injectors appear\n      const cacheResetLogic = this.unifiedInjector.injectors$.pipe(tap(() => this.converters.clear()));\n      this.subscriptions.add(cacheResetLogic.subscribe());\n    }\n    getConverters(injectionToken) {\n      if (!this.converters.has(injectionToken)) {\n        const converters = getLastValueSync(this.unifiedInjector.getMulti(injectionToken));\n        this.converters.set(injectionToken, converters);\n      }\n      return this.converters.get(injectionToken);\n    }\n    /**\n     * Will return true if converters for specified token were provided\n     */\n    hasConverters(injectionToken) {\n      const converters = this.getConverters(injectionToken);\n      return Array.isArray(converters) && converters.length > 0;\n    }\n    /**\n     * Pipeable operator to apply converter logic in a observable stream\n     */\n    pipeable(injectionToken) {\n      if (this.hasConverters(injectionToken)) {\n        return map(model => this.convertSource(model, injectionToken));\n      } else {\n        return observable => observable;\n      }\n    }\n    /**\n     * Pipeable operator to apply converter logic in a observable stream to collection of items\n     */\n    pipeableMany(injectionToken) {\n      if (this.hasConverters(injectionToken)) {\n        return map(model => this.convertMany(model, injectionToken));\n      } else {\n        return observable => observable;\n      }\n    }\n    /**\n     * Apply converter logic specified by injection token to source data\n     */\n    convert(source, injectionToken) {\n      if (this.hasConverters(injectionToken)) {\n        return this.convertSource(source, injectionToken);\n      } else {\n        return source;\n      }\n    }\n    /**\n     * Apply converter logic specified by injection token to a collection\n     */\n    convertMany(sources, injectionToken) {\n      if (this.hasConverters(injectionToken) && Array.isArray(sources)) {\n        return sources.map(source => this.convertSource(source, injectionToken));\n      } else {\n        return sources;\n      }\n    }\n    convertSource(source, injectionToken) {\n      return this.getConverters(injectionToken).reduce((target, converter) => {\n        return converter.convert(source, target);\n      }, undefined);\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  ConverterService.ɵfac = function ConverterService_Factory(t) {\n    return new (t || ConverterService)(i0.ɵɵinject(UnifiedInjector));\n  };\n  ConverterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConverterService,\n    factory: ConverterService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConverterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OrderEntryPromotionsService = /*#__PURE__*/(() => {\n  class OrderEntryPromotionsService {\n    /**\n     * Get consumed promotions for the given order entry\n     *\n     * @param item\n     * @param promotions\n     * @returns consumed promotions for this entry\n     */\n    getProductPromotion(item, promotions) {\n      const entryPromotions = [];\n      if (promotions && promotions.length > 0) {\n        for (const promotion of promotions) {\n          if (promotion.description && promotion.consumedEntries && promotion.consumedEntries.length > 0) {\n            for (const consumedEntry of promotion.consumedEntries) {\n              if (this.isConsumedByEntry(consumedEntry, item)) {\n                entryPromotions.push(promotion);\n              }\n            }\n          }\n        }\n      }\n      return entryPromotions;\n    }\n    isConsumedByEntry(consumedEntry, entry) {\n      const consumedEntryNumber = consumedEntry.orderEntryNumber;\n      if (entry && entry.entries && entry.entries.length > 0) {\n        for (const subEntry of entry.entries) {\n          if (subEntry.entryNumber === consumedEntryNumber) {\n            return true;\n          }\n        }\n        return false;\n      } else {\n        return consumedEntryNumber === (entry === null || entry === void 0 ? void 0 : entry.entryNumber);\n      }\n    }\n  }\n  OrderEntryPromotionsService.ɵfac = function OrderEntryPromotionsService_Factory(t) {\n    return new (t || OrderEntryPromotionsService)();\n  };\n  OrderEntryPromotionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OrderEntryPromotionsService,\n    factory: OrderEntryPromotionsService.ɵfac,\n    providedIn: 'root'\n  });\n  return OrderEntryPromotionsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCartNormalizer = /*#__PURE__*/(() => {\n  class OccCartNormalizer {\n    constructor(converter, entryPromotionService) {\n      this.converter = converter;\n      this.entryPromotionService = entryPromotionService;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      this.removeDuplicatePromotions(source, target);\n      if (source.entries) {\n        target.entries = source.entries.map(entry => Object.assign(Object.assign({}, entry), {\n          product: this.converter.convert(entry.product, PRODUCT_NORMALIZER),\n          promotions: this.entryPromotionService ? this.entryPromotionService.getProductPromotion(entry, target === null || target === void 0 ? void 0 : target.appliedProductPromotions) : []\n        }));\n      }\n      return target;\n    }\n    /**\n     * Remove all duplicate promotions\n     */\n    removeDuplicatePromotions(source, target) {\n      if (source && source.potentialOrderPromotions) {\n        target.potentialOrderPromotions = this.removeDuplicateItems(source.potentialOrderPromotions);\n      }\n      if (source && source.potentialProductPromotions) {\n        target.potentialProductPromotions = this.removeDuplicateItems(source.potentialProductPromotions);\n      }\n      if (source && source.appliedOrderPromotions) {\n        target.appliedOrderPromotions = this.removeDuplicateItems(source.appliedOrderPromotions);\n      }\n      if (source && source.appliedProductPromotions) {\n        target.appliedProductPromotions = this.removeDuplicateItems(source.appliedProductPromotions);\n      }\n    }\n    removeDuplicateItems(itemList) {\n      return itemList.filter((p, i, a) => {\n        const b = a.map(el => JSON.stringify(el));\n        return i === b.indexOf(JSON.stringify(p));\n      });\n    }\n  }\n  OccCartNormalizer.ɵfac = function OccCartNormalizer_Factory(t) {\n    return new (t || OccCartNormalizer)(i0.ɵɵinject(ConverterService), i0.ɵɵinject(OrderEntryPromotionsService));\n  };\n  OccCartNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCartNormalizer,\n    factory: OccCartNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCartNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultOccCartConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        /* eslint-disable max-len */\n        carts: 'users/${userId}/carts?fields=carts(DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user,saveTime,name,description)',\n        cart: 'users/${userId}/carts/${cartId}?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user,saveTime,name,description',\n        createCart: 'users/${userId}/carts?fields=DEFAULT,potentialProductPromotions,appliedProductPromotions,potentialOrderPromotions,appliedOrderPromotions,entries(totalPrice(formattedValue),product(images(FULL),stock(FULL)),basePrice(formattedValue,value),updateable),totalPrice(formattedValue),totalItems,totalPriceWithTax(formattedValue),totalDiscounts(value,formattedValue),subTotal(formattedValue),deliveryItemsQuantity,deliveryCost(formattedValue),totalTax(formattedValue, value),pickupItemsQuantity,net,appliedVouchers,productDiscounts(formattedValue),user',\n        addEntries: 'users/${userId}/carts/${cartId}/entries',\n        updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',\n        removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',\n        addEmail: 'users/${userId}/carts/${cartId}/email',\n        deleteCart: 'users/${userId}/carts/${cartId}',\n        cartVoucher: 'users/${userId}/carts/${cartId}/vouchers',\n        saveCart: 'users/${userId}/carts/${cartId}/save',\n        validate: 'users/${userId}/carts/${cartId}/validate?fields=DEFAULT'\n        /* eslint-enable */\n      }\n    }\n  }\n};\nlet OccCartEntryAdapter = /*#__PURE__*/(() => {\n  class OccCartEntryAdapter {\n    constructor(http, occEndpointsService, converterService) {\n      this.http = http;\n      this.occEndpointsService = occEndpointsService;\n      this.converterService = converterService;\n    }\n    add(userId, cartId, productCode, quantity = 1) {\n      const url = this.occEndpointsService.buildUrl('addEntries', {\n        urlParams: {\n          userId,\n          cartId,\n          quantity\n        }\n      });\n      // Handle b2b case where the x-www-form-urlencoded is still used\n      if (url.includes(`quantity=${quantity}`)) {\n        const headers = new HttpHeaders({\n          'Content-Type': 'application/x-www-form-urlencoded'\n        });\n        return this.http.post(url, {}, {\n          headers,\n          params: {\n            code: productCode\n          }\n        }).pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n      }\n      const toAdd = {\n        quantity,\n        product: {\n          code: productCode\n        }\n      };\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.post(url, toAdd, {\n        headers\n      }).pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    update(userId, cartId, entryNumber, qty, pickupStore) {\n      let params = {};\n      if (pickupStore) {\n        params = {\n          deliveryPointOfService: {\n            name: pickupStore\n          }\n        };\n      }\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      const url = this.occEndpointsService.buildUrl('updateEntries', {\n        urlParams: {\n          userId,\n          cartId,\n          entryNumber\n        }\n      });\n      return this.http.patch(url, Object.assign({\n        quantity: qty\n      }, params), {\n        headers\n      }).pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));\n    }\n    remove(userId, cartId, entryNumber) {\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      const url = this.occEndpointsService.buildUrl('removeEntries', {\n        urlParams: {\n          userId,\n          cartId,\n          entryNumber\n        }\n      });\n      return this.http.delete(url, {\n        headers\n      });\n    }\n  }\n  OccCartEntryAdapter.ɵfac = function OccCartEntryAdapter_Factory(t) {\n    return new (t || OccCartEntryAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCartEntryAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCartEntryAdapter,\n    factory: OccCartEntryAdapter.ɵfac\n  });\n  return OccCartEntryAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCartVoucherAdapter = /*#__PURE__*/(() => {\n  class OccCartVoucherAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    getCartVoucherEndpoint(userId, cartId) {\n      return this.occEndpoints.buildUrl('cartVoucher', {\n        urlParams: {\n          userId,\n          cartId\n        }\n      });\n    }\n    getHeaders(userId) {\n      let headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      if (userId === OCC_USER_ID_ANONYMOUS) {\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n      }\n      return headers;\n    }\n    add(userId, cartId, voucherId) {\n      const url = this.getCartVoucherEndpoint(userId, cartId);\n      const toAdd = JSON.stringify({});\n      const params = new HttpParams().set('voucherId', voucherId);\n      const headers = this.getHeaders(userId);\n      return this.http.post(url, toAdd, {\n        headers,\n        params\n      }).pipe(catchError(error => throwError(error)), this.converter.pipeable(CART_VOUCHER_NORMALIZER));\n    }\n    remove(userId, cartId, voucherId) {\n      const url = this.getCartVoucherEndpoint(userId, cartId) + '/' + encodeURIComponent(voucherId);\n      const headers = this.getHeaders(userId);\n      return this.http.delete(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccCartVoucherAdapter.ɵfac = function OccCartVoucherAdapter_Factory(t) {\n    return new (t || OccCartVoucherAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCartVoucherAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCartVoucherAdapter,\n    factory: OccCartVoucherAdapter.ɵfac\n  });\n  return OccCartVoucherAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCartAdapter = /*#__PURE__*/(() => {\n  class OccCartAdapter {\n    constructor(http, occEndpointsService, converterService) {\n      this.http = http;\n      this.occEndpointsService = occEndpointsService;\n      this.converterService = converterService;\n    }\n    loadAll(userId) {\n      return this.http.get(this.occEndpointsService.buildUrl('carts', {\n        urlParams: {\n          userId\n        }\n      })).pipe(pluck('carts'), this.converterService.pipeableMany(CART_NORMALIZER));\n    }\n    load(userId, cartId) {\n      if (cartId === OCC_CART_ID_CURRENT) {\n        return this.loadAll(userId).pipe(map(carts => {\n          if (carts) {\n            const activeCart = carts.find(cart => {\n              return cart['saveTime'] === undefined;\n            });\n            return activeCart;\n          } else {\n            return null;\n          }\n        }));\n      } else {\n        return this.http.get(this.occEndpointsService.buildUrl('cart', {\n          urlParams: {\n            userId,\n            cartId\n          }\n        })).pipe(this.converterService.pipeable(CART_NORMALIZER));\n      }\n    }\n    create(userId, oldCartId, toMergeCartGuid) {\n      const toAdd = JSON.stringify({});\n      let params = {};\n      if (oldCartId) {\n        params = {\n          oldCartId: oldCartId\n        };\n      }\n      if (toMergeCartGuid) {\n        params['toMergeCartGuid'] = toMergeCartGuid;\n      }\n      return this.http.post(this.occEndpointsService.buildUrl('createCart', {\n        urlParams: {\n          userId\n        },\n        queryParams: params\n      }), toAdd).pipe(this.converterService.pipeable(CART_NORMALIZER));\n    }\n    delete(userId, cartId) {\n      let headers = new HttpHeaders();\n      if (userId === OCC_USER_ID_ANONYMOUS) {\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n      }\n      return this.http.delete(this.occEndpointsService.buildUrl('deleteCart', {\n        urlParams: {\n          userId,\n          cartId\n        }\n      }), {\n        headers\n      });\n    }\n    addEmail(userId, cartId, email) {\n      let headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n      const httpParams = new HttpParams().set('email', email);\n      const url = this.occEndpointsService.buildUrl('addEmail', {\n        urlParams: {\n          userId,\n          cartId\n        }\n      });\n      return this.http.put(url, httpParams, {\n        headers\n      });\n    }\n  }\n  OccCartAdapter.ɵfac = function OccCartAdapter_Factory(t) {\n    return new (t || OccCartAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCartAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCartAdapter,\n    factory: OccCartAdapter.ɵfac\n  });\n  return OccCartAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * TODO(#11938): 4.0: use OccSavedCartAdapter instead from saved-cart feature-lib of cart\n *\n * When the saved cart feature module exist, there exist a race condition between the 'saveCart' key for the default occ config\n * Allows wishlist to function when the key value is pulled from the saved-cart feature-lib\n *\n * Keep in mind that this adapter will be removed in 4.0 as we will delegate this functionality to the saved-cart feature-lib\n **/\nlet OccSaveCartAdapter = /*#__PURE__*/(() => {\n  class OccSaveCartAdapter {\n    constructor(http, occEndpointsService, converterService) {\n      this.http = http;\n      this.occEndpointsService = occEndpointsService;\n      this.converterService = converterService;\n    }\n    saveCart(userId, cartId, saveCartName, saveCartDescription) {\n      let httpParams = new HttpParams();\n      if (Boolean(saveCartName)) {\n        httpParams = httpParams.set('saveCartName', saveCartName);\n      }\n      if (Boolean(saveCartDescription)) {\n        httpParams = httpParams.set('saveCartDescription', saveCartDescription);\n      }\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      return !this.occEndpointsService.buildUrl('saveCart', {\n        urlParams: {\n          userId,\n          cartId\n        }\n      }).includes('saveCartName') ? this.http.patch(this.occEndpointsService.buildUrl('saveCart', {\n        urlParams: {\n          userId,\n          cartId\n        }\n      }), httpParams, {\n        headers\n      }).pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER)) : this.http.patch(this.occEndpointsService.buildUrl('saveCart', {\n        urlParams: {\n          userId,\n          cartId,\n          saveCartName,\n          saveCartDescription\n        }\n      }), cartId).pipe(this.converterService.pipeable(SAVE_CART_NORMALIZER));\n    }\n  }\n  OccSaveCartAdapter.ɵfac = function OccSaveCartAdapter_Factory(t) {\n    return new (t || OccSaveCartAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccSaveCartAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccSaveCartAdapter,\n    factory: OccSaveCartAdapter.ɵfac\n  });\n  return OccSaveCartAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCartValidationAdapter = /*#__PURE__*/(() => {\n  class OccCartValidationAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    validate(cartId, userId) {\n      const url = this.occEndpoints.buildUrl('validate', {\n        urlParams: {\n          cartId,\n          userId\n        }\n      });\n      return this.http.post(url, null).pipe(catchError(error => throwError(normalizeHttpError(error))), this.converter.pipeable(CART_VALIDATION_NORMALIZER));\n    }\n  }\n  OccCartValidationAdapter.ɵfac = function OccCartValidationAdapter_Factory(t) {\n    return new (t || OccCartValidationAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCartValidationAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCartValidationAdapter,\n    factory: OccCartValidationAdapter.ɵfac\n  });\n  return OccCartValidationAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CartOccModule = /*#__PURE__*/(() => {\n  class CartOccModule {}\n  CartOccModule.ɵfac = function CartOccModule_Factory(t) {\n    return new (t || CartOccModule)();\n  };\n  CartOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CartOccModule\n  });\n  CartOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccCartConfig), {\n      provide: CartAdapter,\n      useClass: OccCartAdapter\n    }, {\n      provide: CART_NORMALIZER,\n      useExisting: OccCartNormalizer,\n      multi: true\n    }, {\n      provide: CartEntryAdapter,\n      useClass: OccCartEntryAdapter\n    }, {\n      provide: CartVoucherAdapter,\n      useClass: OccCartVoucherAdapter\n    }, {\n      provide: SaveCartAdapter,\n      useClass: OccSaveCartAdapter\n    }, {\n      provide: CartValidationAdapter,\n      useClass: OccCartValidationAdapter\n    }],\n    imports: [[CommonModule]]\n  });\n  return CartOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCmsComponentAdapter = /*#__PURE__*/(() => {\n  class OccCmsComponentAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n      this.headers = new HttpHeaders().set('Content-Type', 'application/json');\n    }\n    load(id, pageContext) {\n      return this.http.get(this.getComponentEndPoint(id, pageContext), {\n        headers: this.headers\n      }).pipe(this.converter.pipeable(CMS_COMPONENT_NORMALIZER));\n    }\n    findComponentsByIds(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {\n      const requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));\n      requestParams['componentIds'] = ids.toString();\n      return this.http.get(this.getComponentsEndpoint(requestParams, fields), {\n        headers: this.headers\n      }).pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));\n    }\n    getComponentEndPoint(id, pageContext) {\n      return this.occEndpoints.buildUrl('component', {\n        urlParams: {\n          id\n        },\n        queryParams: this.getContextParams(pageContext)\n      });\n    }\n    getComponentsEndpoint(requestParams, fields) {\n      return this.occEndpoints.buildUrl('components', {\n        queryParams: Object.assign({\n          fields\n        }, requestParams)\n      });\n    }\n    getPaginationParams(currentPage, pageSize, sort) {\n      const requestParams = {};\n      if (currentPage !== undefined) {\n        requestParams['currentPage'] = currentPage.toString();\n      }\n      if (pageSize !== undefined) {\n        requestParams['pageSize'] = pageSize.toString();\n      }\n      if (sort !== undefined) {\n        requestParams['sort'] = sort;\n      }\n      return requestParams;\n    }\n    getContextParams(pageContext) {\n      let requestParams = {};\n      switch (pageContext.type) {\n        case PageType.PRODUCT_PAGE:\n          {\n            requestParams = {\n              productCode: pageContext.id\n            };\n            break;\n          }\n        case PageType.CATEGORY_PAGE:\n          {\n            requestParams = {\n              categoryCode: pageContext.id\n            };\n            break;\n          }\n        case PageType.CATALOG_PAGE:\n          {\n            requestParams = {\n              catalogCode: pageContext.id\n            };\n            break;\n          }\n      }\n      return requestParams;\n    }\n  }\n  OccCmsComponentAdapter.ɵfac = function OccCmsComponentAdapter_Factory(t) {\n    return new (t || OccCmsComponentAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCmsComponentAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCmsComponentAdapter,\n    factory: OccCmsComponentAdapter.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCmsComponentAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar Occ;\n(function (Occ) {\n  /**\n   * The page robot information is exposed with 4 string values.\n   */\n  let PageRobots;\n  (function (PageRobots) {\n    PageRobots[\"INDEX_FOLLOW\"] = \"INDEX_FOLLOW\";\n    PageRobots[\"NOINDEX_FOLLOW\"] = \"NOINDEX_FOLLOW\";\n    PageRobots[\"INDEX_NOFOLLOW\"] = \"INDEX_NOFOLLOW\";\n    PageRobots[\"NOINDEX_NOFOLLOW\"] = \"NOINDEX_NOFOLLOW\";\n  })(PageRobots = Occ.PageRobots || (Occ.PageRobots = {}));\n  /**\n   * Possible order entry statuses\n   */\n  let OrderEntryStatus;\n  (function (OrderEntryStatus) {\n    OrderEntryStatus[\"Success\"] = \"SUCCESS\";\n    OrderEntryStatus[\"Info\"] = \"INFO\";\n    OrderEntryStatus[\"Warning\"] = \"WARNING\";\n    OrderEntryStatus[\"Error\"] = \"ERROR\";\n  })(OrderEntryStatus = Occ.OrderEntryStatus || (Occ.OrderEntryStatus = {}));\n  /**\n   * Defines values for PriceType.\n   * Possible values include: 'BUY', 'FROM'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: PriceType = <PriceType>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let PriceType;\n  (function (PriceType) {\n    PriceType[\"BUY\"] = \"BUY\";\n    PriceType[\"FROM\"] = \"FROM\";\n  })(PriceType = Occ.PriceType || (Occ.PriceType = {}));\n  /**\n   * Defines values for ImageType.\n   * Possible values include: 'PRIMARY', 'GALLERY'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: ImageType = <ImageType>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let ImageType;\n  (function (ImageType) {\n    ImageType[\"PRIMARY\"] = \"PRIMARY\";\n    ImageType[\"GALLERY\"] = \"GALLERY\";\n  })(ImageType = Occ.ImageType || (Occ.ImageType = {}));\n  /**\n   * Defines values for Fields.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields = <Fields>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields;\n  (function (Fields) {\n    Fields[\"BASIC\"] = \"BASIC\";\n    Fields[\"DEFAULT\"] = \"DEFAULT\";\n    Fields[\"FULL\"] = \"FULL\";\n  })(Fields = Occ.Fields || (Occ.Fields = {}));\n  /**\n   * Defines values for Fields1.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields1 = <Fields1>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields1;\n  (function (Fields1) {\n    Fields1[\"BASIC\"] = \"BASIC\";\n    Fields1[\"DEFAULT\"] = \"DEFAULT\";\n    Fields1[\"FULL\"] = \"FULL\";\n  })(Fields1 = Occ.Fields1 || (Occ.Fields1 = {}));\n  /**\n   * Defines values for Fields2.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields2 = <Fields2>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields2;\n  (function (Fields2) {\n    Fields2[\"BASIC\"] = \"BASIC\";\n    Fields2[\"DEFAULT\"] = \"DEFAULT\";\n    Fields2[\"FULL\"] = \"FULL\";\n  })(Fields2 = Occ.Fields2 || (Occ.Fields2 = {}));\n  /**\n   * Defines values for Fields3.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields3 = <Fields3>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields3;\n  (function (Fields3) {\n    Fields3[\"BASIC\"] = \"BASIC\";\n    Fields3[\"DEFAULT\"] = \"DEFAULT\";\n    Fields3[\"FULL\"] = \"FULL\";\n  })(Fields3 = Occ.Fields3 || (Occ.Fields3 = {}));\n  /**\n   * Defines values for Fields4.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields4 = <Fields4>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields4;\n  (function (Fields4) {\n    Fields4[\"BASIC\"] = \"BASIC\";\n    Fields4[\"DEFAULT\"] = \"DEFAULT\";\n    Fields4[\"FULL\"] = \"FULL\";\n  })(Fields4 = Occ.Fields4 || (Occ.Fields4 = {}));\n  /**\n   * Defines values for Fields5.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields5 = <Fields5>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields5;\n  (function (Fields5) {\n    Fields5[\"BASIC\"] = \"BASIC\";\n    Fields5[\"DEFAULT\"] = \"DEFAULT\";\n    Fields5[\"FULL\"] = \"FULL\";\n  })(Fields5 = Occ.Fields5 || (Occ.Fields5 = {}));\n  /**\n   * Defines values for Fields6.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields6 = <Fields6>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields6;\n  (function (Fields6) {\n    Fields6[\"BASIC\"] = \"BASIC\";\n    Fields6[\"DEFAULT\"] = \"DEFAULT\";\n    Fields6[\"FULL\"] = \"FULL\";\n  })(Fields6 = Occ.Fields6 || (Occ.Fields6 = {}));\n  /**\n   * Defines values for PageType.\n   * Possible values include: 'ContentPage', 'ProductPage', 'CategoryPage',\n   * 'CatalogPage'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: PageType = <PageType>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let PageType;\n  (function (PageType) {\n    PageType[\"CONTENT_PAGE\"] = \"ContentPage\";\n    PageType[\"PRODUCT_PAGE\"] = \"ProductPage\";\n    PageType[\"CATEGORY_PAGE\"] = \"CategoryPage\";\n    PageType[\"CATALOG_PAGE\"] = \"CatalogPage\";\n  })(PageType = Occ.PageType || (Occ.PageType = {}));\n  /**\n   * Defines values for Fields7.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields7 = <Fields7>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields7;\n  (function (Fields7) {\n    Fields7[\"BASIC\"] = \"BASIC\";\n    Fields7[\"DEFAULT\"] = \"DEFAULT\";\n    Fields7[\"FULL\"] = \"FULL\";\n  })(Fields7 = Occ.Fields7 || (Occ.Fields7 = {}));\n  /**\n   * Defines values for Fields8.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields8 = <Fields8>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields8;\n  (function (Fields8) {\n    Fields8[\"BASIC\"] = \"BASIC\";\n    Fields8[\"DEFAULT\"] = \"DEFAULT\";\n    Fields8[\"FULL\"] = \"FULL\";\n  })(Fields8 = Occ.Fields8 || (Occ.Fields8 = {}));\n  /**\n   * Defines values for Fields9.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields9 = <Fields9>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields9;\n  (function (Fields9) {\n    Fields9[\"BASIC\"] = \"BASIC\";\n    Fields9[\"DEFAULT\"] = \"DEFAULT\";\n    Fields9[\"FULL\"] = \"FULL\";\n  })(Fields9 = Occ.Fields9 || (Occ.Fields9 = {}));\n  /**\n   * Defines values for Fields10.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields10 = <Fields10>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields10;\n  (function (Fields10) {\n    Fields10[\"BASIC\"] = \"BASIC\";\n    Fields10[\"DEFAULT\"] = \"DEFAULT\";\n    Fields10[\"FULL\"] = \"FULL\";\n  })(Fields10 = Occ.Fields10 || (Occ.Fields10 = {}));\n  /**\n   * Defines values for Fields11.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields11 = <Fields11>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields11;\n  (function (Fields11) {\n    Fields11[\"BASIC\"] = \"BASIC\";\n    Fields11[\"DEFAULT\"] = \"DEFAULT\";\n    Fields11[\"FULL\"] = \"FULL\";\n  })(Fields11 = Occ.Fields11 || (Occ.Fields11 = {}));\n  /**\n   * Defines values for Fields12.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields12 = <Fields12>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields12;\n  (function (Fields12) {\n    Fields12[\"BASIC\"] = \"BASIC\";\n    Fields12[\"DEFAULT\"] = \"DEFAULT\";\n    Fields12[\"FULL\"] = \"FULL\";\n  })(Fields12 = Occ.Fields12 || (Occ.Fields12 = {}));\n  /**\n   * Defines values for Fields13.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields13 = <Fields13>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields13;\n  (function (Fields13) {\n    Fields13[\"BASIC\"] = \"BASIC\";\n    Fields13[\"DEFAULT\"] = \"DEFAULT\";\n    Fields13[\"FULL\"] = \"FULL\";\n  })(Fields13 = Occ.Fields13 || (Occ.Fields13 = {}));\n  /**\n   * Defines values for Fields14.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields14 = <Fields14>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields14;\n  (function (Fields14) {\n    Fields14[\"BASIC\"] = \"BASIC\";\n    Fields14[\"DEFAULT\"] = \"DEFAULT\";\n    Fields14[\"FULL\"] = \"FULL\";\n  })(Fields14 = Occ.Fields14 || (Occ.Fields14 = {}));\n  /**\n   * Defines values for Fields15.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields15 = <Fields15>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields15;\n  (function (Fields15) {\n    Fields15[\"BASIC\"] = \"BASIC\";\n    Fields15[\"DEFAULT\"] = \"DEFAULT\";\n    Fields15[\"FULL\"] = \"FULL\";\n  })(Fields15 = Occ.Fields15 || (Occ.Fields15 = {}));\n  /**\n   * Defines values for Fields16.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields16 = <Fields16>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields16;\n  (function (Fields16) {\n    Fields16[\"BASIC\"] = \"BASIC\";\n    Fields16[\"DEFAULT\"] = \"DEFAULT\";\n    Fields16[\"FULL\"] = \"FULL\";\n  })(Fields16 = Occ.Fields16 || (Occ.Fields16 = {}));\n  /**\n   * Defines values for SortEnum.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: SortEnum = <SortEnum>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let SortEnum;\n  (function (SortEnum) {\n    SortEnum[\"BASIC\"] = \"BASIC\";\n    SortEnum[\"DEFAULT\"] = \"DEFAULT\";\n    SortEnum[\"FULL\"] = \"FULL\";\n  })(SortEnum = Occ.SortEnum || (Occ.SortEnum = {}));\n  /**\n   * Defines values for Fields17.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields17 = <Fields17>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields17;\n  (function (Fields17) {\n    Fields17[\"BASIC\"] = \"BASIC\";\n    Fields17[\"DEFAULT\"] = \"DEFAULT\";\n    Fields17[\"FULL\"] = \"FULL\";\n  })(Fields17 = Occ.Fields17 || (Occ.Fields17 = {}));\n  /**\n   * Defines values for Fields18.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields18 = <Fields18>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields18;\n  (function (Fields18) {\n    Fields18[\"BASIC\"] = \"BASIC\";\n    Fields18[\"DEFAULT\"] = \"DEFAULT\";\n    Fields18[\"FULL\"] = \"FULL\";\n  })(Fields18 = Occ.Fields18 || (Occ.Fields18 = {}));\n  /**\n   * Defines values for Fields19.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields19 = <Fields19>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields19;\n  (function (Fields19) {\n    Fields19[\"BASIC\"] = \"BASIC\";\n    Fields19[\"DEFAULT\"] = \"DEFAULT\";\n    Fields19[\"FULL\"] = \"FULL\";\n  })(Fields19 = Occ.Fields19 || (Occ.Fields19 = {}));\n  /**\n   * Defines values for Fields20.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields20 = <Fields20>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields20;\n  (function (Fields20) {\n    Fields20[\"BASIC\"] = \"BASIC\";\n    Fields20[\"DEFAULT\"] = \"DEFAULT\";\n    Fields20[\"FULL\"] = \"FULL\";\n  })(Fields20 = Occ.Fields20 || (Occ.Fields20 = {}));\n  /**\n   * Defines values for Fields21.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields21 = <Fields21>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields21;\n  (function (Fields21) {\n    Fields21[\"BASIC\"] = \"BASIC\";\n    Fields21[\"DEFAULT\"] = \"DEFAULT\";\n    Fields21[\"FULL\"] = \"FULL\";\n  })(Fields21 = Occ.Fields21 || (Occ.Fields21 = {}));\n  /**\n   * Defines values for Fields22.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields22 = <Fields22>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields22;\n  (function (Fields22) {\n    Fields22[\"BASIC\"] = \"BASIC\";\n    Fields22[\"DEFAULT\"] = \"DEFAULT\";\n    Fields22[\"FULL\"] = \"FULL\";\n  })(Fields22 = Occ.Fields22 || (Occ.Fields22 = {}));\n  /**\n   * Defines values for Fields23.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields23 = <Fields23>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields23;\n  (function (Fields23) {\n    Fields23[\"BASIC\"] = \"BASIC\";\n    Fields23[\"DEFAULT\"] = \"DEFAULT\";\n    Fields23[\"FULL\"] = \"FULL\";\n  })(Fields23 = Occ.Fields23 || (Occ.Fields23 = {}));\n  /**\n   * Defines values for Fields24.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields24 = <Fields24>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields24;\n  (function (Fields24) {\n    Fields24[\"BASIC\"] = \"BASIC\";\n    Fields24[\"DEFAULT\"] = \"DEFAULT\";\n    Fields24[\"FULL\"] = \"FULL\";\n  })(Fields24 = Occ.Fields24 || (Occ.Fields24 = {}));\n  /**\n   * Defines values for Fields25.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields25 = <Fields25>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields25;\n  (function (Fields25) {\n    Fields25[\"BASIC\"] = \"BASIC\";\n    Fields25[\"DEFAULT\"] = \"DEFAULT\";\n    Fields25[\"FULL\"] = \"FULL\";\n  })(Fields25 = Occ.Fields25 || (Occ.Fields25 = {}));\n  /**\n   * Defines values for Fields26.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields26 = <Fields26>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields26;\n  (function (Fields26) {\n    Fields26[\"BASIC\"] = \"BASIC\";\n    Fields26[\"DEFAULT\"] = \"DEFAULT\";\n    Fields26[\"FULL\"] = \"FULL\";\n  })(Fields26 = Occ.Fields26 || (Occ.Fields26 = {}));\n  /**\n   * Defines values for Fields27.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields27 = <Fields27>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields27;\n  (function (Fields27) {\n    Fields27[\"BASIC\"] = \"BASIC\";\n    Fields27[\"DEFAULT\"] = \"DEFAULT\";\n    Fields27[\"FULL\"] = \"FULL\";\n  })(Fields27 = Occ.Fields27 || (Occ.Fields27 = {}));\n  /**\n   * Defines values for Fields28.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields28 = <Fields28>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields28;\n  (function (Fields28) {\n    Fields28[\"BASIC\"] = \"BASIC\";\n    Fields28[\"DEFAULT\"] = \"DEFAULT\";\n    Fields28[\"FULL\"] = \"FULL\";\n  })(Fields28 = Occ.Fields28 || (Occ.Fields28 = {}));\n  /**\n   * Defines values for Fields29.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields29 = <Fields29>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields29;\n  (function (Fields29) {\n    Fields29[\"BASIC\"] = \"BASIC\";\n    Fields29[\"DEFAULT\"] = \"DEFAULT\";\n    Fields29[\"FULL\"] = \"FULL\";\n  })(Fields29 = Occ.Fields29 || (Occ.Fields29 = {}));\n  /**\n   * Defines values for Fields30.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields30 = <Fields30>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields30;\n  (function (Fields30) {\n    Fields30[\"BASIC\"] = \"BASIC\";\n    Fields30[\"DEFAULT\"] = \"DEFAULT\";\n    Fields30[\"FULL\"] = \"FULL\";\n  })(Fields30 = Occ.Fields30 || (Occ.Fields30 = {}));\n  /**\n   * Defines values for Fields31.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields31 = <Fields31>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields31;\n  (function (Fields31) {\n    Fields31[\"BASIC\"] = \"BASIC\";\n    Fields31[\"DEFAULT\"] = \"DEFAULT\";\n    Fields31[\"FULL\"] = \"FULL\";\n  })(Fields31 = Occ.Fields31 || (Occ.Fields31 = {}));\n  /**\n   * Defines values for Fields32.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields32 = <Fields32>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields32;\n  (function (Fields32) {\n    Fields32[\"BASIC\"] = \"BASIC\";\n    Fields32[\"DEFAULT\"] = \"DEFAULT\";\n    Fields32[\"FULL\"] = \"FULL\";\n  })(Fields32 = Occ.Fields32 || (Occ.Fields32 = {}));\n  /**\n   * Defines values for Fields33.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields33 = <Fields33>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields33;\n  (function (Fields33) {\n    Fields33[\"BASIC\"] = \"BASIC\";\n    Fields33[\"DEFAULT\"] = \"DEFAULT\";\n    Fields33[\"FULL\"] = \"FULL\";\n  })(Fields33 = Occ.Fields33 || (Occ.Fields33 = {}));\n  /**\n   * Defines values for Fields34.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields34 = <Fields34>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields34;\n  (function (Fields34) {\n    Fields34[\"BASIC\"] = \"BASIC\";\n    Fields34[\"DEFAULT\"] = \"DEFAULT\";\n    Fields34[\"FULL\"] = \"FULL\";\n  })(Fields34 = Occ.Fields34 || (Occ.Fields34 = {}));\n  /**\n   * Defines values for Fields35.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields35 = <Fields35>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields35;\n  (function (Fields35) {\n    Fields35[\"BASIC\"] = \"BASIC\";\n    Fields35[\"DEFAULT\"] = \"DEFAULT\";\n    Fields35[\"FULL\"] = \"FULL\";\n  })(Fields35 = Occ.Fields35 || (Occ.Fields35 = {}));\n  /**\n   * Defines values for Fields36.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields36 = <Fields36>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields36;\n  (function (Fields36) {\n    Fields36[\"BASIC\"] = \"BASIC\";\n    Fields36[\"DEFAULT\"] = \"DEFAULT\";\n    Fields36[\"FULL\"] = \"FULL\";\n  })(Fields36 = Occ.Fields36 || (Occ.Fields36 = {}));\n  /**\n   * Defines values for Fields37.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields37 = <Fields37>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields37;\n  (function (Fields37) {\n    Fields37[\"BASIC\"] = \"BASIC\";\n    Fields37[\"DEFAULT\"] = \"DEFAULT\";\n    Fields37[\"FULL\"] = \"FULL\";\n  })(Fields37 = Occ.Fields37 || (Occ.Fields37 = {}));\n  /**\n   * Defines values for Fields38.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields38 = <Fields38>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields38;\n  (function (Fields38) {\n    Fields38[\"BASIC\"] = \"BASIC\";\n    Fields38[\"DEFAULT\"] = \"DEFAULT\";\n    Fields38[\"FULL\"] = \"FULL\";\n  })(Fields38 = Occ.Fields38 || (Occ.Fields38 = {}));\n  /**\n   * Defines values for Fields39.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields39 = <Fields39>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields39;\n  (function (Fields39) {\n    Fields39[\"BASIC\"] = \"BASIC\";\n    Fields39[\"DEFAULT\"] = \"DEFAULT\";\n    Fields39[\"FULL\"] = \"FULL\";\n  })(Fields39 = Occ.Fields39 || (Occ.Fields39 = {}));\n  /**\n   * Defines values for Fields40.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields40 = <Fields40>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields40;\n  (function (Fields40) {\n    Fields40[\"BASIC\"] = \"BASIC\";\n    Fields40[\"DEFAULT\"] = \"DEFAULT\";\n    Fields40[\"FULL\"] = \"FULL\";\n  })(Fields40 = Occ.Fields40 || (Occ.Fields40 = {}));\n  /**\n   * Defines values for Fields41.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields41 = <Fields41>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields41;\n  (function (Fields41) {\n    Fields41[\"BASIC\"] = \"BASIC\";\n    Fields41[\"DEFAULT\"] = \"DEFAULT\";\n    Fields41[\"FULL\"] = \"FULL\";\n  })(Fields41 = Occ.Fields41 || (Occ.Fields41 = {}));\n  /**\n   * Defines values for Fields42.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields42 = <Fields42>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields42;\n  (function (Fields42) {\n    Fields42[\"BASIC\"] = \"BASIC\";\n    Fields42[\"DEFAULT\"] = \"DEFAULT\";\n    Fields42[\"FULL\"] = \"FULL\";\n  })(Fields42 = Occ.Fields42 || (Occ.Fields42 = {}));\n  /**\n   * Defines values for Fields43.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields43 = <Fields43>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields43;\n  (function (Fields43) {\n    Fields43[\"BASIC\"] = \"BASIC\";\n    Fields43[\"DEFAULT\"] = \"DEFAULT\";\n    Fields43[\"FULL\"] = \"FULL\";\n  })(Fields43 = Occ.Fields43 || (Occ.Fields43 = {}));\n  /**\n   * Defines values for Fields44.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields44 = <Fields44>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields44;\n  (function (Fields44) {\n    Fields44[\"BASIC\"] = \"BASIC\";\n    Fields44[\"DEFAULT\"] = \"DEFAULT\";\n    Fields44[\"FULL\"] = \"FULL\";\n  })(Fields44 = Occ.Fields44 || (Occ.Fields44 = {}));\n  /**\n   * Defines values for Fields45.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields45 = <Fields45>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields45;\n  (function (Fields45) {\n    Fields45[\"BASIC\"] = \"BASIC\";\n    Fields45[\"DEFAULT\"] = \"DEFAULT\";\n    Fields45[\"FULL\"] = \"FULL\";\n  })(Fields45 = Occ.Fields45 || (Occ.Fields45 = {}));\n  /**\n   * Defines values for Fields46.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields46 = <Fields46>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields46;\n  (function (Fields46) {\n    Fields46[\"BASIC\"] = \"BASIC\";\n    Fields46[\"DEFAULT\"] = \"DEFAULT\";\n    Fields46[\"FULL\"] = \"FULL\";\n  })(Fields46 = Occ.Fields46 || (Occ.Fields46 = {}));\n  /**\n   * Defines values for Fields47.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields47 = <Fields47>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields47;\n  (function (Fields47) {\n    Fields47[\"BASIC\"] = \"BASIC\";\n    Fields47[\"DEFAULT\"] = \"DEFAULT\";\n    Fields47[\"FULL\"] = \"FULL\";\n  })(Fields47 = Occ.Fields47 || (Occ.Fields47 = {}));\n  /**\n   * Defines values for Fields48.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields48 = <Fields48>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields48;\n  (function (Fields48) {\n    Fields48[\"BASIC\"] = \"BASIC\";\n    Fields48[\"DEFAULT\"] = \"DEFAULT\";\n    Fields48[\"FULL\"] = \"FULL\";\n  })(Fields48 = Occ.Fields48 || (Occ.Fields48 = {}));\n  /**\n   * Defines values for Fields49.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields49 = <Fields49>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields49;\n  (function (Fields49) {\n    Fields49[\"BASIC\"] = \"BASIC\";\n    Fields49[\"DEFAULT\"] = \"DEFAULT\";\n    Fields49[\"FULL\"] = \"FULL\";\n  })(Fields49 = Occ.Fields49 || (Occ.Fields49 = {}));\n  /**\n   * Defines values for Fields50.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields50 = <Fields50>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields50;\n  (function (Fields50) {\n    Fields50[\"BASIC\"] = \"BASIC\";\n    Fields50[\"DEFAULT\"] = \"DEFAULT\";\n    Fields50[\"FULL\"] = \"FULL\";\n  })(Fields50 = Occ.Fields50 || (Occ.Fields50 = {}));\n  /**\n   * Defines values for Fields51.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields51 = <Fields51>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields51;\n  (function (Fields51) {\n    Fields51[\"BASIC\"] = \"BASIC\";\n    Fields51[\"DEFAULT\"] = \"DEFAULT\";\n    Fields51[\"FULL\"] = \"FULL\";\n  })(Fields51 = Occ.Fields51 || (Occ.Fields51 = {}));\n  /**\n   * Defines values for Fields52.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields52 = <Fields52>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields52;\n  (function (Fields52) {\n    Fields52[\"BASIC\"] = \"BASIC\";\n    Fields52[\"DEFAULT\"] = \"DEFAULT\";\n    Fields52[\"FULL\"] = \"FULL\";\n  })(Fields52 = Occ.Fields52 || (Occ.Fields52 = {}));\n  /**\n   * Defines values for Fields53.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields53 = <Fields53>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields53;\n  (function (Fields53) {\n    Fields53[\"BASIC\"] = \"BASIC\";\n    Fields53[\"DEFAULT\"] = \"DEFAULT\";\n    Fields53[\"FULL\"] = \"FULL\";\n  })(Fields53 = Occ.Fields53 || (Occ.Fields53 = {}));\n  /**\n   * Defines values for Fields54.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields54 = <Fields54>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields54;\n  (function (Fields54) {\n    Fields54[\"BASIC\"] = \"BASIC\";\n    Fields54[\"DEFAULT\"] = \"DEFAULT\";\n    Fields54[\"FULL\"] = \"FULL\";\n  })(Fields54 = Occ.Fields54 || (Occ.Fields54 = {}));\n  /**\n   * Defines values for Fields55.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields55 = <Fields55>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields55;\n  (function (Fields55) {\n    Fields55[\"BASIC\"] = \"BASIC\";\n    Fields55[\"DEFAULT\"] = \"DEFAULT\";\n    Fields55[\"FULL\"] = \"FULL\";\n  })(Fields55 = Occ.Fields55 || (Occ.Fields55 = {}));\n  /**\n   * Defines values for Fields56.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields56 = <Fields56>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields56;\n  (function (Fields56) {\n    Fields56[\"BASIC\"] = \"BASIC\";\n    Fields56[\"DEFAULT\"] = \"DEFAULT\";\n    Fields56[\"FULL\"] = \"FULL\";\n  })(Fields56 = Occ.Fields56 || (Occ.Fields56 = {}));\n  /**\n   * Defines values for Fields57.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields57 = <Fields57>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields57;\n  (function (Fields57) {\n    Fields57[\"BASIC\"] = \"BASIC\";\n    Fields57[\"DEFAULT\"] = \"DEFAULT\";\n    Fields57[\"FULL\"] = \"FULL\";\n  })(Fields57 = Occ.Fields57 || (Occ.Fields57 = {}));\n  /**\n   * Defines values for Fields58.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields58 = <Fields58>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields58;\n  (function (Fields58) {\n    Fields58[\"BASIC\"] = \"BASIC\";\n    Fields58[\"DEFAULT\"] = \"DEFAULT\";\n    Fields58[\"FULL\"] = \"FULL\";\n  })(Fields58 = Occ.Fields58 || (Occ.Fields58 = {}));\n  /**\n   * Defines values for Fields59.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields59 = <Fields59>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields59;\n  (function (Fields59) {\n    Fields59[\"BASIC\"] = \"BASIC\";\n    Fields59[\"DEFAULT\"] = \"DEFAULT\";\n    Fields59[\"FULL\"] = \"FULL\";\n  })(Fields59 = Occ.Fields59 || (Occ.Fields59 = {}));\n  /**\n   * Defines values for Fields60.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields60 = <Fields60>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields60;\n  (function (Fields60) {\n    Fields60[\"BASIC\"] = \"BASIC\";\n    Fields60[\"DEFAULT\"] = \"DEFAULT\";\n    Fields60[\"FULL\"] = \"FULL\";\n  })(Fields60 = Occ.Fields60 || (Occ.Fields60 = {}));\n  /**\n   * Defines values for Fields61.\n   * Possible values include: 'BASIC', 'DEFAULT', 'FULL'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Fields61 = <Fields61>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Fields61;\n  (function (Fields61) {\n    Fields61[\"BASIC\"] = \"BASIC\";\n    Fields61[\"DEFAULT\"] = \"DEFAULT\";\n    Fields61[\"FULL\"] = \"FULL\";\n  })(Fields61 = Occ.Fields61 || (Occ.Fields61 = {}));\n  /**\n   * Defines values for Type.\n   * Possible values include: 'all', 'product', 'order'\n   * There could be more values for this enum apart from the ones defined here.If\n   * you want to set a value that is not from the known values then you can do\n   * the following:\n   * let param: Type = <Type>\"someUnknownValueThatWillStillBeValid\";\n   * @readonly\n   * @enum {string}\n   */\n  let Type;\n  (function (Type) {\n    Type[\"All\"] = \"all\";\n    Type[\"Product\"] = \"product\";\n    Type[\"Order\"] = \"order\";\n  })(Type = Occ.Type || (Occ.Type = {}));\n  let CONSENT_STATUS;\n  (function (CONSENT_STATUS) {\n    CONSENT_STATUS[\"ANONYMOUS_CONSENT_GIVEN\"] = \"GIVEN\";\n    CONSENT_STATUS[\"ANONYMOUS_CONSENT_WITHDRAWN\"] = \"WITHDRAWN\";\n  })(CONSENT_STATUS = Occ.CONSENT_STATUS || (Occ.CONSENT_STATUS = {}));\n  let NotificationType;\n  (function (NotificationType) {\n    NotificationType[\"BACK_IN_STOCK\"] = \"BACK_IN_STOCK\";\n  })(NotificationType = Occ.NotificationType || (Occ.NotificationType = {}));\n  let Period;\n  (function (Period) {\n    Period[\"DAY\"] = \"DAY\";\n    Period[\"WEEK\"] = \"WEEK\";\n    Period[\"MONTH\"] = \"MONTH\";\n    Period[\"QUARTER\"] = \"QUARTER\";\n    Period[\"YEAR\"] = \"YEAR\";\n  })(Period = Occ.Period || (Occ.Period = {}));\n  let DaysOfWeek;\n  (function (DaysOfWeek) {\n    DaysOfWeek[\"MONDAY\"] = \"MONDAY\";\n    DaysOfWeek[\"TUESDAY\"] = \"TUESDAY\";\n    DaysOfWeek[\"WEDNESDAY\"] = \"WEDNESDAY\";\n    DaysOfWeek[\"THURSDAY\"] = \"THURSDAY\";\n    DaysOfWeek[\"FRIDAY\"] = \"FRIDAY\";\n    DaysOfWeek[\"SATURDAY\"] = \"SATURDAY\";\n    DaysOfWeek[\"SUNDAY\"] = \"SUNDAY\";\n  })(DaysOfWeek = Occ.DaysOfWeek || (Occ.DaysOfWeek = {}));\n  let OrderApprovalDecisionValue;\n  (function (OrderApprovalDecisionValue) {\n    OrderApprovalDecisionValue[\"APPROVE\"] = \"APPROVE\";\n    OrderApprovalDecisionValue[\"REJECT\"] = \"REJECT\";\n  })(OrderApprovalDecisionValue = Occ.OrderApprovalDecisionValue || (Occ.OrderApprovalDecisionValue = {}));\n})(Occ || (Occ = {}));\nlet OccCmsPageNormalizer = /*#__PURE__*/(() => {\n  class OccCmsPageNormalizer {\n    convert(source, target = {}) {\n      this.normalizePageData(source, target);\n      this.normalizePageSlotData(source, target);\n      this.normalizePageComponentData(source, target);\n      this.normalizeComponentData(source, target);\n      return target;\n    }\n    /**\n     * Converts the OCC cms page model to the `Page` in the `CmsStructureModel`.\n     */\n    normalizePageData(source, target) {\n      if (!source) {\n        return;\n      }\n      const page = {};\n      if (source.name) {\n        page.name = source.name;\n      }\n      if (source.typeCode) {\n        page.type = source.typeCode;\n      }\n      if (source.label) {\n        page.label = source.label;\n      }\n      if (source.template) {\n        page.template = source.template;\n      }\n      if (source.uid) {\n        page.pageId = source.uid;\n      }\n      if (source.title) {\n        page.title = source.title;\n      }\n      if (source.description) {\n        page.description = source.description;\n      }\n      if (source.properties) {\n        page.properties = source.properties;\n      }\n      this.normalizeRobots(source, page);\n      target.page = page;\n    }\n    /**\n     * Adds a ContentSlotData for each page slot in the `CmsStructureModel`.\n     */\n    normalizePageSlotData(source, target) {\n      if (!(source === null || source === void 0 ? void 0 : source.contentSlots)) {\n        return;\n      }\n      if (!Array.isArray(source.contentSlots.contentSlot)) {\n        source.contentSlots.contentSlot = [source.contentSlots.contentSlot];\n      }\n      target.page.slots = {};\n      for (const slot of source.contentSlots.contentSlot) {\n        target.page.slots[slot.position] = {};\n        if (slot.properties) {\n          target.page.slots[slot.position].properties = slot.properties;\n        }\n      }\n    }\n    /**\n     * Registers the `ContentSlotComponentData` for each component.\n     */\n    normalizePageComponentData(source, target) {\n      var _a, _b;\n      if (!((_a = source === null || source === void 0 ? void 0 : source.contentSlots) === null || _a === void 0 ? void 0 : _a.contentSlot)) {\n        return;\n      }\n      for (const slot of source.contentSlots.contentSlot) {\n        if (Array.isArray((_b = slot.components) === null || _b === void 0 ? void 0 : _b.component)) {\n          for (const component of slot.components.component) {\n            const comp = {\n              uid: component.uid,\n              typeCode: component.typeCode\n            };\n            if (component.properties) {\n              comp.properties = component.properties;\n            }\n            if (component.typeCode === CMS_FLEX_COMPONENT_TYPE) {\n              comp.flexType = component.flexType;\n            } else if (component.typeCode === JSP_INCLUDE_CMS_COMPONENT_TYPE) {\n              comp.flexType = component.uid;\n            } else {\n              comp.flexType = component.typeCode;\n            }\n            if (!target.page.slots[slot.position].components) {\n              target.page.slots[slot.position].components = [];\n            }\n            target.page.slots[slot.position].components.push(comp);\n          }\n        }\n      }\n    }\n    /**\n     * Adds the actual component data whenever available in the CMS page data.\n     *\n     * If the data is not populated in this payload, it is loaded separately\n     * (`OccCmsComponentAdapter`).\n     */\n    normalizeComponentData(source, target) {\n      var _a, _b;\n      if (!((_a = source === null || source === void 0 ? void 0 : source.contentSlots) === null || _a === void 0 ? void 0 : _a.contentSlot)) {\n        return;\n      }\n      for (const slot of source.contentSlots.contentSlot) {\n        if (Array.isArray((_b = slot.components) === null || _b === void 0 ? void 0 : _b.component)) {\n          for (const component of slot.components.component) {\n            // while we're hoping to get this right from the backend api,\n            // the OCC api stills seems out of sync with the right model.\n            if (component.modifiedtime) {\n              component.modifiedTime = component.modifiedtime;\n              delete component.modifiedtime;\n            }\n            // we don't put properties into component state\n            if (component.properties) {\n              component.properties = undefined;\n            }\n            if (!target.components) {\n              target.components = [];\n            }\n            target.components.push(component);\n          }\n        }\n      }\n    }\n    /**\n     * Normalizes the page robot string to an array of `PageRobotsMeta` items.\n     */\n    normalizeRobots(source, target) {\n      const robots = [];\n      if (source.robotTag) {\n        switch (source.robotTag) {\n          case Occ.PageRobots.INDEX_FOLLOW:\n            robots.push(PageRobotsMeta.INDEX);\n            robots.push(PageRobotsMeta.FOLLOW);\n            break;\n          case Occ.PageRobots.NOINDEX_FOLLOW:\n            robots.push(PageRobotsMeta.NOINDEX);\n            robots.push(PageRobotsMeta.FOLLOW);\n            break;\n          case Occ.PageRobots.INDEX_NOFOLLOW:\n            robots.push(PageRobotsMeta.INDEX);\n            robots.push(PageRobotsMeta.NOFOLLOW);\n            break;\n          case Occ.PageRobots.NOINDEX_NOFOLLOW:\n            robots.push(PageRobotsMeta.NOINDEX);\n            robots.push(PageRobotsMeta.NOFOLLOW);\n            break;\n        }\n      }\n      target.robots = robots;\n    }\n  }\n  OccCmsPageNormalizer.ɵfac = function OccCmsPageNormalizer_Factory(t) {\n    return new (t || OccCmsPageNormalizer)();\n  };\n  OccCmsPageNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCmsPageNormalizer,\n    factory: OccCmsPageNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCmsPageNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCmsPageAdapter = /*#__PURE__*/(() => {\n  class OccCmsPageAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n      this.headers = new HttpHeaders().set('Content-Type', 'application/json');\n    }\n    /**\n     * @override returns the OCC CMS page data for the given context and converts\n     * the data by any configured `CMS_PAGE_NORMALIZER`.\n     */\n    load(pageContext) {\n      const params = this.getPagesRequestParams(pageContext);\n      const endpoint = !pageContext.type ? this.occEndpoints.buildUrl('page', {\n        urlParams: {\n          id: pageContext.id\n        }\n      }) : this.occEndpoints.buildUrl('pages', {\n        queryParams: params\n      });\n      return this.http.get(endpoint, {\n        headers: this.headers\n      }).pipe(this.converter.pipeable(CMS_PAGE_NORMALIZER));\n    }\n    /**\n     * The OCC CMS API allows to query pages by a combination of pageType, label and code.\n     *\n     * When a `ContentPage` is requested, we use the `pageLabelOrId`:\n     *\n     * ```\n     * \"/pages?pageLabelOrId=/my-page&pageType=ContentPage\"\n     * ```\n     *\n     * Other pages are queried by code:\n     *\n     * ```\n     * \"/pages?code=1234&pageType=ProductPage\"\n     * ```\n     *\n     * The page context is ignored for a home page request or in case of a\n     * `smartedit-preview` request.\n     */\n    getPagesRequestParams(context) {\n      if (context.id === HOME_PAGE_CONTEXT || context.id === SMART_EDIT_CONTEXT) {\n        return {};\n      }\n      const httpParams = {};\n      if (context.type) {\n        httpParams.pageType = context.type;\n      }\n      if (context.type === PageType.CONTENT_PAGE) {\n        httpParams.pageLabelOrId = context.id;\n      } else {\n        httpParams.code = context.id;\n      }\n      return httpParams;\n    }\n  }\n  OccCmsPageAdapter.ɵfac = function OccCmsPageAdapter_Factory(t) {\n    return new (t || OccCmsPageAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCmsPageAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCmsPageAdapter,\n    factory: OccCmsPageAdapter.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCmsPageAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CmsOccModule = /*#__PURE__*/(() => {\n  class CmsOccModule {}\n  CmsOccModule.ɵfac = function CmsOccModule_Factory(t) {\n    return new (t || CmsOccModule)();\n  };\n  CmsOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CmsOccModule\n  });\n  CmsOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: CmsPageAdapter,\n      useClass: OccCmsPageAdapter\n    }, {\n      provide: CMS_PAGE_NORMALIZER,\n      useExisting: OccCmsPageNormalizer,\n      multi: true\n    }, {\n      provide: CmsComponentAdapter,\n      useClass: OccCmsComponentAdapter\n    }],\n    imports: [[CommonModule]]\n  });\n  return CmsOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Before 1905, the OCC CMS component API required was using POST method\n * to load a (potentially large) number of components. With 1905, the endpoint\n * evaluated to use GET. Switching from POST to GET has been initially implemented\n * with the `legacy` flag, but from version 3.0 onwards, we're moving the\n * implementation to this optional Adapter.\n *\n * If you like to connect to a pre 1905 version, you can provide this adapter for the\n * `CmsComponentAdapter` injection token.\n */\nlet LegacyOccCmsComponentAdapter = /*#__PURE__*/(() => {\n  class LegacyOccCmsComponentAdapter extends OccCmsComponentAdapter {\n    findComponentsByIds(ids, pageContext, fields = 'DEFAULT', currentPage = 0, pageSize = ids.length, sort) {\n      const idList = {\n        idList: ids\n      };\n      const requestParams = Object.assign(Object.assign({}, this.getContextParams(pageContext)), this.getPaginationParams(currentPage, pageSize, sort));\n      return this.http.post(this.getComponentsEndpoint(requestParams, fields), idList, {\n        headers: this.headers\n      }).pipe(pluck('component'), this.converter.pipeableMany(CMS_COMPONENT_NORMALIZER));\n    }\n  }\n  LegacyOccCmsComponentAdapter.ɵfac = /* @__PURE__ */function () {\n    let ɵLegacyOccCmsComponentAdapter_BaseFactory;\n    return function LegacyOccCmsComponentAdapter_Factory(t) {\n      return (ɵLegacyOccCmsComponentAdapter_BaseFactory || (ɵLegacyOccCmsComponentAdapter_BaseFactory = i0.ɵɵgetInheritedFactory(LegacyOccCmsComponentAdapter)))(t || LegacyOccCmsComponentAdapter);\n    };\n  }();\n  LegacyOccCmsComponentAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LegacyOccCmsComponentAdapter,\n    factory: LegacyOccCmsComponentAdapter.ɵfac,\n    providedIn: 'root'\n  });\n  return LegacyOccCmsComponentAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCostCenterNormalizer = /*#__PURE__*/(() => {\n  class OccCostCenterNormalizer {\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      target.active = this.normalizeBoolean(source.active);\n      return target;\n    }\n    /**\n     * Returns the boolean value for a string property that is supposed\n     * to be of type boolean.\n     */\n    normalizeBoolean(property) {\n      return typeof property === 'string' ? property === 'true' : property;\n    }\n  }\n  OccCostCenterNormalizer.ɵfac = function OccCostCenterNormalizer_Factory(t) {\n    return new (t || OccCostCenterNormalizer)();\n  };\n  OccCostCenterNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCostCenterNormalizer,\n    factory: OccCostCenterNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCostCenterNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCostCenterSerializer = /*#__PURE__*/(() => {\n  class OccCostCenterSerializer {\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      target.activeFlag = source.active;\n      delete target.active;\n      return target;\n    }\n  }\n  OccCostCenterSerializer.ɵfac = function OccCostCenterSerializer_Factory(t) {\n    return new (t || OccCostCenterSerializer)();\n  };\n  OccCostCenterSerializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCostCenterSerializer,\n    factory: OccCostCenterSerializer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCostCenterSerializer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccCostCenterListNormalizer = /*#__PURE__*/(() => {\n  class OccCostCenterListNormalizer {\n    constructor(converter) {\n      this.converter = converter;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      target.values = source.costCenters.map(costCenter => Object.assign({}, this.converter.convert(costCenter, COST_CENTER_NORMALIZER)));\n      return target;\n    }\n  }\n  OccCostCenterListNormalizer.ɵfac = function OccCostCenterListNormalizer_Factory(t) {\n    return new (t || OccCostCenterListNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccCostCenterListNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCostCenterListNormalizer,\n    factory: OccCostCenterListNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccCostCenterListNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultOccCostCentersConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        getActiveCostCenters: '/costcenters?fields=DEFAULT,unit(BASIC,addresses(DEFAULT))'\n      }\n    }\n  }\n};\nlet CostCenterOccModule = /*#__PURE__*/(() => {\n  class CostCenterOccModule {}\n  CostCenterOccModule.ɵfac = function CostCenterOccModule_Factory(t) {\n    return new (t || CostCenterOccModule)();\n  };\n  CostCenterOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CostCenterOccModule\n  });\n  CostCenterOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: COST_CENTERS_NORMALIZER,\n      useExisting: OccCostCenterListNormalizer,\n      multi: true\n    }, {\n      provide: COST_CENTER_NORMALIZER,\n      useExisting: OccCostCenterNormalizer,\n      multi: true\n    }, {\n      provide: COST_CENTER_SERIALIZER,\n      useExisting: OccCostCenterSerializer,\n      multi: true\n    }],\n    imports: [[CommonModule, ConfigModule.withConfig(defaultOccCostCentersConfig)]]\n  });\n  return CostCenterOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccOrderNormalizer = /*#__PURE__*/(() => {\n  class OccOrderNormalizer {\n    constructor(converter, entryPromotionService) {\n      this.converter = converter;\n      this.entryPromotionService = entryPromotionService;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source.entries) {\n        target.entries = source.entries.map(entry => this.convertOrderEntry(entry, source.code, source.appliedProductPromotions));\n      }\n      if (source.consignments) {\n        target.consignments = source.consignments.map(consignment => {\n          var _a;\n          return Object.assign(Object.assign({}, consignment), {\n            entries: (_a = consignment.entries) === null || _a === void 0 ? void 0 : _a.map(entry => Object.assign(Object.assign({}, entry), {\n              orderEntry: this.convertOrderEntry(entry.orderEntry, source.code, source.appliedProductPromotions)\n            }))\n          });\n        });\n      }\n      if (source.unconsignedEntries) {\n        target.unconsignedEntries = source.unconsignedEntries.map(entry => this.convertOrderEntry(entry, source.code, source.appliedProductPromotions));\n      }\n      return target;\n    }\n    convertOrderEntry(source, code, promotions) {\n      return Object.assign(Object.assign({}, source), {\n        product: this.converter.convert(source === null || source === void 0 ? void 0 : source.product, PRODUCT_NORMALIZER),\n        orderCode: code,\n        promotions: this.entryPromotionService ? this.entryPromotionService.getProductPromotion(source, promotions) : []\n      });\n    }\n  }\n  OccOrderNormalizer.ɵfac = function OccOrderNormalizer_Factory(t) {\n    return new (t || OccOrderNormalizer)(i0.ɵɵinject(ConverterService), i0.ɵɵinject(OrderEntryPromotionsService));\n  };\n  OccOrderNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccOrderNormalizer,\n    factory: OccOrderNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccOrderNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccReplenishmentOrderNormalizer = /*#__PURE__*/(() => {\n  class OccReplenishmentOrderNormalizer {\n    constructor(converter, entryPromotionService) {\n      this.converter = converter;\n      this.entryPromotionService = entryPromotionService;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source.entries) {\n        target.entries = source.entries.map(entry => Object.assign(Object.assign({}, entry), {\n          product: this.converter.convert(entry.product, PRODUCT_NORMALIZER),\n          promotions: this.entryPromotionService ? this.entryPromotionService.getProductPromotion(entry, source.appliedProductPromotions) : []\n        }));\n      }\n      return target;\n    }\n  }\n  OccReplenishmentOrderNormalizer.ɵfac = function OccReplenishmentOrderNormalizer_Factory(t) {\n    return new (t || OccReplenishmentOrderNormalizer)(i0.ɵɵinject(ConverterService), i0.ɵɵinject(OrderEntryPromotionsService));\n  };\n  OccReplenishmentOrderNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccReplenishmentOrderNormalizer,\n    factory: OccReplenishmentOrderNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccReplenishmentOrderNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OrderOccModule = /*#__PURE__*/(() => {\n  class OrderOccModule {}\n  OrderOccModule.ɵfac = function OrderOccModule_Factory(t) {\n    return new (t || OrderOccModule)();\n  };\n  OrderOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OrderOccModule\n  });\n  OrderOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: ORDER_NORMALIZER,\n      useExisting: OccOrderNormalizer,\n      multi: true\n    }, {\n      provide: REPLENISHMENT_ORDER_NORMALIZER,\n      useExisting: OccReplenishmentOrderNormalizer,\n      multi: true\n    }],\n    imports: [[CommonModule]]\n  });\n  return OrderOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductImageNormalizer = /*#__PURE__*/(() => {\n  class ProductImageNormalizer {\n    constructor(config) {\n      this.config = config;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source.images) {\n        target.images = this.normalize(source.images);\n      }\n      return target;\n    }\n    /**\n     * @desc\n     * Creates the image structure we'd like to have. Instead of\n     * having a single list with all images despite type and format\n     * we create a proper structure. With that we can do:\n     * - images.primary.thumnail.url\n     * - images.GALLERY[0].thumnail.url\n     */\n    normalize(source) {\n      const images = {};\n      if (source) {\n        for (const image of source) {\n          const isList = image.hasOwnProperty('galleryIndex');\n          if (!images.hasOwnProperty(image.imageType)) {\n            images[image.imageType] = isList ? [] : {};\n          }\n          let imageContainer;\n          if (isList && !images[image.imageType][image.galleryIndex]) {\n            images[image.imageType][image.galleryIndex] = {};\n          }\n          if (isList) {\n            imageContainer = images[image.imageType][image.galleryIndex];\n          } else {\n            imageContainer = images[image.imageType];\n          }\n          const targetImage = Object.assign({}, image);\n          targetImage.url = this.normalizeImageUrl(targetImage.url);\n          imageContainer[image.format] = targetImage;\n        }\n      }\n      return images;\n    }\n    /**\n     * Traditionally, in an on-prem world, medias and other backend related calls\n     * are hosted at the same platform, but in a cloud setup, applications are are\n     * typically distributed cross different environments. For media, we use the\n     * `backend.media.baseUrl` by default, but fallback to `backend.occ.baseUrl`\n     * if none provided.\n     */\n    normalizeImageUrl(url) {\n      if (new RegExp(/^(http|data:image|\\/\\/)/i).test(url)) {\n        return url;\n      }\n      return (this.config.backend.media.baseUrl || this.config.backend.occ.baseUrl || '') + url;\n    }\n  }\n  ProductImageNormalizer.ɵfac = function ProductImageNormalizer_Factory(t) {\n    return new (t || ProductImageNormalizer)(i0.ɵɵinject(OccConfig));\n  };\n  ProductImageNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductImageNormalizer,\n    factory: ProductImageNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductImageNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReferenceNormalizer = /*#__PURE__*/(() => {\n  class ProductReferenceNormalizer {\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source.productReferences) {\n        target.productReferences = this.normalize(source.productReferences);\n      }\n      return target;\n    }\n    /**\n     * @desc\n     * Creates the reference structure we'd like to have. Instead of\n     * having a single list with all references we create a proper structure.\n     * With that we have a semantic API for the clients\n     * - product.references.SIMILAR[0].code\n     */\n    normalize(source) {\n      const references = {};\n      if (source) {\n        for (const reference of source) {\n          if (!references.hasOwnProperty(reference.referenceType)) {\n            references[reference.referenceType] = [];\n          }\n          references[reference.referenceType].push(reference);\n        }\n      }\n      return references;\n    }\n  }\n  ProductReferenceNormalizer.ɵfac = function ProductReferenceNormalizer_Factory(t) {\n    return new (t || ProductReferenceNormalizer)();\n  };\n  ProductReferenceNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReferenceNormalizer,\n    factory: ProductReferenceNormalizer.ɵfac\n  });\n  return ProductReferenceNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccProductSearchPageNormalizer = /*#__PURE__*/(() => {\n  class OccProductSearchPageNormalizer {\n    constructor(converterService) {\n      this.converterService = converterService;\n      /**\n       * Specifies the minimal number of top values in case\n       * non have been setup by the business.\n       */\n      this.DEFAULT_TOP_VALUES = 6;\n    }\n    convert(source, target = {}) {\n      target = Object.assign(Object.assign({}, target), source);\n      this.normalizeFacets(target);\n      if (source.products) {\n        target.products = source.products.map(product => this.converterService.convert(product, PRODUCT_NORMALIZER));\n      }\n      return target;\n    }\n    normalizeFacets(target) {\n      this.normalizeFacetValues(target);\n      this.normalizeUselessFacets(target);\n    }\n    /**\n     * The (current) backend returns facets with values that do not contribute\n     * to the facet navigation much, as the number in the result list will not get\n     * behavior, see https://jira.hybris.com/browse/CS-427.\n     *\n     * As long as this is not in place, we manually filter the facet from the list;\n     * any facet that does not have a count < the total results will be dropped from\n     * the facets.\n     */\n    normalizeUselessFacets(target) {\n      if (target.facets) {\n        target.facets = target.facets.filter(facet => {\n          return !target.pagination || !target.pagination.totalResults || (!facet.hasOwnProperty('visible') || facet.visible) && facet.values && facet.values.find(value => {\n            return value.selected || value.count < target.pagination.totalResults;\n          });\n        });\n      }\n    }\n    /*\n     * In case there are so-called `topValues` given for the facet values,\n     * values are obsolete.\n     *\n     * `topValues` is a feature in Adaptive Search which can limit a large\n     * amount of facet values to a small set (5 by default). As long as the backend\n     * provides all facet values AND topValues, we normalize the data to not bother\n     * the UI with this specific feature.\n     */\n    normalizeFacetValues(target) {\n      if (target.facets) {\n        target.facets = target.facets.map(facetSource => {\n          const {\n              topValues\n            } = facetSource,\n            facetTarget = __rest(facetSource, [\"topValues\"]);\n          facetTarget.topValueCount = (topValues === null || topValues === void 0 ? void 0 : topValues.length) > 0 ? topValues.length : this.DEFAULT_TOP_VALUES;\n          return facetTarget;\n        });\n      }\n    }\n  }\n  OccProductSearchPageNormalizer.ɵfac = function OccProductSearchPageNormalizer_Factory(t) {\n    return new (t || OccProductSearchPageNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccProductSearchPageNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductSearchPageNormalizer,\n    factory: OccProductSearchPageNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccProductSearchPageNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccProductReferencesListNormalizer = /*#__PURE__*/(() => {\n  class OccProductReferencesListNormalizer {\n    constructor(converter) {\n      this.converter = converter;\n    }\n    convert(source, target = []) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source && source.references) {\n        target = source.references.map(reference => Object.assign(Object.assign({}, reference), {\n          target: this.converter.convert(reference.target, PRODUCT_NORMALIZER)\n        }));\n        return target;\n      }\n    }\n  }\n  OccProductReferencesListNormalizer.ɵfac = function OccProductReferencesListNormalizer_Factory(t) {\n    return new (t || OccProductReferencesListNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccProductReferencesListNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductReferencesListNormalizer,\n    factory: OccProductReferencesListNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccProductReferencesListNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductNameNormalizer = /*#__PURE__*/(() => {\n  class ProductNameNormalizer {\n    constructor(config) {\n      this.config = config;\n      /**\n       * A pretty url should not have any encoded characters, which is why we replace\n       * the following character in the product title.\n       *\n       * See https://developers.google.com/maps/documentation/urls/url-encoding for more\n       * information on the characters.\n       */\n      this.reservedSlugCharacters = ` !*'();:@&=+$,/?%#[]`;\n      this.slugChar = '-';\n      // created the regex only once\n      this.slugRegex = new RegExp(`[${this.reservedSlugCharacters.split('').join('\\\\')}]`, 'g');\n      this.sanitizeMultipleSlugChars = new RegExp(`${this.slugChar}+`, 'g');\n    }\n    convert(source, target) {\n      target = target !== null && target !== void 0 ? target : Object.assign({}, source);\n      if (source.name) {\n        target.name = this.normalize(source.name);\n        target.slug = this.normalizeSlug(source.name);\n        target.nameHtml = source.name;\n      }\n      return target;\n    }\n    /**\n     * Sanitizes the name so that the name doesn't contain html elements.\n     */\n    normalize(name) {\n      return name.replace(/<[^>]*>/g, '');\n    }\n    /**\n     * Provides a title slug for the pretty URL.\n     *\n     * The name is sanitized from html, trimmed, converted to lowercase and special characters\n     * which are encoded are replaced by the slug char (dash by default).\n     */\n    normalizeSlug(name) {\n      return this.normalize(name).trim().toLowerCase().replace(this.slugRegex, this.slugChar).replace(this.sanitizeMultipleSlugChars, this.slugChar);\n    }\n  }\n  ProductNameNormalizer.ɵfac = function ProductNameNormalizer_Factory(t) {\n    return new (t || ProductNameNormalizer)(i0.ɵɵinject(OccConfig));\n  };\n  ProductNameNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductNameNormalizer,\n    factory: ProductNameNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductNameNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRODUCT_REFERENCES_NORMALIZER = new InjectionToken('ProductReferencesListNormalizer');\nlet OccProductReferencesAdapter = /*#__PURE__*/(() => {\n  class OccProductReferencesAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    load(productCode, referenceType, pageSize) {\n      return this.http.get(this.getEndpoint(productCode, referenceType, pageSize)).pipe(this.converter.pipeable(PRODUCT_REFERENCES_NORMALIZER));\n    }\n    getEndpoint(code, reference, pageSize) {\n      return this.occEndpoints.buildUrl('productReferences', {\n        urlParams: {\n          productCode: code\n        },\n        queryParams: {\n          referenceType: reference,\n          pageSize\n        }\n      });\n    }\n  }\n  OccProductReferencesAdapter.ɵfac = function OccProductReferencesAdapter_Factory(t) {\n    return new (t || OccProductReferencesAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccProductReferencesAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductReferencesAdapter,\n    factory: OccProductReferencesAdapter.ɵfac\n  });\n  return OccProductReferencesAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRODUCT_REVIEW_NORMALIZER = new InjectionToken('ProductReviewNormalizer');\nconst PRODUCT_REVIEW_SERIALIZER = new InjectionToken('ProductReviewSerializer');\nlet OccProductReviewsAdapter = /*#__PURE__*/(() => {\n  class OccProductReviewsAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    load(productCode, maxCount) {\n      return this.http.get(this.getEndpoint(productCode, maxCount)).pipe(pluck('reviews'), this.converter.pipeableMany(PRODUCT_REVIEW_NORMALIZER));\n    }\n    post(productCode, review) {\n      review = this.converter.convert(review, PRODUCT_REVIEW_SERIALIZER);\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded'\n      });\n      const body = new URLSearchParams();\n      body.append('headline', review.headline);\n      body.append('comment', review.comment);\n      body.append('rating', review.rating.toString());\n      body.append('alias', review.alias);\n      return this.http.post(this.getEndpoint(productCode), body.toString(), {\n        headers\n      });\n    }\n    getEndpoint(code, maxCount) {\n      return this.occEndpoints.buildUrl('productReviews', {\n        urlParams: {\n          productCode: code\n        },\n        queryParams: {\n          maxCount\n        }\n      });\n    }\n  }\n  OccProductReviewsAdapter.ɵfac = function OccProductReviewsAdapter_Factory(t) {\n    return new (t || OccProductReviewsAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccProductReviewsAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductReviewsAdapter,\n    factory: OccProductReviewsAdapter.ɵfac\n  });\n  return OccProductReviewsAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRODUCT_SEARCH_PAGE_NORMALIZER = new InjectionToken('ProductSearchPageNormalizer');\nconst PRODUCT_SUGGESTION_NORMALIZER = new InjectionToken('ProductSuggestionNormalizer');\nconst DEFAULT_SEARCH_CONFIG = {\n  pageSize: 20\n};\nlet OccProductSearchAdapter = /*#__PURE__*/(() => {\n  class OccProductSearchAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    search(query, searchConfig = DEFAULT_SEARCH_CONFIG) {\n      return this.http.get(this.getSearchEndpoint(query, searchConfig)).pipe(this.converter.pipeable(PRODUCT_SEARCH_PAGE_NORMALIZER));\n    }\n    loadSuggestions(term, pageSize = 3) {\n      return this.http.get(this.getSuggestionEndpoint(term, pageSize.toString())).pipe(pluck('suggestions'), this.converter.pipeableMany(PRODUCT_SUGGESTION_NORMALIZER));\n    }\n    getSearchEndpoint(query, searchConfig) {\n      return this.occEndpoints.buildUrl('productSearch', {\n        queryParams: Object.assign({\n          query\n        }, searchConfig)\n      });\n    }\n    getSuggestionEndpoint(term, max) {\n      return this.occEndpoints.buildUrl('productSuggestions', {\n        queryParams: {\n          term,\n          max\n        }\n      });\n    }\n  }\n  OccProductSearchAdapter.ɵfac = function OccProductSearchAdapter_Factory(t) {\n    return new (t || OccProductSearchAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccProductSearchAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductSearchAdapter,\n    factory: OccProductSearchAdapter.ɵfac\n  });\n  return OccProductSearchAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Merge occ fields parameters\n *\n * @param fields Fields definition as string or object\n */\nfunction mergeFields(fields) {\n  const parsedFields = fields.map(f => typeof f === 'string' ? parseFields(f) : f);\n  const mergedFields = optimizeFields(deepMerge({}, ...parsedFields));\n  return stringifyFields(mergedFields);\n}\n/**\n * Optimize fields definition by removing not needed groups\n *\n * @param fields\n */\nfunction optimizeFields(fields = {}) {\n  const keys = Object.keys(fields);\n  if (keys.includes('FULL')) {\n    delete fields['DEFAULT'];\n    delete fields['BASIC'];\n  } else if (keys.includes('DEFAULT')) {\n    delete fields['BASIC'];\n  }\n  Object.keys(fields).forEach(key => {\n    fields[key] = optimizeFields(fields[key]);\n  });\n  return fields;\n}\n/**\n * Parse string field definition to an AST object\n *\n * @param fields Fields string definition\n * @param startIndex Used for recurrence\n */\nfunction parseFields(fields, startIndex = 0) {\n  const parsedFields = {};\n  let i = startIndex;\n  while (i < fields.length) {\n    if (fields[i] === ',') {\n      if (i > startIndex) {\n        parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n      }\n      startIndex = i + 1;\n    } else if (fields[i] === '(') {\n      const subFields = parseFields(fields, i + 1);\n      if (Array.isArray(subFields)) {\n        parsedFields[fields.substr(startIndex, i - startIndex)] = subFields[0];\n        startIndex = subFields[1];\n        i = startIndex - 1;\n      } else {\n        return parsedFields;\n      }\n    } else if (fields[i] === ')') {\n      if (i > startIndex) {\n        parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n      }\n      return [parsedFields, i + 1];\n    }\n    i++;\n  }\n  if (startIndex < fields.length) {\n    parsedFields[fields.substr(startIndex, i - startIndex)] = {};\n  }\n  return parsedFields;\n}\n/**\n * Convert AST object fields definition to string representation\n *\n * @param fields\n */\nfunction stringifyFields(fields) {\n  return Object.keys(fields).map(key => {\n    const subFields = stringifyFields(fields[key]);\n    return subFields ? `${key}(${subFields})` : key;\n  }).join(',');\n}\n/**\n * Extract part of the object described by fields definition\n *\n * @param data\n * @param fields\n */\nfunction extractFields(data, fields) {\n  const parsedFields = typeof fields === 'string' ? parseFields(fields) : fields;\n  return getObjectPart(data, parsedFields);\n}\nfunction getObjectPart(data, fields) {\n  if (!isObject(data)) {\n    return data;\n  }\n  const keys = Object.keys(fields);\n  if (keys.length === 0 ||\n  // we should not extract parts of the object with ambiguous fields definitions\n  keys.find(el => el === 'BASIC' || el === 'DEFAULT' || el === 'FULL')) {\n    return data;\n  }\n  const result = {};\n  keys.forEach(key => {\n    if (data.hasOwnProperty(key)) {\n      result[key] = getObjectPart(data[key], fields[key]);\n    }\n  });\n  return result;\n}\n\n/**\n * Helper service for optimizing endpoint calls to occ backend\n */\nlet OccFieldsService = /*#__PURE__*/(() => {\n  class OccFieldsService {\n    constructor(http) {\n      this.http = http;\n      this.FIELDS_PARAM = 'fields';\n    }\n    /**\n     * Merge similar occ endpoints calls by merging fields parameter\n     *\n     * We assume that different scopes are defined by different fields parameters,\n     * so we are grouping all requests with the same urls (except fields definition)\n     * and merging into one request with fields that will satisfy all separate ones.\n     *\n     * @param models\n     */\n    getOptimalUrlGroups(models) {\n      const groupedByUrls = {};\n      for (const model of models) {\n        const [urlPart, fields] = this.splitFields(model.url);\n        if (!groupedByUrls[urlPart]) {\n          groupedByUrls[urlPart] = {};\n        }\n        model.fields = fields ? parseFields(fields) : {};\n        groupedByUrls[urlPart][model.scopedData.scope] = model;\n      }\n      const mergedUrls = {};\n      for (const [url, group] of Object.entries(groupedByUrls)) {\n        const urlWithFields = this.getUrlWithFields(url, Object.values(group).map(lo => lo.fields));\n        mergedUrls[urlWithFields] = group;\n      }\n      return mergedUrls;\n    }\n    /**\n     * Extract fields parameter from occ endpoint url\n     *\n     * @param urlWithFields\n     */\n    splitFields(urlWithFields) {\n      const [url, params] = urlWithFields.split('?');\n      const paramsMap = {};\n      if (params) {\n        params.split('&').forEach(param => {\n          const keyValue = param.split('=');\n          paramsMap[keyValue[0]] = keyValue[1];\n        });\n      }\n      const nonFieldsParams = Object.keys(paramsMap).sort().reduce((id, par) => {\n        if (par !== this.FIELDS_PARAM) {\n          id.push(paramsMap[par] ? `${par}=${paramsMap[par]}` : par);\n        }\n        return id;\n      }, []);\n      const nonFields = nonFieldsParams.join('&');\n      return [nonFields ? `${url}?${nonFields}` : url, paramsMap[this.FIELDS_PARAM]];\n    }\n    /**\n     * Combine url with field parameters\n     *\n     * @param url\n     * @param fields\n     */\n    getUrlWithFields(url, fields) {\n      const mergedFields = mergeFields(fields);\n      if (mergedFields) {\n        url += url.includes('?') ? '&' : '?';\n        url += `${this.FIELDS_PARAM}=${mergedFields}`;\n      }\n      return url;\n    }\n  }\n  OccFieldsService.ɵfac = function OccFieldsService_Factory(t) {\n    return new (t || OccFieldsService)(i0.ɵɵinject(i1$3.HttpClient));\n  };\n  OccFieldsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccFieldsService,\n    factory: OccFieldsService.ɵfac,\n    providedIn: 'root'\n  });\n  return OccFieldsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccRequestsOptimizerService = /*#__PURE__*/(() => {\n  class OccRequestsOptimizerService {\n    constructor(http, occFields) {\n      this.http = http;\n      this.occFields = occFields;\n    }\n    /**\n     * Optimize occ endpoint calls merging requests to the same url by merging field parameters\n     *\n     * @param scopedDataWithUrls\n     * @param dataFactory\n     */\n    scopedDataLoad(scopedDataWithUrls, dataFactory) {\n      const result = [];\n      if (!dataFactory) {\n        dataFactory = url => this.http.get(url);\n      }\n      const mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);\n      Object.entries(mergedUrls).forEach(([url, groupedModelsSet]) => {\n        const groupedModels = Object.values(groupedModelsSet);\n        if (groupedModels.length === 1) {\n          // only one scope for url, we can pass the data straightaway\n          result.push(Object.assign(Object.assign({}, groupedModels[0].scopedData), {\n            data$: dataFactory(url)\n          }));\n        } else {\n          // multiple scopes per url\n          // we have to split the model per each scope\n          const data$ = dataFactory(url).pipe(shareReplay(1));\n          groupedModels.forEach(modelData => {\n            result.push(Object.assign(Object.assign({}, modelData.scopedData), {\n              data$: data$.pipe(map(data => extractFields(data, modelData.fields)))\n            }));\n          });\n        }\n      });\n      return result;\n    }\n  }\n  OccRequestsOptimizerService.ɵfac = function OccRequestsOptimizerService_Factory(t) {\n    return new (t || OccRequestsOptimizerService)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccFieldsService));\n  };\n  OccRequestsOptimizerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccRequestsOptimizerService,\n    factory: OccRequestsOptimizerService.ɵfac,\n    providedIn: 'root'\n  });\n  return OccRequestsOptimizerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccProductAdapter = /*#__PURE__*/(() => {\n  class OccProductAdapter {\n    constructor(http, occEndpoints, converter, requestsOptimizer) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n      this.requestsOptimizer = requestsOptimizer;\n    }\n    load(productCode, scope) {\n      return this.http.get(this.getEndpoint(productCode, scope)).pipe(this.converter.pipeable(PRODUCT_NORMALIZER));\n    }\n    loadMany(products) {\n      const scopedDataWithUrls = products.map(model => ({\n        scopedData: model,\n        url: this.getEndpoint(model.code, model.scope)\n      }));\n      return this.requestsOptimizer.scopedDataLoad(scopedDataWithUrls).map(scopedProduct => Object.assign(Object.assign({}, scopedProduct), {\n        data$: scopedProduct.data$.pipe(this.converter.pipeable(PRODUCT_NORMALIZER))\n      }));\n    }\n    getEndpoint(code, scope) {\n      return this.occEndpoints.buildUrl('product', {\n        urlParams: {\n          productCode: code\n        },\n        scope\n      });\n    }\n  }\n  OccProductAdapter.ɵfac = function OccProductAdapter_Factory(t) {\n    return new (t || OccProductAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService), i0.ɵɵinject(OccRequestsOptimizerService));\n  };\n  OccProductAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccProductAdapter,\n    factory: OccProductAdapter.ɵfac\n  });\n  return OccProductAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass ProductAdapter {}\nclass ProductReferencesAdapter {}\nclass ProductReviewsAdapter {}\nclass ProductSearchAdapter {}\nconst defaultOccProductConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        product: {\n          default: 'products/${productCode}?fields=DEFAULT,averageRating,images(FULL),classifications,manufacturer,numberOfReviews,categories(FULL),baseOptions,baseProduct,variantOptions,variantType',\n          list: 'products/${productCode}?fields=code,name,summary,price(formattedValue),images(DEFAULT,galleryIndex),baseProduct',\n          details: 'products/${productCode}?fields=averageRating,stock(DEFAULT),description,availableForPickup,code,url,price(DEFAULT),numberOfReviews,manufacturer,categories(FULL),priceRange,multidimensional,tags,images(FULL)',\n          attributes: 'products/${productCode}?fields=classifications',\n          price: 'products/${productCode}?fields=price(formattedValue)'\n        },\n        productReviews: 'products/${productCode}/reviews',\n        // Uncomment this when occ gets configured\n        // productReferences:\n        //   'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))&referenceType=${referenceType}',\n        productReferences: 'products/${productCode}/references?fields=DEFAULT,references(target(images(FULL)))',\n        /* eslint-disable max-len */\n        productSearch: 'products/search?fields=products(code,name,summary,configurable,configuratorType,multidimensional,price(FULL),images(DEFAULT),stock(FULL),averageRating,variantOptions),facets,breadcrumbs,pagination(DEFAULT),sorts(DEFAULT),freeTextSearch,currentQuery',\n        /* eslint-enable */\n        productSuggestions: 'products/suggestions'\n      }\n    },\n    loadingScopes: {\n      product: {\n        details: {\n          include: [\"list\" /* LIST */, \"variants\" /* VARIANTS */]\n        }\n      }\n    }\n  }\n};\nlet ProductOccModule = /*#__PURE__*/(() => {\n  class ProductOccModule {}\n  ProductOccModule.ɵfac = function ProductOccModule_Factory(t) {\n    return new (t || ProductOccModule)();\n  };\n  ProductOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProductOccModule\n  });\n  ProductOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccProductConfig), {\n      provide: ProductAdapter,\n      useClass: OccProductAdapter\n    }, {\n      provide: PRODUCT_NORMALIZER,\n      useExisting: ProductImageNormalizer,\n      multi: true\n    }, {\n      provide: PRODUCT_NORMALIZER,\n      useExisting: ProductNameNormalizer,\n      multi: true\n    }, {\n      provide: ProductReferencesAdapter,\n      useClass: OccProductReferencesAdapter\n    }, {\n      provide: PRODUCT_REFERENCES_NORMALIZER,\n      useExisting: OccProductReferencesListNormalizer,\n      multi: true\n    }, {\n      provide: ProductSearchAdapter,\n      useClass: OccProductSearchAdapter\n    }, {\n      provide: PRODUCT_SEARCH_PAGE_NORMALIZER,\n      useExisting: OccProductSearchPageNormalizer,\n      multi: true\n    }, {\n      provide: ProductReviewsAdapter,\n      useClass: OccProductReviewsAdapter\n    }],\n    imports: [[CommonModule]]\n  });\n  return ProductOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseSiteNormalizer = /*#__PURE__*/(() => {\n  class BaseSiteNormalizer {\n    constructor() {}\n    convert(source, target) {\n      var _a;\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      // We take the first store as the base store.\n      target.baseStore = (_a = source.stores) === null || _a === void 0 ? void 0 : _a[0];\n      delete target.stores;\n      return target;\n    }\n  }\n  BaseSiteNormalizer.ɵfac = function BaseSiteNormalizer_Factory(t) {\n    return new (t || BaseSiteNormalizer)();\n  };\n  BaseSiteNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BaseSiteNormalizer,\n    factory: BaseSiteNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return BaseSiteNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccSiteAdapter = /*#__PURE__*/(() => {\n  class OccSiteAdapter {\n    constructor(http, occEndpointsService, converterService) {\n      this.http = http;\n      this.occEndpointsService = occEndpointsService;\n      this.converterService = converterService;\n    }\n    loadLanguages() {\n      return this.http.get(this.occEndpointsService.buildUrl('languages')).pipe(map(languageList => languageList.languages), this.converterService.pipeableMany(LANGUAGE_NORMALIZER));\n    }\n    loadCurrencies() {\n      return this.http.get(this.occEndpointsService.buildUrl('currencies')).pipe(map(currencyList => currencyList.currencies), this.converterService.pipeableMany(CURRENCY_NORMALIZER));\n    }\n    loadCountries(type) {\n      return this.http.get(this.occEndpointsService.buildUrl('countries', {\n        queryParams: type ? {\n          type\n        } : undefined\n      })).pipe(map(countryList => countryList.countries), this.converterService.pipeableMany(COUNTRY_NORMALIZER));\n    }\n    loadRegions(countryIsoCode) {\n      return this.http.get(this.occEndpointsService.buildUrl('regions', {\n        urlParams: {\n          isoCode: countryIsoCode\n        }\n      })).pipe(map(regionList => regionList.regions), this.converterService.pipeableMany(REGION_NORMALIZER));\n    }\n    /**\n     * There is no OCC API to load one site based on Uid.\n     * So, we have to load all sites, and find the one from the list.\n     */\n    loadBaseSite(siteUid) {\n      if (!siteUid) {\n        const baseUrl = this.occEndpointsService.getBaseUrl();\n        const urlSplits = baseUrl.split('/');\n        siteUid = urlSplits.pop();\n      }\n      return this.http.get(this.occEndpointsService.buildUrl('baseSites', {}, {\n        baseSite: false\n      })).pipe(map(siteList => {\n        return siteList.baseSites.find(site => site.uid === siteUid);\n      }));\n    }\n    loadBaseSites() {\n      return this.http.get(this.occEndpointsService.buildUrl('baseSites', {}, {\n        baseSite: false\n      })).pipe(map(baseSiteList => baseSiteList.baseSites), this.converterService.pipeableMany(BASE_SITE_NORMALIZER));\n    }\n  }\n  OccSiteAdapter.ɵfac = function OccSiteAdapter_Factory(t) {\n    return new (t || OccSiteAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccSiteAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccSiteAdapter,\n    factory: OccSiteAdapter.ɵfac\n  });\n  return OccSiteAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultOccSiteContextConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        languages: 'languages',\n        currencies: 'currencies',\n        countries: 'countries',\n        regions: 'countries/${isoCode}/regions?fields=regions(name,isocode,isocodeShort)',\n        baseSites: 'basesites?fields=baseSites(uid,defaultLanguage(isocode),urlEncodingAttributes,urlPatterns,stores(currencies(isocode),defaultCurrency(isocode),languages(isocode),defaultLanguage(isocode)),theme,defaultPreviewCatalogId,defaultPreviewCategoryCode,defaultPreviewProductCode)'\n      }\n    }\n  }\n};\nlet SiteContextInterceptor = /*#__PURE__*/(() => {\n  class SiteContextInterceptor {\n    constructor(languageService, currencyService, occEndpoints, config) {\n      this.languageService = languageService;\n      this.currencyService = currencyService;\n      this.occEndpoints = occEndpoints;\n      this.config = config;\n      this.activeLang = getContextParameterDefault(this.config, LANGUAGE_CONTEXT_ID);\n      this.activeCurr = getContextParameterDefault(this.config, CURRENCY_CONTEXT_ID);\n      this.languageService.getActive().subscribe(data => this.activeLang = data);\n      this.currencyService.getActive().subscribe(data => {\n        this.activeCurr = data;\n      });\n    }\n    intercept(request, next) {\n      if (request.url.includes(this.occEndpoints.getBaseUrl())) {\n        request = request.clone({\n          setParams: {\n            lang: this.activeLang,\n            curr: this.activeCurr\n          }\n        });\n      }\n      return next.handle(request);\n    }\n  }\n  SiteContextInterceptor.ɵfac = function SiteContextInterceptor_Factory(t) {\n    return new (t || SiteContextInterceptor)(i0.ɵɵinject(LanguageService), i0.ɵɵinject(CurrencyService), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(SiteContextConfig));\n  };\n  SiteContextInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SiteContextInterceptor,\n    factory: SiteContextInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return SiteContextInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SiteContextOccModule = /*#__PURE__*/(() => {\n  class SiteContextOccModule {}\n  SiteContextOccModule.ɵfac = function SiteContextOccModule_Factory(t) {\n    return new (t || SiteContextOccModule)();\n  };\n  SiteContextOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SiteContextOccModule\n  });\n  SiteContextOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccSiteContextConfig), {\n      provide: SiteAdapter,\n      useClass: OccSiteAdapter\n    }, {\n      provide: HTTP_INTERCEPTORS,\n      useExisting: SiteContextInterceptor,\n      multi: true\n    }, {\n      provide: BASE_SITE_NORMALIZER,\n      useExisting: BaseSiteNormalizer,\n      multi: true\n    }],\n    imports: [[CommonModule]]\n  });\n  return SiteContextOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AnonymousConsentNormalizer = /*#__PURE__*/(() => {\n  class AnonymousConsentNormalizer {\n    constructor(anonymousConsentsService) {\n      this.anonymousConsentsService = anonymousConsentsService;\n    }\n    convert(source) {\n      return this.anonymousConsentsService.decodeAndDeserialize(source);\n    }\n  }\n  AnonymousConsentNormalizer.ɵfac = function AnonymousConsentNormalizer_Factory(t) {\n    return new (t || AnonymousConsentNormalizer)(i0.ɵɵinject(AnonymousConsentsService));\n  };\n  AnonymousConsentNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AnonymousConsentNormalizer,\n    factory: AnonymousConsentNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return AnonymousConsentNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet OccReturnRequestNormalizer = /*#__PURE__*/(() => {\n  class OccReturnRequestNormalizer {\n    constructor(converter) {\n      this.converter = converter;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source.returnEntries) {\n        target.returnEntries = source.returnEntries.map(entry => Object.assign(Object.assign({}, entry), {\n          orderEntry: this.convertOrderEntry(entry.orderEntry)\n        }));\n      }\n      return target;\n    }\n    convertOrderEntry(source) {\n      return Object.assign(Object.assign({}, source), {\n        product: this.converter.convert(source.product, PRODUCT_NORMALIZER)\n      });\n    }\n  }\n  OccReturnRequestNormalizer.ɵfac = function OccReturnRequestNormalizer_Factory(t) {\n    return new (t || OccReturnRequestNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccReturnRequestNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccReturnRequestNormalizer,\n    factory: OccReturnRequestNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccReturnRequestNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccUserInterestsNormalizer = /*#__PURE__*/(() => {\n  class OccUserInterestsNormalizer {\n    constructor(converter) {\n      this.converter = converter;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      if (source && source.results) {\n        target.results = source.results.map(result => Object.assign(Object.assign({}, result), {\n          product: this.converter.convert(result.product, PRODUCT_NORMALIZER)\n        }));\n      }\n      return target;\n    }\n  }\n  OccUserInterestsNormalizer.ɵfac = function OccUserInterestsNormalizer_Factory(t) {\n    return new (t || OccUserInterestsNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccUserInterestsNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserInterestsNormalizer,\n    factory: OccUserInterestsNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccUserInterestsNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CONSENT_TEMPLATE_NORMALIZER = new InjectionToken('ConsentTemplateNormalizer');\nlet OccAnonymousConsentTemplatesAdapter = /*#__PURE__*/(() => {\n  class OccAnonymousConsentTemplatesAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    loadAnonymousConsentTemplates() {\n      const url = this.occEndpoints.buildUrl('anonymousConsentTemplates');\n      return this.http.get(url).pipe(catchError(error => throwError(error)), map(consentList => consentList.consentTemplates), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));\n    }\n    loadAnonymousConsents() {\n      // using the endpoint that doesn't set caching headers\n      const url = this.occEndpoints.buildUrl('anonymousConsentTemplates');\n      return this.http.head(url, {\n        observe: 'response'\n      }).pipe(catchError(error => throwError(error)), map(response => response.headers.get(ANONYMOUS_CONSENTS_HEADER)), this.converter.pipeable(ANONYMOUS_CONSENT_NORMALIZER));\n    }\n  }\n  OccAnonymousConsentTemplatesAdapter.ɵfac = function OccAnonymousConsentTemplatesAdapter_Factory(t) {\n    return new (t || OccAnonymousConsentTemplatesAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccAnonymousConsentTemplatesAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccAnonymousConsentTemplatesAdapter,\n    factory: OccAnonymousConsentTemplatesAdapter.ɵfac\n  });\n  return OccAnonymousConsentTemplatesAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER = new InjectionToken('CustomerCouponSearchResultNormalizer');\nlet OccCustomerCouponAdapter = /*#__PURE__*/(() => {\n  class OccCustomerCouponAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    getCustomerCoupons(userId, pageSize, currentPage, sort) {\n      // Currently OCC only supports calls for customer coupons in case of logged users\n      if (userId === OCC_USER_ID_ANONYMOUS) {\n        return of({});\n      }\n      const url = this.occEndpoints.buildUrl('customerCoupons', {\n        urlParams: {\n          userId\n        }\n      });\n      let params = new HttpParams().set('sort', sort ? sort : 'startDate:asc');\n      if (pageSize) {\n        params = params.set('pageSize', pageSize.toString());\n      }\n      if (currentPage) {\n        params = params.set('currentPage', currentPage.toString());\n      }\n      const headers = this.newHttpHeader();\n      return this.http.get(url, {\n        headers,\n        params\n      }).pipe(this.converter.pipeable(CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER));\n    }\n    turnOffNotification(userId, couponCode) {\n      const url = this.occEndpoints.buildUrl('couponNotification', {\n        urlParams: {\n          userId,\n          couponCode\n        }\n      });\n      const headers = this.newHttpHeader();\n      return this.http.delete(url, {\n        headers\n      });\n    }\n    turnOnNotification(userId, couponCode) {\n      const url = this.occEndpoints.buildUrl('couponNotification', {\n        urlParams: {\n          userId,\n          couponCode\n        }\n      });\n      const headers = this.newHttpHeader();\n      return this.http.post(url, {\n        headers\n      });\n    }\n    claimCustomerCoupon(userId, couponCode) {\n      const url = this.occEndpoints.buildUrl('claimCoupon', {\n        urlParams: {\n          userId,\n          couponCode\n        }\n      });\n      const headers = this.newHttpHeader();\n      return this.http.post(url, {\n        headers\n      });\n    }\n    newHttpHeader() {\n      return new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n    }\n  }\n  OccCustomerCouponAdapter.ɵfac = function OccCustomerCouponAdapter_Factory(t) {\n    return new (t || OccCustomerCouponAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccCustomerCouponAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccCustomerCouponAdapter,\n    factory: OccCustomerCouponAdapter.ɵfac\n  });\n  return OccCustomerCouponAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ADDRESS_NORMALIZER = new InjectionToken('AddressNormalizer');\nconst ADDRESS_LIST_NORMALIZER = new InjectionToken('AddressesNormalizer');\nconst ADDRESS_SERIALIZER = new InjectionToken('AddressSerializer');\nconst ADDRESS_VALIDATION_NORMALIZER = new InjectionToken('AddressValidationNormalizer');\nlet OccUserAddressAdapter = /*#__PURE__*/(() => {\n  class OccUserAddressAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    loadAll(userId) {\n      const url = this.occEndpoints.buildUrl('addresses', {\n        urlParams: {\n          userId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.get(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)), map(addressList => addressList.addresses), this.converter.pipeableMany(ADDRESS_NORMALIZER));\n    }\n    add(userId, address) {\n      const url = this.occEndpoints.buildUrl('addresses', {\n        urlParams: {\n          userId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      address = this.converter.convert(address, ADDRESS_SERIALIZER);\n      return this.http.post(url, address, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n    update(userId, addressId, address) {\n      const url = this.occEndpoints.buildUrl('addressDetail', {\n        urlParams: {\n          userId,\n          addressId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      address = this.converter.convert(address, ADDRESS_SERIALIZER);\n      return this.http.patch(url, address, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n    verify(userId, address) {\n      const url = this.occEndpoints.buildUrl('addressVerification', {\n        urlParams: {\n          userId\n        }\n      });\n      let headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      if (userId === OCC_USER_ID_ANONYMOUS) {\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n      }\n      address = this.converter.convert(address, ADDRESS_SERIALIZER);\n      return this.http.post(url, address, {\n        headers\n      }).pipe(catchError(error => throwError(error)), this.converter.pipeable(ADDRESS_VALIDATION_NORMALIZER));\n    }\n    delete(userId, addressId) {\n      const url = this.occEndpoints.buildUrl('addressDetail', {\n        urlParams: {\n          userId,\n          addressId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.delete(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccUserAddressAdapter.ɵfac = function OccUserAddressAdapter_Factory(t) {\n    return new (t || OccUserAddressAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserAddressAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserAddressAdapter,\n    factory: OccUserAddressAdapter.ɵfac\n  });\n  return OccUserAddressAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccUserConsentAdapter = /*#__PURE__*/(() => {\n  class OccUserConsentAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    loadConsents(userId) {\n      const url = this.occEndpoints.buildUrl('consentTemplates', {\n        urlParams: {\n          userId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Cache-Control': 'no-cache'\n      });\n      return this.http.get(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)), map(consentList => consentList.consentTemplates), this.converter.pipeableMany(CONSENT_TEMPLATE_NORMALIZER));\n    }\n    giveConsent(userId, consentTemplateId, consentTemplateVersion) {\n      const url = this.occEndpoints.buildUrl('consents', {\n        urlParams: {\n          userId\n        }\n      });\n      const httpParams = new HttpParams().set('consentTemplateId', consentTemplateId).set('consentTemplateVersion', consentTemplateVersion.toString());\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      });\n      return this.http.post(url, httpParams, {\n        headers\n      }).pipe(catchError(error => throwError(error)), this.converter.pipeable(CONSENT_TEMPLATE_NORMALIZER));\n    }\n    withdrawConsent(userId, consentCode) {\n      const headers = new HttpHeaders({\n        'Cache-Control': 'no-cache'\n      });\n      const url = this.occEndpoints.buildUrl('consentDetail', {\n        urlParams: {\n          userId,\n          consentId: consentCode\n        }\n      });\n      return this.http.delete(url, {\n        headers\n      });\n    }\n  }\n  OccUserConsentAdapter.ɵfac = function OccUserConsentAdapter_Factory(t) {\n    return new (t || OccUserConsentAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserConsentAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserConsentAdapter,\n    factory: OccUserConsentAdapter.ɵfac\n  });\n  return OccUserConsentAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PRODUCT_INTERESTS_NORMALIZER = new InjectionToken('ProductInterestsNormalizer');\nconst headers$1 = new HttpHeaders({\n  'Content-Type': 'application/json'\n});\nlet OccUserInterestsAdapter = /*#__PURE__*/(() => {\n  class OccUserInterestsAdapter {\n    constructor(http, occEndpoints, config, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.config = config;\n      this.converter = converter;\n    }\n    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {\n      let params = new HttpParams().set('sort', sort ? sort : 'name:asc');\n      if (pageSize) {\n        params = params.set('pageSize', pageSize.toString());\n      }\n      if (currentPage) {\n        params = params.set('currentPage', currentPage.toString());\n      }\n      if (productCode) {\n        params = params.set('productCode', productCode);\n      }\n      if (notificationType) {\n        params = params.set('notificationType', notificationType.toString());\n      }\n      return this.http.get(this.occEndpoints.buildUrl('getProductInterests', {\n        urlParams: {\n          userId\n        }\n      }), {\n        headers: headers$1,\n        params\n      }).pipe(this.converter.pipeable(PRODUCT_INTERESTS_NORMALIZER), catchError(error => throwError(error)));\n    }\n    removeInterest(userId, item) {\n      const r = [];\n      item.productInterestEntry.forEach(entry => {\n        const params = new HttpParams().set('productCode', item.product.code).set('notificationType', entry.interestType);\n        r.push(this.http.delete(this.occEndpoints.buildUrl('productInterests', {\n          urlParams: {\n            userId\n          }\n        }), {\n          params: params\n        }).pipe(catchError(error => throwError(error))));\n      });\n      return forkJoin(r);\n    }\n    addInterest(userId, productCode, notificationType) {\n      const params = new HttpParams().set('productCode', productCode).set('notificationType', notificationType.toString());\n      return this.http.post(this.occEndpoints.buildUrl('productInterests', {\n        urlParams: {\n          userId\n        }\n      }), {}, {\n        headers: headers$1,\n        params\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccUserInterestsAdapter.ɵfac = function OccUserInterestsAdapter_Factory(t) {\n    return new (t || OccUserInterestsAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(OccConfig), i0.ɵɵinject(ConverterService));\n  };\n  OccUserInterestsAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserInterestsAdapter,\n    factory: OccUserInterestsAdapter.ɵfac\n  });\n  return OccUserInterestsAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NOTIFICATION_PREFERENCE_SERIALIZER = new InjectionToken('NotificationPreferenceSerializer');\nconst NOTIFICATION_PREFERENCE_NORMALIZER = new InjectionToken('NotificationPreferenceNormalizer');\nclass UserNotificationPreferenceAdapter {}\nlet UserNotificationPreferenceConnector = /*#__PURE__*/(() => {\n  class UserNotificationPreferenceConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    loadAll(userId) {\n      return this.adapter.loadAll(userId);\n    }\n    update(userId, preferences) {\n      return this.adapter.update(userId, preferences);\n    }\n  }\n  UserNotificationPreferenceConnector.ɵfac = function UserNotificationPreferenceConnector_Factory(t) {\n    return new (t || UserNotificationPreferenceConnector)(i0.ɵɵinject(UserNotificationPreferenceAdapter));\n  };\n  UserNotificationPreferenceConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserNotificationPreferenceConnector,\n    factory: UserNotificationPreferenceConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserNotificationPreferenceConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst headers = new HttpHeaders({\n  'Content-Type': 'application/json'\n});\nlet OccUserNotificationPreferenceAdapter = /*#__PURE__*/(() => {\n  class OccUserNotificationPreferenceAdapter {\n    constructor(http, converter, occEndpoints) {\n      this.http = http;\n      this.converter = converter;\n      this.occEndpoints = occEndpoints;\n    }\n    loadAll(userId) {\n      return this.http.get(this.occEndpoints.buildUrl('notificationPreference', {\n        urlParams: {\n          userId\n        }\n      }), {\n        headers\n      }).pipe(map(list => list.preferences), this.converter.pipeableMany(NOTIFICATION_PREFERENCE_NORMALIZER), catchError(error => throwError(error)));\n    }\n    update(userId, preferences) {\n      preferences = this.converter.convert(preferences, NOTIFICATION_PREFERENCE_SERIALIZER);\n      return this.http.patch(this.occEndpoints.buildUrl('notificationPreference', {\n        urlParams: {\n          userId\n        }\n      }), {\n        preferences: preferences\n      }, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccUserNotificationPreferenceAdapter.ɵfac = function OccUserNotificationPreferenceAdapter_Factory(t) {\n    return new (t || OccUserNotificationPreferenceAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(ConverterService), i0.ɵɵinject(OccEndpointsService));\n  };\n  OccUserNotificationPreferenceAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserNotificationPreferenceAdapter,\n    factory: OccUserNotificationPreferenceAdapter.ɵfac\n  });\n  return OccUserNotificationPreferenceAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst ORDER_HISTORY_NORMALIZER = new InjectionToken('OrderHistoryNormalizer');\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst CONSIGNMENT_TRACKING_NORMALIZER = new InjectionToken('ConsignmentTrackingNormalizer');\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst ORDER_RETURN_REQUEST_NORMALIZER = new InjectionToken('OrderReturnRequestNormalizer');\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst ORDER_RETURN_REQUEST_INPUT_SERIALIZER = new InjectionToken('OrderReturnRequestInputSerializer');\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst ORDER_RETURNS_NORMALIZER = new InjectionToken('OrderReturnsNormalizer');\n\n/**\n * @deprecated since 4.2 - use OccOrderAdapter in @spartacus/order/occ instead\n */\nlet OccUserOrderAdapter = /*#__PURE__*/(() => {\n  class OccUserOrderAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    load(userId, orderCode) {\n      const url = this.occEndpoints.buildUrl('orderDetail', {\n        urlParams: {\n          userId,\n          orderId: orderCode\n        }\n      });\n      let headers = new HttpHeaders();\n      if (userId === OCC_USER_ID_ANONYMOUS) {\n        headers = InterceptorUtil.createHeader(USE_CLIENT_TOKEN, true, headers);\n      }\n      return this.http.get(url, {\n        headers\n      }).pipe(this.converter.pipeable(ORDER_NORMALIZER));\n    }\n    loadHistory(userId, pageSize, currentPage, sort) {\n      const params = {};\n      if (pageSize) {\n        params['pageSize'] = pageSize.toString();\n      }\n      if (currentPage) {\n        params['currentPage'] = currentPage.toString();\n      }\n      if (sort) {\n        params['sort'] = sort.toString();\n      }\n      const url = this.occEndpoints.buildUrl('orderHistory', {\n        urlParams: {\n          userId\n        },\n        queryParams: params\n      });\n      return this.http.get(url).pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));\n    }\n    getConsignmentTracking(orderCode, consignmentCode, userId = OCC_USER_ID_CURRENT) {\n      const url = this.occEndpoints.buildUrl('consignmentTracking', {\n        urlParams: {\n          userId,\n          orderCode,\n          consignmentCode\n        }\n      });\n      return this.http.get(url).pipe(this.converter.pipeable(CONSIGNMENT_TRACKING_NORMALIZER));\n    }\n    cancel(userId, orderCode, cancelRequestInput) {\n      const url = this.occEndpoints.buildUrl('cancelOrder', {\n        urlParams: {\n          userId,\n          orderId: orderCode\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.post(url, cancelRequestInput, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n    createReturnRequest(userId, returnRequestInput) {\n      const url = this.occEndpoints.buildUrl('returnOrder', {\n        urlParams: {\n          userId\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      returnRequestInput = this.converter.convert(returnRequestInput, ORDER_RETURN_REQUEST_INPUT_SERIALIZER);\n      return this.http.post(url, returnRequestInput, {\n        headers\n      }).pipe(catchError(error => throwError(error)), this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));\n    }\n    loadReturnRequestList(userId, pageSize, currentPage, sort) {\n      const params = {};\n      if (pageSize) {\n        params['pageSize'] = pageSize.toString();\n      }\n      if (currentPage) {\n        params['currentPage'] = currentPage.toString();\n      }\n      if (sort) {\n        params['sort'] = sort.toString();\n      }\n      const url = this.occEndpoints.buildUrl('orderReturns', {\n        urlParams: {\n          userId\n        },\n        queryParams: params\n      });\n      return this.http.get(url).pipe(this.converter.pipeable(ORDER_RETURNS_NORMALIZER));\n    }\n    loadReturnRequestDetail(userId, returnRequestCode) {\n      const url = this.occEndpoints.buildUrl('orderReturnDetail', {\n        urlParams: {\n          userId,\n          returnRequestCode\n        }\n      });\n      return this.http.get(url).pipe(this.converter.pipeable(ORDER_RETURN_REQUEST_NORMALIZER));\n    }\n    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {\n      const url = this.occEndpoints.buildUrl('cancelReturn', {\n        urlParams: {\n          userId,\n          returnRequestCode\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.patch(url, returnRequestModification, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccUserOrderAdapter.ɵfac = function OccUserOrderAdapter_Factory(t) {\n    return new (t || OccUserOrderAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserOrderAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserOrderAdapter,\n    factory: OccUserOrderAdapter.ɵfac\n  });\n  return OccUserOrderAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccUserPaymentAdapter = /*#__PURE__*/(() => {\n  class OccUserPaymentAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    loadAll(userId) {\n      const url = this.occEndpoints.buildUrl('paymentDetailsAll', {\n        urlParams: {\n          userId\n        }\n      }) + '?saved=true';\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.get(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)), map(methodList => methodList.payments), this.converter.pipeableMany(PAYMENT_DETAILS_NORMALIZER));\n    }\n    delete(userId, paymentMethodID) {\n      const url = this.occEndpoints.buildUrl('paymentDetail', {\n        urlParams: {\n          userId,\n          paymentDetailId: paymentMethodID\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.delete(url, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n    setDefault(userId, paymentMethodID) {\n      const url = this.occEndpoints.buildUrl('paymentDetail', {\n        urlParams: {\n          userId,\n          paymentDetailId: paymentMethodID\n        }\n      });\n      const headers = new HttpHeaders({\n        'Content-Type': 'application/json'\n      });\n      return this.http.patch(url,\n      // TODO: Remove billingAddress property\n      {\n        billingAddress: {\n          titleCode: 'mr'\n        },\n        defaultPayment: true\n      }, {\n        headers\n      }).pipe(catchError(error => throwError(error)));\n    }\n  }\n  OccUserPaymentAdapter.ɵfac = function OccUserPaymentAdapter_Factory(t) {\n    return new (t || OccUserPaymentAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserPaymentAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserPaymentAdapter,\n    factory: OccUserPaymentAdapter.ɵfac\n  });\n  return OccUserPaymentAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst REPLENISHMENT_ORDER_HISTORY_NORMALIZER = new InjectionToken('ReplenishmentOrderHistoryNormalizer');\n\n/**\n * @deprecated since 4.2 - use OccReplenishmentOrderAdapter in @spartacus/order/occ instead\n */\nlet OccUserReplenishmentOrderAdapter = /*#__PURE__*/(() => {\n  class OccUserReplenishmentOrderAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    load(userId, replenishmentOrderCode) {\n      return this.http.get(this.occEndpoints.buildUrl('replenishmentOrderDetails', {\n        urlParams: {\n          userId,\n          replenishmentOrderCode\n        }\n      })).pipe(this.converter.pipeable(REPLENISHMENT_ORDER_NORMALIZER));\n    }\n    loadReplenishmentDetailsHistory(userId, replenishmentOrderCode, pageSize, currentPage, sort) {\n      const params = {};\n      if (pageSize) {\n        params['pageSize'] = pageSize.toString();\n      }\n      if (currentPage) {\n        params['currentPage'] = currentPage.toString();\n      }\n      if (sort) {\n        params['sort'] = sort.toString();\n      }\n      return this.http.get(this.occEndpoints.buildUrl('replenishmentOrderDetailsHistory', {\n        urlParams: {\n          userId,\n          replenishmentOrderCode\n        },\n        queryParams: params\n      })).pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER));\n    }\n    cancelReplenishmentOrder(userId, replenishmentOrderCode) {\n      const headers = new HttpHeaders().set('Content-Type', 'application/json');\n      return this.http.patch(this.occEndpoints.buildUrl('cancelReplenishmentOrder', {\n        urlParams: {\n          userId,\n          replenishmentOrderCode\n        }\n      }), {}, {\n        headers\n      }).pipe(this.converter.pipeable(REPLENISHMENT_ORDER_NORMALIZER));\n    }\n    loadHistory(userId, pageSize, currentPage, sort) {\n      const params = {};\n      if (pageSize) {\n        params['pageSize'] = pageSize.toString();\n      }\n      if (currentPage) {\n        params['currentPage'] = currentPage.toString();\n      }\n      if (sort) {\n        params['sort'] = sort.toString();\n      }\n      const url = this.occEndpoints.buildUrl('replenishmentOrderHistory', {\n        urlParams: {\n          userId\n        },\n        queryParams: params\n      });\n      return this.http.get(url).pipe(this.converter.pipeable(REPLENISHMENT_ORDER_HISTORY_NORMALIZER));\n    }\n  }\n  OccUserReplenishmentOrderAdapter.ɵfac = function OccUserReplenishmentOrderAdapter_Factory(t) {\n    return new (t || OccUserReplenishmentOrderAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserReplenishmentOrderAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserReplenishmentOrderAdapter,\n    factory: OccUserReplenishmentOrderAdapter.ɵfac\n  });\n  return OccUserReplenishmentOrderAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass UserAddressAdapter {}\nclass UserConsentAdapter {}\nclass UserCostCenterAdapter {}\nclass CustomerCouponAdapter {}\nclass UserInterestsAdapter {}\n\n/**\n * @deprecated since 4.2 - use OrderAdapter in @spartacus/order/core\n */\nclass UserOrderAdapter {}\nclass UserPaymentAdapter {}\n\n/**\n * @deprecated since 4.2 - use ReplenishmentOrderAdapter in @spartacus/order/core\n */\nclass UserReplenishmentOrderAdapter {}\n\n/**\n * @deprecated since 4.2 - use ReplenishmentOrderConnector in @spartacus/order/core\n */\nlet UserReplenishmentOrderConnector = /*#__PURE__*/(() => {\n  class UserReplenishmentOrderConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    load(userId, replenishmentOrderCode) {\n      return this.adapter.load(userId, replenishmentOrderCode);\n    }\n    loadReplenishmentDetailsHistory(userId, replenishmentOrderCode, pageSize, currentPage, sort) {\n      return this.adapter.loadReplenishmentDetailsHistory(userId, replenishmentOrderCode, pageSize, currentPage, sort);\n    }\n    cancelReplenishmentOrder(userId, replenishmentOrderCode) {\n      return this.adapter.cancelReplenishmentOrder(userId, replenishmentOrderCode);\n    }\n    loadHistory(userId, pageSize, currentPage, sort) {\n      return this.adapter.loadHistory(userId, pageSize, currentPage, sort);\n    }\n  }\n  UserReplenishmentOrderConnector.ɵfac = function UserReplenishmentOrderConnector_Factory(t) {\n    return new (t || UserReplenishmentOrderConnector)(i0.ɵɵinject(UserReplenishmentOrderAdapter));\n  };\n  UserReplenishmentOrderConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserReplenishmentOrderConnector,\n    factory: UserReplenishmentOrderConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserReplenishmentOrderConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OccAddressListNormalizer = /*#__PURE__*/(() => {\n  class OccAddressListNormalizer {\n    constructor(converter) {\n      this.converter = converter;\n    }\n    convert(source, target) {\n      if (target === undefined) {\n        target = Object.assign({}, source);\n      }\n      target.values = source.addresses.map(address => Object.assign({}, this.converter.convert(address, ADDRESS_NORMALIZER)));\n      return target;\n    }\n  }\n  OccAddressListNormalizer.ɵfac = function OccAddressListNormalizer_Factory(t) {\n    return new (t || OccAddressListNormalizer)(i0.ɵɵinject(ConverterService));\n  };\n  OccAddressListNormalizer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccAddressListNormalizer,\n    factory: OccAddressListNormalizer.ɵfac,\n    providedIn: 'root'\n  });\n  return OccAddressListNormalizer;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultOccUserConfig = {\n  backend: {\n    occ: {\n      endpoints: {\n        /* eslint-disable max-len */\n        paymentDetailsAll: 'users/${userId}/paymentdetails',\n        paymentDetail: 'users/${userId}/paymentdetails/${paymentDetailId}',\n        /** @deprecated since 4.2, use order lib instead */\n        orderHistory: 'users/${userId}/orders',\n        /** @deprecated since 4.2, use order lib instead */\n        orderDetail: 'users/${userId}/orders/${orderId}?fields=FULL',\n        anonymousConsentTemplates: 'users/anonymous/consenttemplates',\n        consentTemplates: 'users/${userId}/consenttemplates',\n        consents: 'users/${userId}/consents',\n        consentDetail: 'users/${userId}/consents/${consentId}',\n        addresses: 'users/${userId}/addresses',\n        addressDetail: 'users/${userId}/addresses/${addressId}',\n        addressVerification: 'users/${userId}/addresses/verification',\n        /** @deprecated since 4.2, use order lib instead */\n        consignmentTracking: 'users/${userId}/orders/${orderCode}/consignments/${consignmentCode}/tracking',\n        customerCoupons: 'users/${userId}/customercoupons',\n        claimCoupon: 'users/${userId}/customercoupons/${couponCode}/claim',\n        couponNotification: 'users/${userId}/customercoupons/${couponCode}/notification',\n        notificationPreference: 'users/${userId}/notificationpreferences',\n        productInterests: 'users/${userId}/productinterests',\n        getProductInterests: 'users/${userId}/productinterests?fields=sorts,pagination,results(productInterestEntry,product(code))',\n        /** @deprecated since 4.2, use order lib instead */\n        cancelOrder: 'users/${userId}/orders/${orderId}/cancellation',\n        /** @deprecated since 4.2, use order lib instead */\n        returnOrder: 'users/${userId}/orderReturns?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',\n        /** @deprecated since 4.2, use order lib instead */\n        orderReturns: 'users/${userId}/orderReturns?fields=BASIC',\n        /** @deprecated since 4.2, use order lib instead */\n        orderReturnDetail: 'users/${userId}/orderReturns/${returnRequestCode}?fields=BASIC,returnEntries(BASIC,refundAmount(formattedValue),orderEntry(basePrice(formattedValue),product(name,code,baseOptions,images(DEFAULT,galleryIndex)))),deliveryCost(formattedValue),totalPrice(formattedValue),subTotal(formattedValue)',\n        /** @deprecated since 4.2, use order lib instead */\n        cancelReturn: 'users/${userId}/orderReturns/${returnRequestCode}'\n        /* eslint-enable */\n      }\n    }\n  }\n};\nlet OccUserCostCenterAdapter = /*#__PURE__*/(() => {\n  class OccUserCostCenterAdapter {\n    constructor(http, occEndpoints, converter) {\n      this.http = http;\n      this.occEndpoints = occEndpoints;\n      this.converter = converter;\n    }\n    loadActiveList(userId) {\n      return this.http.get(this.getCostCentersEndpoint(userId)).pipe(this.converter.pipeable(COST_CENTERS_NORMALIZER));\n    }\n    getCostCentersEndpoint(userId, params) {\n      return this.occEndpoints.buildUrl('getActiveCostCenters', {\n        urlParams: {\n          userId\n        },\n        queryParams: params\n      });\n    }\n  }\n  OccUserCostCenterAdapter.ɵfac = function OccUserCostCenterAdapter_Factory(t) {\n    return new (t || OccUserCostCenterAdapter)(i0.ɵɵinject(i1$3.HttpClient), i0.ɵɵinject(OccEndpointsService), i0.ɵɵinject(ConverterService));\n  };\n  OccUserCostCenterAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OccUserCostCenterAdapter,\n    factory: OccUserCostCenterAdapter.ɵfac\n  });\n  return OccUserCostCenterAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use UserOccTransitional_4_2_Module wiith order lib instead\n */\nlet UserOccTransitionalModule = /*#__PURE__*/(() => {\n  class UserOccTransitionalModule {}\n  UserOccTransitionalModule.ɵfac = function UserOccTransitionalModule_Factory(t) {\n    return new (t || UserOccTransitionalModule)();\n  };\n  UserOccTransitionalModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserOccTransitionalModule\n  });\n  UserOccTransitionalModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccUserConfig), {\n      provide: UserAddressAdapter,\n      useClass: OccUserAddressAdapter\n    }, {\n      provide: UserConsentAdapter,\n      useClass: OccUserConsentAdapter\n    }, {\n      provide: AnonymousConsentTemplatesAdapter,\n      useClass: OccAnonymousConsentTemplatesAdapter\n    }, {\n      provide: UserPaymentAdapter,\n      useClass: OccUserPaymentAdapter\n    }, {\n      provide: UserOrderAdapter,\n      useClass: OccUserOrderAdapter\n    }, {\n      provide: CustomerCouponAdapter,\n      useClass: OccCustomerCouponAdapter\n    }, {\n      provide: UserNotificationPreferenceAdapter,\n      useClass: OccUserNotificationPreferenceAdapter\n    }, {\n      provide: UserInterestsAdapter,\n      useClass: OccUserInterestsAdapter\n    }, {\n      provide: UserCostCenterAdapter,\n      useClass: OccUserCostCenterAdapter\n    }, {\n      provide: PRODUCT_INTERESTS_NORMALIZER,\n      useExisting: OccUserInterestsNormalizer,\n      multi: true\n    }, {\n      provide: ORDER_RETURN_REQUEST_NORMALIZER,\n      useExisting: OccReturnRequestNormalizer,\n      multi: true\n    }, {\n      provide: ANONYMOUS_CONSENT_NORMALIZER,\n      useExisting: AnonymousConsentNormalizer,\n      multi: true\n    }, {\n      provide: ADDRESS_LIST_NORMALIZER,\n      useExisting: OccAddressListNormalizer,\n      multi: true\n    }, {\n      provide: UserReplenishmentOrderAdapter,\n      useClass: OccUserReplenishmentOrderAdapter\n    }],\n    imports: [[CommonModule]]\n  });\n  return UserOccTransitionalModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserOccTransitional_4_2_Module = /*#__PURE__*/(() => {\n  class UserOccTransitional_4_2_Module {}\n  UserOccTransitional_4_2_Module.ɵfac = function UserOccTransitional_4_2_Module_Factory(t) {\n    return new (t || UserOccTransitional_4_2_Module)();\n  };\n  UserOccTransitional_4_2_Module.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserOccTransitional_4_2_Module\n  });\n  UserOccTransitional_4_2_Module.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccUserConfig), {\n      provide: UserAddressAdapter,\n      useClass: OccUserAddressAdapter\n    }, {\n      provide: UserConsentAdapter,\n      useClass: OccUserConsentAdapter\n    }, {\n      provide: AnonymousConsentTemplatesAdapter,\n      useClass: OccAnonymousConsentTemplatesAdapter\n    }, {\n      provide: UserPaymentAdapter,\n      useClass: OccUserPaymentAdapter\n    }, {\n      provide: CustomerCouponAdapter,\n      useClass: OccCustomerCouponAdapter\n    }, {\n      provide: UserNotificationPreferenceAdapter,\n      useClass: OccUserNotificationPreferenceAdapter\n    }, {\n      provide: UserInterestsAdapter,\n      useClass: OccUserInterestsAdapter\n    }, {\n      provide: UserCostCenterAdapter,\n      useClass: OccUserCostCenterAdapter\n    }, {\n      provide: PRODUCT_INTERESTS_NORMALIZER,\n      useExisting: OccUserInterestsNormalizer,\n      multi: true\n    }, {\n      provide: ANONYMOUS_CONSENT_NORMALIZER,\n      useExisting: AnonymousConsentNormalizer,\n      multi: true\n    }, {\n      provide: ADDRESS_LIST_NORMALIZER,\n      useExisting: OccAddressListNormalizer,\n      multi: true\n    }],\n    imports: [[CommonModule]]\n  });\n  return UserOccTransitional_4_2_Module;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserOccModule = /*#__PURE__*/(() => {\n  class UserOccModule {}\n  UserOccModule.ɵfac = function UserOccModule_Factory(t) {\n    return new (t || UserOccModule)();\n  };\n  UserOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserOccModule\n  });\n  UserOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultOccUserConfig), {\n      provide: UserAddressAdapter,\n      useClass: OccUserAddressAdapter\n    }, {\n      provide: UserConsentAdapter,\n      useClass: OccUserConsentAdapter\n    }, {\n      provide: AnonymousConsentTemplatesAdapter,\n      useClass: OccAnonymousConsentTemplatesAdapter\n    }, {\n      provide: UserPaymentAdapter,\n      useClass: OccUserPaymentAdapter\n    }, {\n      provide: UserOrderAdapter,\n      useClass: OccUserOrderAdapter\n    }, {\n      provide: CustomerCouponAdapter,\n      useClass: OccCustomerCouponAdapter\n    }, {\n      provide: UserNotificationPreferenceAdapter,\n      useClass: OccUserNotificationPreferenceAdapter\n    }, {\n      provide: UserInterestsAdapter,\n      useClass: OccUserInterestsAdapter\n    }, {\n      provide: UserCostCenterAdapter,\n      useClass: OccUserCostCenterAdapter\n    }, {\n      provide: PRODUCT_INTERESTS_NORMALIZER,\n      useExisting: OccUserInterestsNormalizer,\n      multi: true\n    }, {\n      provide: ORDER_RETURN_REQUEST_NORMALIZER,\n      useExisting: OccReturnRequestNormalizer,\n      multi: true\n    }, {\n      provide: ANONYMOUS_CONSENT_NORMALIZER,\n      useExisting: AnonymousConsentNormalizer,\n      multi: true\n    }, {\n      provide: ADDRESS_LIST_NORMALIZER,\n      useExisting: OccAddressListNormalizer,\n      multi: true\n    }, {\n      provide: UserReplenishmentOrderAdapter,\n      useClass: OccUserReplenishmentOrderAdapter\n    }],\n    imports: [[CommonModule]]\n  });\n  return UserOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst defaultOccConfig = {\n  backend: {\n    occ: {\n      prefix: '/occ/v2/'\n    },\n    media: {}\n  }\n};\nfunction occConfigValidator(config) {\n  if (config.backend === undefined || config.backend.occ === undefined || config.backend.occ.baseUrl === undefined) {\n    return 'Please configure backend.occ.baseUrl before using storefront library!';\n  }\n}\n\n/**\n * Http interceptor to add cookies to all cross-site requests.\n */\nlet WithCredentialsInterceptor = /*#__PURE__*/(() => {\n  class WithCredentialsInterceptor {\n    constructor(config) {\n      this.config = config;\n    }\n    /**\n     * Intercepts each request and adds the `withCredential` flag to it\n     * if it hasn't been added already.\n     */\n    intercept(request, next) {\n      if (this.requiresWithCredentials(request)) {\n        request = request.clone({\n          withCredentials: true\n        });\n      }\n      return next.handle(request);\n    }\n    /**\n     * indicates whether the request should use the WithCredentials flag.\n     */\n    requiresWithCredentials(request) {\n      var _a, _b;\n      return ((_a = this.occConfig) === null || _a === void 0 ? void 0 : _a.useWithCredentials) && request.url.indexOf((_b = this.occConfig) === null || _b === void 0 ? void 0 : _b.prefix) > -1;\n    }\n    get occConfig() {\n      return this.config.backend.occ;\n    }\n  }\n  WithCredentialsInterceptor.ɵfac = function WithCredentialsInterceptor_Factory(t) {\n    return new (t || WithCredentialsInterceptor)(i0.ɵɵinject(OccConfig));\n  };\n  WithCredentialsInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: WithCredentialsInterceptor,\n    factory: WithCredentialsInterceptor.ɵfac,\n    providedIn: 'root'\n  });\n  return WithCredentialsInterceptor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseOccModule = /*#__PURE__*/(() => {\n  class BaseOccModule {\n    static forRoot() {\n      return {\n        ngModule: BaseOccModule,\n        providers: [{\n          provide: HTTP_INTERCEPTORS,\n          useExisting: WithCredentialsInterceptor,\n          multi: true\n        }, provideDefaultConfig(defaultOccConfig), provideConfigValidator(occConfigValidator)]\n      };\n    }\n  }\n  BaseOccModule.ɵfac = function BaseOccModule_Factory(t) {\n    return new (t || BaseOccModule)();\n  };\n  BaseOccModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BaseOccModule\n  });\n  BaseOccModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CmsOccModule, SiteContextOccModule]]\n  });\n  return BaseOccModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst OCC_BASE_URL_META_TAG_NAME = 'occ-backend-base-url';\nconst OCC_BASE_URL_META_TAG_PLACEHOLDER = 'OCC_BACKEND_BASE_URL_VALUE';\nconst MEDIA_BASE_URL_META_TAG_NAME = 'media-backend-base-url';\nconst MEDIA_BASE_URL_META_TAG_PLACEHOLDER = 'MEDIA_BACKEND_BASE_URL_VALUE';\nfunction occServerConfigFromMetaTagFactory(meta) {\n  const baseUrl = getMetaTagContent(OCC_BASE_URL_META_TAG_NAME, meta);\n  return baseUrl && baseUrl !== OCC_BASE_URL_META_TAG_PLACEHOLDER ? {\n    backend: {\n      occ: {\n        baseUrl\n      }\n    }\n  } : {};\n}\nfunction mediaServerConfigFromMetaTagFactory(meta) {\n  const baseUrl = getMetaTagContent(MEDIA_BASE_URL_META_TAG_NAME, meta);\n  return baseUrl && baseUrl !== MEDIA_BASE_URL_META_TAG_PLACEHOLDER ? {\n    backend: {\n      media: {\n        baseUrl\n      }\n    }\n  } : {};\n}\nfunction getMetaTagContent(name, meta) {\n  const metaTag = meta.getTag(`name=\"${name}\"`);\n  return metaTag && metaTag.content;\n}\nfunction provideConfigFromMetaTags() {\n  return [provideConfigFactory(occServerConfigFromMetaTagFactory, [Meta]), provideConfigFactory(mediaServerConfigFromMetaTagFactory, [Meta])];\n}\nlet MetaTagConfigModule = /*#__PURE__*/(() => {\n  class MetaTagConfigModule {\n    static forRoot() {\n      return {\n        ngModule: MetaTagConfigModule,\n        providers: [...provideConfigFromMetaTags()]\n      };\n    }\n  }\n  MetaTagConfigModule.ɵfac = function MetaTagConfigModule_Factory(t) {\n    return new (t || MetaTagConfigModule)();\n  };\n  MetaTagConfigModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MetaTagConfigModule\n  });\n  MetaTagConfigModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return MetaTagConfigModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LoadingScopesService = /*#__PURE__*/(() => {\n  class LoadingScopesService {\n    constructor(config) {\n      this.config = config;\n    }\n    /**\n     * Aims to expand scopes based on loading scopes config.\n     *\n     * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']\n     *\n     * If scope data overlaps with each other, the data should be merged in the order of scopes provided,\n     * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.\n     * It should apply also to implicit scopes (that are included by configuration).\n     *\n     * @param model\n     * @param scopes\n     */\n    expand(model, scopes) {\n      var _a, _b, _c, _d;\n      const scopesConfig = (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.loadingScopes) === null || _c === void 0 ? void 0 : _c[model];\n      if (scopesConfig) {\n        const expandedScopes = [...scopes];\n        let i = expandedScopes.length;\n        while (i > 0) {\n          i--;\n          const includedScopes = (_d = scopesConfig[expandedScopes[i]]) === null || _d === void 0 ? void 0 : _d.include;\n          if (includedScopes) {\n            for (const includedScope of includedScopes) {\n              if (!expandedScopes.includes(includedScope)) {\n                expandedScopes.splice(i, 0, includedScope);\n                i++;\n              }\n            }\n          }\n        }\n        return expandedScopes;\n      }\n      return scopes;\n    }\n    /**\n     * Return maxAge for product scope in milliseconds\n     *\n     * @param model\n     * @param scope\n     */\n    getMaxAge(model, scope) {\n      var _a, _b, _c, _d, _e;\n      const configuredMaxAge = (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.maxAge) !== null && _e !== void 0 ? _e : 0;\n      return configuredMaxAge * 1000;\n    }\n    /**\n     *\n     * Returns the configured triggers for which to reload the product.\n     *\n     * @param model for which to look up the scopes (usually a 'product')\n     * @param scope for which to look up the config\n     * @returns the configured triggers, or an empty array if not configured\n     */\n    getReloadTriggers(model, scope) {\n      var _a, _b, _c, _d, _e;\n      return (_e = (_d = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.loadingScopes) === null || _b === void 0 ? void 0 : _b[model]) === null || _c === void 0 ? void 0 : _c[scope]) === null || _d === void 0 ? void 0 : _d.reloadOn) !== null && _e !== void 0 ? _e : [];\n    }\n  }\n  LoadingScopesService.ɵfac = function LoadingScopesService_Factory(t) {\n    return new (t || LoadingScopesService)(i0.ɵɵinject(OccConfig));\n  };\n  LoadingScopesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LoadingScopesService,\n    factory: LoadingScopesService.ɵfac,\n    providedIn: 'root'\n  });\n  return LoadingScopesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getReducers$2() {\n  return entityLoaderReducer(PROCESS_FEATURE);\n}\nconst reducerToken$2 = new InjectionToken('ProcessReducers');\nconst reducerProvider$2 = {\n  provide: reducerToken$2,\n  useFactory: getReducers$2\n};\nlet ProcessStoreModule = /*#__PURE__*/(() => {\n  class ProcessStoreModule {}\n  ProcessStoreModule.ɵfac = function ProcessStoreModule_Factory(t) {\n    return new (t || ProcessStoreModule)();\n  };\n  ProcessStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProcessStoreModule\n  });\n  ProcessStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerProvider$2],\n    imports: [[StateModule, StoreModule.forFeature(PROCESS_FEATURE, reducerToken$2)]]\n  });\n  return ProcessStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProcessModule = /*#__PURE__*/(() => {\n  class ProcessModule {\n    static forRoot() {\n      return {\n        ngModule: ProcessModule,\n        providers: []\n      };\n    }\n  }\n  ProcessModule.ɵfac = function ProcessModule_Factory(t) {\n    return new (t || ProcessModule)();\n  };\n  ProcessModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProcessModule\n  });\n  ProcessModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[ProcessStoreModule]]\n  });\n  return ProcessModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductConnector = /*#__PURE__*/(() => {\n  class ProductConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    get(productCode, scope = '') {\n      return this.adapter.load(productCode, scope);\n    }\n    getMany(products) {\n      if (!this.adapter.loadMany) {\n        return products.map(product => Object.assign(Object.assign({}, product), {\n          data$: this.adapter.load(product.code, product.scope)\n        }));\n      }\n      return this.adapter.loadMany(products);\n    }\n  }\n  ProductConnector.ɵfac = function ProductConnector_Factory(t) {\n    return new (t || ProductConnector)(i0.ɵɵinject(ProductAdapter));\n  };\n  ProductConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductConnector,\n    factory: ProductConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReferencesConnector = /*#__PURE__*/(() => {\n  class ProductReferencesConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    get(productCode, referenceType, pageSize) {\n      return this.adapter.load(productCode, referenceType, pageSize);\n    }\n  }\n  ProductReferencesConnector.ɵfac = function ProductReferencesConnector_Factory(t) {\n    return new (t || ProductReferencesConnector)(i0.ɵɵinject(ProductReferencesAdapter));\n  };\n  ProductReferencesConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReferencesConnector,\n    factory: ProductReferencesConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductReferencesConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReviewsConnector = /*#__PURE__*/(() => {\n  class ProductReviewsConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    get(productCode, maxCount) {\n      return this.adapter.load(productCode, maxCount);\n    }\n    add(productCode, review) {\n      return this.adapter.post(productCode, review);\n    }\n  }\n  ProductReviewsConnector.ɵfac = function ProductReviewsConnector_Factory(t) {\n    return new (t || ProductReviewsConnector)(i0.ɵɵinject(ProductReviewsAdapter));\n  };\n  ProductReviewsConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReviewsConnector,\n    factory: ProductReviewsConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductReviewsConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductSearchConnector = /*#__PURE__*/(() => {\n  class ProductSearchConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    search(query, searchConfig) {\n      return this.adapter.search(query, searchConfig);\n    }\n    getSuggestions(term, pageSize) {\n      return this.adapter.loadSuggestions(term, pageSize);\n    }\n  }\n  ProductSearchConnector.ɵfac = function ProductSearchConnector_Factory(t) {\n    return new (t || ProductSearchConnector)(i0.ɵɵinject(ProductSearchAdapter));\n  };\n  ProductSearchConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductSearchConnector,\n    factory: ProductSearchConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductSearchConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Indicates that a user select or unselect a facet value\n */\nlet FacetChangedEvent = /*#__PURE__*/(() => {\n  class FacetChangedEvent extends CxEvent {}\n  /**\n   * Event's type\n   */\n  FacetChangedEvent.type = 'FacetChangedEvent';\n  return FacetChangedEvent;\n})();\nconst LOAD_PRODUCT_REFERENCES = '[Product] Load Product References Data';\nconst LOAD_PRODUCT_REFERENCES_FAIL = '[Product] Load Product References Data Fail';\nconst LOAD_PRODUCT_REFERENCES_SUCCESS = '[Product] Load Product References Data Success';\nconst CLEAN_PRODUCT_REFERENCES = '[Product] Clean Product References';\nclass LoadProductReferences {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REFERENCES;\n  }\n}\nclass LoadProductReferencesFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REFERENCES_FAIL;\n  }\n}\nclass LoadProductReferencesSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REFERENCES_SUCCESS;\n  }\n}\nclass CleanProductReferences {\n  constructor() {\n    this.type = CLEAN_PRODUCT_REFERENCES;\n  }\n}\nconst LOAD_PRODUCT_REVIEWS = '[Product] Load Product Reviews Data';\nconst LOAD_PRODUCT_REVIEWS_FAIL = '[Product] Load Product Reviews Data Fail';\nconst LOAD_PRODUCT_REVIEWS_SUCCESS = '[Product] Load Product Reviews Data Success';\nconst POST_PRODUCT_REVIEW = '[Product] Post Product Review';\nconst POST_PRODUCT_REVIEW_FAIL = '[Product] Post Product Review Fail';\nconst POST_PRODUCT_REVIEW_SUCCESS = '[Product] Post Product Review Success';\nclass LoadProductReviews {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REVIEWS;\n  }\n}\nclass LoadProductReviewsFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REVIEWS_FAIL;\n  }\n}\nclass LoadProductReviewsSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_REVIEWS_SUCCESS;\n  }\n}\nclass PostProductReview {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = POST_PRODUCT_REVIEW;\n  }\n}\nclass PostProductReviewFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = POST_PRODUCT_REVIEW_FAIL;\n  }\n}\nclass PostProductReviewSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = POST_PRODUCT_REVIEW_SUCCESS;\n  }\n}\nconst SEARCH_PRODUCTS = '[Product] Search Products';\nconst SEARCH_PRODUCTS_FAIL = '[Product] Search Products Fail';\nconst SEARCH_PRODUCTS_SUCCESS = '[Product] Search Products Success';\nconst GET_PRODUCT_SUGGESTIONS = '[Product] Get Product Suggestions';\nconst GET_PRODUCT_SUGGESTIONS_SUCCESS = '[Product] Get Product Suggestions Success';\nconst GET_PRODUCT_SUGGESTIONS_FAIL = '[Product] Get Product Suggestions Fail';\nconst CLEAR_PRODUCT_SEARCH_RESULT = '[Product] Clear Product Search Result';\nclass SearchProducts {\n  constructor(payload, auxiliary) {\n    this.payload = payload;\n    this.auxiliary = auxiliary;\n    this.type = SEARCH_PRODUCTS;\n  }\n}\nclass SearchProductsFail {\n  constructor(payload, auxiliary) {\n    this.payload = payload;\n    this.auxiliary = auxiliary;\n    this.type = SEARCH_PRODUCTS_FAIL;\n  }\n}\nclass SearchProductsSuccess {\n  constructor(payload, auxiliary) {\n    this.payload = payload;\n    this.auxiliary = auxiliary;\n    this.type = SEARCH_PRODUCTS_SUCCESS;\n  }\n}\nclass GetProductSuggestions {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = GET_PRODUCT_SUGGESTIONS;\n  }\n}\nclass GetProductSuggestionsSuccess {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = GET_PRODUCT_SUGGESTIONS_SUCCESS;\n  }\n}\nclass GetProductSuggestionsFail {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = GET_PRODUCT_SUGGESTIONS_FAIL;\n  }\n}\nclass ClearProductSearchResult {\n  constructor(payload = {\n    clearPageResults: false,\n    clearSearchboxResults: false\n  }) {\n    this.payload = payload;\n    this.type = CLEAR_PRODUCT_SEARCH_RESULT;\n  }\n}\nvar EntityScopedLoaderActions;\n(function (EntityScopedLoaderActions) {\n  function entityScopedLoadMeta(entityType, id, scope) {\n    return Object.assign(Object.assign({}, entityLoadMeta(entityType, id)), {\n      scope\n    });\n  }\n  EntityScopedLoaderActions.entityScopedLoadMeta = entityScopedLoadMeta;\n  function entityScopedFailMeta(entityType, id, scope, error) {\n    return Object.assign(Object.assign({}, entityFailMeta(entityType, id, error)), {\n      scope\n    });\n  }\n  EntityScopedLoaderActions.entityScopedFailMeta = entityScopedFailMeta;\n  function entityScopedSuccessMeta(entityType, id, scope) {\n    return Object.assign(Object.assign({}, entitySuccessMeta(entityType, id)), {\n      scope\n    });\n  }\n  EntityScopedLoaderActions.entityScopedSuccessMeta = entityScopedSuccessMeta;\n  function entityScopedResetMeta(entityType, id, scope) {\n    return Object.assign(Object.assign({}, entityResetMeta(entityType, id)), {\n      scope\n    });\n  }\n  EntityScopedLoaderActions.entityScopedResetMeta = entityScopedResetMeta;\n  class EntityScopedLoadAction {\n    constructor(entityType, id, scope) {\n      this.type = ENTITY_LOAD_ACTION;\n      this.meta = entityScopedLoadMeta(entityType, id, scope);\n    }\n  }\n  EntityScopedLoaderActions.EntityScopedLoadAction = EntityScopedLoadAction;\n  class EntityScopedFailAction {\n    constructor(entityType, id, scope, error) {\n      this.type = ENTITY_FAIL_ACTION;\n      this.meta = entityScopedFailMeta(entityType, id, scope, error);\n    }\n  }\n  EntityScopedLoaderActions.EntityScopedFailAction = EntityScopedFailAction;\n  class EntityScopedSuccessAction {\n    constructor(entityType, id, scope, payload) {\n      this.payload = payload;\n      this.type = ENTITY_SUCCESS_ACTION;\n      this.meta = entityScopedSuccessMeta(entityType, id, scope);\n    }\n  }\n  EntityScopedLoaderActions.EntityScopedSuccessAction = EntityScopedSuccessAction;\n  class EntityScopedResetAction {\n    constructor(entityType, id, scope) {\n      this.type = ENTITY_RESET_ACTION;\n      this.meta = entityScopedResetMeta(entityType, id, scope);\n    }\n  }\n  EntityScopedLoaderActions.EntityScopedResetAction = EntityScopedResetAction;\n})(EntityScopedLoaderActions || (EntityScopedLoaderActions = {}));\nconst PRODUCT_FEATURE = 'product';\nconst PRODUCT_DETAIL_ENTITY = '[Product] Detail Entity';\nconst LOAD_PRODUCT = '[Product] Load Product Data';\nconst LOAD_PRODUCT_FAIL = '[Product] Load Product Data Fail';\nconst LOAD_PRODUCT_SUCCESS = '[Product] Load Product Data Success';\nconst CLEAR_PRODUCT_PRICE = '[Product] Clear Product PRICE';\nclass LoadProduct extends EntityScopedLoaderActions.EntityScopedLoadAction {\n  constructor(payload, scope = '') {\n    super(PRODUCT_DETAIL_ENTITY, payload, scope);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT;\n  }\n}\nclass LoadProductFail extends EntityScopedLoaderActions.EntityScopedFailAction {\n  constructor(productCode, payload, scope = '') {\n    super(PRODUCT_DETAIL_ENTITY, productCode, scope, payload);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_FAIL;\n  }\n}\nclass LoadProductSuccess extends EntityScopedLoaderActions.EntityScopedSuccessAction {\n  constructor(payload, scope = '') {\n    super(PRODUCT_DETAIL_ENTITY, payload.code, scope);\n    this.payload = payload;\n    this.type = LOAD_PRODUCT_SUCCESS;\n  }\n}\nclass ClearProductPrice extends EntityScopedLoaderActions.EntityScopedResetAction {\n  constructor() {\n    super(PRODUCT_DETAIL_ENTITY, undefined, \"price\" /* PRICE */);\n    this.type = CLEAR_PRODUCT_PRICE;\n  }\n}\nvar productGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LOAD_PRODUCT_REFERENCES: LOAD_PRODUCT_REFERENCES,\n  LOAD_PRODUCT_REFERENCES_FAIL: LOAD_PRODUCT_REFERENCES_FAIL,\n  LOAD_PRODUCT_REFERENCES_SUCCESS: LOAD_PRODUCT_REFERENCES_SUCCESS,\n  CLEAN_PRODUCT_REFERENCES: CLEAN_PRODUCT_REFERENCES,\n  LoadProductReferences: LoadProductReferences,\n  LoadProductReferencesFail: LoadProductReferencesFail,\n  LoadProductReferencesSuccess: LoadProductReferencesSuccess,\n  CleanProductReferences: CleanProductReferences,\n  LOAD_PRODUCT_REVIEWS: LOAD_PRODUCT_REVIEWS,\n  LOAD_PRODUCT_REVIEWS_FAIL: LOAD_PRODUCT_REVIEWS_FAIL,\n  LOAD_PRODUCT_REVIEWS_SUCCESS: LOAD_PRODUCT_REVIEWS_SUCCESS,\n  POST_PRODUCT_REVIEW: POST_PRODUCT_REVIEW,\n  POST_PRODUCT_REVIEW_FAIL: POST_PRODUCT_REVIEW_FAIL,\n  POST_PRODUCT_REVIEW_SUCCESS: POST_PRODUCT_REVIEW_SUCCESS,\n  LoadProductReviews: LoadProductReviews,\n  LoadProductReviewsFail: LoadProductReviewsFail,\n  LoadProductReviewsSuccess: LoadProductReviewsSuccess,\n  PostProductReview: PostProductReview,\n  PostProductReviewFail: PostProductReviewFail,\n  PostProductReviewSuccess: PostProductReviewSuccess,\n  SEARCH_PRODUCTS: SEARCH_PRODUCTS,\n  SEARCH_PRODUCTS_FAIL: SEARCH_PRODUCTS_FAIL,\n  SEARCH_PRODUCTS_SUCCESS: SEARCH_PRODUCTS_SUCCESS,\n  GET_PRODUCT_SUGGESTIONS: GET_PRODUCT_SUGGESTIONS,\n  GET_PRODUCT_SUGGESTIONS_SUCCESS: GET_PRODUCT_SUGGESTIONS_SUCCESS,\n  GET_PRODUCT_SUGGESTIONS_FAIL: GET_PRODUCT_SUGGESTIONS_FAIL,\n  CLEAR_PRODUCT_SEARCH_RESULT: CLEAR_PRODUCT_SEARCH_RESULT,\n  SearchProducts: SearchProducts,\n  SearchProductsFail: SearchProductsFail,\n  SearchProductsSuccess: SearchProductsSuccess,\n  GetProductSuggestions: GetProductSuggestions,\n  GetProductSuggestionsSuccess: GetProductSuggestionsSuccess,\n  GetProductSuggestionsFail: GetProductSuggestionsFail,\n  ClearProductSearchResult: ClearProductSearchResult,\n  LOAD_PRODUCT: LOAD_PRODUCT,\n  LOAD_PRODUCT_FAIL: LOAD_PRODUCT_FAIL,\n  LOAD_PRODUCT_SUCCESS: LOAD_PRODUCT_SUCCESS,\n  CLEAR_PRODUCT_PRICE: CLEAR_PRODUCT_PRICE,\n  LoadProduct: LoadProduct,\n  LoadProductFail: LoadProductFail,\n  LoadProductSuccess: LoadProductSuccess,\n  ClearProductPrice: ClearProductPrice\n});\nconst getProductsState = createFeatureSelector(PRODUCT_FEATURE);\nconst getProductReferencesState = createSelector(getProductsState, state => state.references);\nconst getSelectedProductReferencesFactory = (productCode, referenceType) => {\n  return createSelector(getProductReferencesState, referenceTypeData => {\n    if (referenceTypeData.productCode === productCode) {\n      if (!!referenceTypeData.list) {\n        if (referenceType) {\n          return referenceTypeData.list.filter(item => item.referenceType === referenceType);\n        }\n        return referenceTypeData.list;\n      } else {\n        return [];\n      }\n    }\n  });\n};\nconst getProductReviewsState = createSelector(getProductsState, state => state.reviews);\nconst getSelectedProductReviewsFactory = productCode => {\n  return createSelector(getProductReviewsState, reviewData => {\n    if (reviewData.productCode === productCode) {\n      return reviewData.list;\n    }\n  });\n};\nconst initialState$i = {\n  results: {},\n  suggestions: [],\n  auxResults: {}\n};\nfunction reducer$i(state = initialState$i, action) {\n  switch (action.type) {\n    case SEARCH_PRODUCTS_SUCCESS:\n      {\n        const results = action.payload;\n        const res = action.auxiliary ? {\n          auxResults: results\n        } : {\n          results\n        };\n        return Object.assign(Object.assign({}, state), res);\n      }\n    case GET_PRODUCT_SUGGESTIONS_SUCCESS:\n      {\n        const suggestions = action.payload;\n        return Object.assign(Object.assign({}, state), {\n          suggestions\n        });\n      }\n    case CLEAR_PRODUCT_SEARCH_RESULT:\n      {\n        return Object.assign(Object.assign({}, state), {\n          results: action.payload.clearPageResults ? {} : state.results,\n          suggestions: action.payload.clearSearchboxResults ? [] : state.suggestions,\n          auxResults: action.payload.clearSearchboxResults ? {} : state.auxResults\n        });\n      }\n  }\n  return state;\n}\nconst getSearchResults$1 = state => state.results;\nconst getAuxSearchResults$1 = state => state.auxResults;\nconst getProductSuggestions$1 = state => state.suggestions;\nconst getProductsSearchState = createSelector(getProductsState, state => state.search);\nconst getSearchResults = createSelector(getProductsSearchState, getSearchResults$1);\nconst getAuxSearchResults = createSelector(getProductsSearchState, getAuxSearchResults$1);\nconst getProductSuggestions = createSelector(getProductsSearchState, getProductSuggestions$1);\nconst getProductState = createSelector(getProductsState, state => state.details);\nconst getSelectedProductStateFactory = (code, scope = '') => {\n  return createSelector(getProductState, details => entityLoaderStateSelector(details, code)[scope] || initialLoaderState);\n};\nconst getSelectedProductFactory = (code, scope = '') => {\n  return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderValueSelector(productState));\n};\nconst getSelectedProductLoadingFactory = (code, scope = '') => {\n  return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderLoadingSelector(productState));\n};\nconst getSelectedProductSuccessFactory = (code, scope = '') => {\n  return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderSuccessSelector(productState));\n};\nconst getSelectedProductErrorFactory = (code, scope = '') => {\n  return createSelector(getSelectedProductStateFactory(code, scope), productState => loaderErrorSelector(productState));\n};\nconst getAllProductCodes = createSelector(getProductState, details => {\n  return Object.keys(details.entities);\n});\nvar productGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getProductsState: getProductsState,\n  getProductReferencesState: getProductReferencesState,\n  getSelectedProductReferencesFactory: getSelectedProductReferencesFactory,\n  getProductReviewsState: getProductReviewsState,\n  getSelectedProductReviewsFactory: getSelectedProductReviewsFactory,\n  getProductsSearchState: getProductsSearchState,\n  getSearchResults: getSearchResults,\n  getAuxSearchResults: getAuxSearchResults,\n  getProductSuggestions: getProductSuggestions,\n  getProductState: getProductState,\n  getSelectedProductStateFactory: getSelectedProductStateFactory,\n  getSelectedProductFactory: getSelectedProductFactory,\n  getSelectedProductLoadingFactory: getSelectedProductLoadingFactory,\n  getSelectedProductSuccessFactory: getSelectedProductSuccessFactory,\n  getSelectedProductErrorFactory: getSelectedProductErrorFactory,\n  getAllProductCodes: getAllProductCodes\n});\nlet ProductSearchService = /*#__PURE__*/(() => {\n  class ProductSearchService {\n    constructor(store) {\n      this.store = store;\n    }\n    search(query, searchConfig) {\n      this.store.dispatch(new SearchProducts({\n        queryText: query,\n        searchConfig: searchConfig\n      }));\n    }\n    getResults() {\n      return this.store.pipe(select(getSearchResults));\n    }\n    clearResults() {\n      this.store.dispatch(new ClearProductSearchResult({\n        clearPageResults: true\n      }));\n    }\n  }\n  ProductSearchService.ɵfac = function ProductSearchService_Factory(t) {\n    return new (t || ProductSearchService)(i0.ɵɵinject(i1$2.Store));\n  };\n  ProductSearchService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductSearchService,\n    factory: ProductSearchService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductSearchService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductEventBuilder = /*#__PURE__*/(() => {\n  class ProductEventBuilder {\n    constructor(eventService, productSearchService) {\n      this.eventService = eventService;\n      this.productSearchService = productSearchService;\n      this.register();\n    }\n    register() {\n      this.eventService.register(FacetChangedEvent, this.buildFacetChangedEvent());\n    }\n    /**\n     * To get the changed facet, we need to compare the product search results\n     * got before and after toggling the facet value. These 2 product searches must\n     * have the same search queries except one different solr filter term. That means\n     * these 2 searches must have the same 'freeTextSearch'; and if they are category\n     * searches, they must have the same root (in the same category or brand).\n     */\n    buildFacetChangedEvent() {\n      return this.productSearchService.getResults().pipe(pairwise(), filter(([prev, curr]) => this.compareSearchResults(prev, curr)), map(([prev, curr]) => {\n        const toggled = this.getToggledBreadcrumb(curr.breadcrumbs, prev.breadcrumbs) || this.getToggledBreadcrumb(prev.breadcrumbs, curr.breadcrumbs);\n        if (toggled) {\n          return createFrom(FacetChangedEvent, {\n            code: toggled.facetCode,\n            name: toggled.facetName,\n            valueCode: toggled.facetValueCode,\n            valueName: toggled.facetValueName,\n            selected: curr.breadcrumbs.length > prev.breadcrumbs.length\n          });\n        }\n      }));\n    }\n    /**\n     * The 2 product searches (before and after facet changed) must have the same\n     * search queries; and if they are category searches, they also must have the\n     * same root (in the same category or brand).\n     */\n    compareSearchResults(prev, curr) {\n      var _a, _b, _c;\n      if (prev && Object.keys(prev).length !== 0) {\n        // for text searches, they must have the same freeTextSearch\n        const sameFreeTextSearch = prev.freeTextSearch !== '' && prev.freeTextSearch === curr.freeTextSearch;\n        // for category searches, they must have the same root\n        const sameCategoryRoot = ((_a = curr.breadcrumbs[0]) === null || _a === void 0 ? void 0 : _a.facetCode) === 'allCategories' && ((_b = prev.breadcrumbs[0]) === null || _b === void 0 ? void 0 : _b.facetCode) === ((_c = curr.breadcrumbs[0]) === null || _c === void 0 ? void 0 : _c.facetCode) &&\n        // same category or brand\n        prev.breadcrumbs[0].facetValueCode === curr.breadcrumbs[0].facetValueCode;\n        return sameFreeTextSearch || sameCategoryRoot;\n      }\n    }\n    /**\n     * Get the toggled breadcrumb. The 2 breadcrumb lists got from the 2 search results\n     * only can have one different solr filter term.\n     */\n    getToggledBreadcrumb(bc1, bc2) {\n      if (bc1.length - bc2.length === 1) {\n        return bc1.find(x => !bc2.find(y => y.facetCode === x.facetCode && y.facetValueCode === x.facetValueCode));\n      }\n    }\n  }\n  ProductEventBuilder.ɵfac = function ProductEventBuilder_Factory(t) {\n    return new (t || ProductEventBuilder)(i0.ɵɵinject(EventService), i0.ɵɵinject(ProductSearchService));\n  };\n  ProductEventBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductEventBuilder,\n    factory: ProductEventBuilder.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductEventBuilder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductEventModule = /*#__PURE__*/(() => {\n  class ProductEventModule {\n    constructor(_productEventBuilder) {}\n  }\n  ProductEventModule.ɵfac = function ProductEventModule_Factory(t) {\n    return new (t || ProductEventModule)(i0.ɵɵinject(ProductEventBuilder));\n  };\n  ProductEventModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProductEventModule\n  });\n  ProductEventModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ProductEventModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReferencesEffects = /*#__PURE__*/(() => {\n  class ProductReferencesEffects {\n    constructor(actions$, productReferencesConnector) {\n      this.actions$ = actions$;\n      this.productReferencesConnector = productReferencesConnector;\n      this.loadProductReferences$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REFERENCES), map(action => action.payload), mergeMap(payload => {\n        return this.productReferencesConnector.get(payload.productCode, payload.referenceType, payload.pageSize).pipe(map(data => {\n          return new LoadProductReferencesSuccess({\n            productCode: payload.productCode,\n            list: data\n          });\n        }), catchError(_error => of(new LoadProductReferencesFail({\n          message: payload.productCode\n        }))));\n      }));\n    }\n  }\n  ProductReferencesEffects.ɵfac = function ProductReferencesEffects_Factory(t) {\n    return new (t || ProductReferencesEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(ProductReferencesConnector));\n  };\n  ProductReferencesEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReferencesEffects,\n    factory: ProductReferencesEffects.ɵfac\n  });\n  __decorate([Effect()], ProductReferencesEffects.prototype, \"loadProductReferences$\", void 0);\n  return ProductReferencesEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReviewsEffects = /*#__PURE__*/(() => {\n  class ProductReviewsEffects {\n    constructor(actions$, productReviewsConnector, globalMessageService) {\n      this.actions$ = actions$;\n      this.productReviewsConnector = productReviewsConnector;\n      this.globalMessageService = globalMessageService;\n      this.loadProductReviews$ = this.actions$.pipe(ofType(LOAD_PRODUCT_REVIEWS), map(action => action.payload), mergeMap(productCode => {\n        return this.productReviewsConnector.get(productCode).pipe(map(data => {\n          return new LoadProductReviewsSuccess({\n            productCode,\n            list: data\n          });\n        }), catchError(_error => of(new LoadProductReviewsFail({\n          message: productCode\n        }))));\n      }));\n      this.postProductReview = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW), map(action => action.payload), mergeMap(payload => {\n        return this.productReviewsConnector.add(payload.productCode, payload.review).pipe(map(reviewResponse => {\n          return new PostProductReviewSuccess(reviewResponse);\n        }), catchError(_error => of(new PostProductReviewFail(payload.productCode))));\n      }));\n      this.showGlobalMessageOnPostProductReviewSuccess$ = this.actions$.pipe(ofType(POST_PRODUCT_REVIEW_SUCCESS), tap(() => {\n        this.globalMessageService.add({\n          key: 'productReview.thankYouForReview'\n        }, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n      }));\n    }\n  }\n  ProductReviewsEffects.ɵfac = function ProductReviewsEffects_Factory(t) {\n    return new (t || ProductReviewsEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(ProductReviewsConnector), i0.ɵɵinject(GlobalMessageService));\n  };\n  ProductReviewsEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReviewsEffects,\n    factory: ProductReviewsEffects.ɵfac\n  });\n  __decorate([Effect()], ProductReviewsEffects.prototype, \"loadProductReviews$\", void 0);\n  __decorate([Effect()], ProductReviewsEffects.prototype, \"postProductReview\", void 0);\n  __decorate([Effect({\n    dispatch: false\n  })], ProductReviewsEffects.prototype, \"showGlobalMessageOnPostProductReviewSuccess$\", void 0);\n  return ProductReviewsEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductsSearchEffects = /*#__PURE__*/(() => {\n  class ProductsSearchEffects {\n    constructor(actions$, productSearchConnector) {\n      this.actions$ = actions$;\n      this.productSearchConnector = productSearchConnector;\n      this.searchProducts$ = this.actions$.pipe(ofType(SEARCH_PRODUCTS), groupBy(action => action.auxiliary), mergeMap(group => group.pipe(switchMap(action => {\n        return this.productSearchConnector.search(action.payload.queryText, action.payload.searchConfig).pipe(map(data => {\n          return new SearchProductsSuccess(data, action.auxiliary);\n        }), catchError(error => of(new SearchProductsFail(normalizeHttpError(error), action.auxiliary))));\n      }))));\n      this.getProductSuggestions$ = this.actions$.pipe(ofType(GET_PRODUCT_SUGGESTIONS), map(action => action.payload), switchMap(payload => {\n        return this.productSearchConnector.getSuggestions(payload.term, payload.searchConfig.pageSize).pipe(map(suggestions => {\n          if (suggestions === undefined) {\n            return new GetProductSuggestionsSuccess([]);\n          }\n          return new GetProductSuggestionsSuccess(suggestions);\n        }), catchError(error => of(new GetProductSuggestionsFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  ProductsSearchEffects.ɵfac = function ProductsSearchEffects_Factory(t) {\n    return new (t || ProductsSearchEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(ProductSearchConnector));\n  };\n  ProductsSearchEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductsSearchEffects,\n    factory: ProductsSearchEffects.ɵfac\n  });\n  __decorate([Effect()], ProductsSearchEffects.prototype, \"searchProducts$\", void 0);\n  __decorate([Effect()], ProductsSearchEffects.prototype, \"getProductSuggestions$\", void 0);\n  return ProductsSearchEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductEffects = /*#__PURE__*/(() => {\n  class ProductEffects {\n    constructor(actions$, productConnector) {\n      this.actions$ = actions$;\n      this.productConnector = productConnector;\n      // we want to cancel all ongoing requests when currency or language changes,\n      this.contextChange$ = this.actions$.pipe(ofType(CURRENCY_CHANGE, LANGUAGE_CHANGE));\n      this.loadProduct$ = createEffect(() => ({\n        scheduler,\n        debounce = 0\n      } = {}) => this.actions$.pipe(ofType(LOAD_PRODUCT), map(action => ({\n        code: action.payload,\n        scope: action.meta.scope\n      })),\n      // we are grouping all load actions that happens at the same time\n      // to optimize loading and pass them all to productConnector.getMany\n      bufferDebounceTime(debounce, scheduler), mergeMap(products => merge(...this.productConnector.getMany(products).map(this.productLoadEffect))), withdrawOn(this.contextChange$)));\n      this.clearProductPrice$ = this.actions$.pipe(ofType(LOGOUT, LOGIN), map(() => new ClearProductPrice()));\n    }\n    productLoadEffect(productLoad) {\n      return productLoad.data$.pipe(map(data => new LoadProductSuccess(Object.assign({\n        code: productLoad.code\n      }, data), productLoad.scope)), catchError(error => {\n        return of(new LoadProductFail(productLoad.code, normalizeHttpError(error), productLoad.scope));\n      }));\n    }\n  }\n  ProductEffects.ɵfac = function ProductEffects_Factory(t) {\n    return new (t || ProductEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(ProductConnector));\n  };\n  ProductEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductEffects,\n    factory: ProductEffects.ɵfac\n  });\n  __decorate([Effect()], ProductEffects.prototype, \"clearProductPrice$\", void 0);\n  return ProductEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects = [ProductsSearchEffects, ProductEffects, ProductReviewsEffects, ProductReferencesEffects];\nconst initialState$h = {\n  productCode: '',\n  list: []\n};\nfunction reducer$h(state = initialState$h, action) {\n  switch (action.type) {\n    case LOAD_PRODUCT_REFERENCES_SUCCESS:\n      {\n        const productCode = action.payload.productCode;\n        const list = action.payload.list;\n        return Object.assign(Object.assign({}, state), {\n          list: [...state.list, ...(list ? list : [])].reduce((productReferences, productReference) => {\n            if (!productReferences.some(obj => obj.referenceType === productReference.referenceType && obj.target.code === productReference.target.code)) {\n              productReferences.push(productReference);\n            }\n            return productReferences;\n          }, []),\n          productCode\n        });\n      }\n    case CLEAN_PRODUCT_REFERENCES:\n      {\n        return initialState$h;\n      }\n  }\n  return state;\n}\nconst getProductReferenceList = state => state.list;\nconst getProductReferenceProductCode = state => state.productCode;\nconst initialState$g = {\n  productCode: '',\n  list: []\n};\nfunction reducer$g(state = initialState$g, action) {\n  switch (action.type) {\n    case LOAD_PRODUCT_REVIEWS_SUCCESS:\n      {\n        const productCode = action.payload.productCode;\n        const list = action.payload.list;\n        return Object.assign(Object.assign({}, state), {\n          productCode,\n          list\n        });\n      }\n  }\n  return state;\n}\nconst getReviewList = state => state.list;\nconst getReviewProductCode = state => state.productCode;\nconst initialScopedLoaderState = {};\n/**\n * Higher order reducer designed to add scope support for loader reducer\n *\n * @param entityType\n * @param reducer\n */\nfunction scopedLoaderReducer(entityType, reducer) {\n  const loader = loaderReducer(entityType, reducer);\n  return (state = initialScopedLoaderState, action) => {\n    var _a;\n    if (action && action.meta && action.meta.entityType === entityType) {\n      return Object.assign(Object.assign({}, state), {\n        [(_a = action.meta.scope) !== null && _a !== void 0 ? _a : '']: loader(state[action.meta.scope], action)\n      });\n    }\n    return state;\n  };\n}\n\n/**\n * Higher order reducer that wraps scopedLoaderReducer and EntityReducer enhancing\n * single state reducer to support multiple entities with generic loading flags and scopes\n */\nfunction entityScopedLoaderReducer(entityType, reducer) {\n  return entityReducer(entityType, scopedLoaderReducer(entityType, reducer));\n}\nfunction getReducers$1() {\n  return {\n    search: reducer$i,\n    details: entityScopedLoaderReducer(PRODUCT_DETAIL_ENTITY),\n    reviews: reducer$g,\n    references: reducer$h\n  };\n}\nconst reducerToken$1 = new InjectionToken('ProductReducers');\nconst reducerProvider$1 = {\n  provide: reducerToken$1,\n  useFactory: getReducers$1\n};\nfunction clearProductsState(reducer) {\n  return function (state, action) {\n    if (action.type === CURRENCY_CHANGE || action.type === LANGUAGE_CHANGE) {\n      state = undefined;\n    }\n    return reducer(state, action);\n  };\n}\nconst metaReducers$1 = [clearProductsState];\nlet ProductReferenceService = /*#__PURE__*/(() => {\n  class ProductReferenceService {\n    constructor(store) {\n      this.store = store;\n    }\n    loadProductReferences(productCode, referenceType, pageSize) {\n      this.store.dispatch(new LoadProductReferences({\n        productCode,\n        referenceType,\n        pageSize\n      }));\n    }\n    getProductReferences(productCode, referenceType) {\n      return this.store.pipe(select(getSelectedProductReferencesFactory(productCode, referenceType)));\n    }\n    cleanReferences() {\n      this.store.dispatch(new CleanProductReferences());\n    }\n  }\n  ProductReferenceService.ɵfac = function ProductReferenceService_Factory(t) {\n    return new (t || ProductReferenceService)(i0.ɵɵinject(i1$2.Store));\n  };\n  ProductReferenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReferenceService,\n    factory: ProductReferenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductReferenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductReviewService = /*#__PURE__*/(() => {\n  class ProductReviewService {\n    constructor(store) {\n      this.store = store;\n    }\n    getByProductCode(productCode) {\n      return this.store.pipe(select(getSelectedProductReviewsFactory(productCode)), tap(reviews => {\n        if (reviews === undefined && productCode !== undefined) {\n          this.store.dispatch(new LoadProductReviews(productCode));\n        }\n      }));\n    }\n    add(productCode, review) {\n      this.store.dispatch(new PostProductReview({\n        productCode: productCode,\n        review\n      }));\n    }\n  }\n  ProductReviewService.ɵfac = function ProductReviewService_Factory(t) {\n    return new (t || ProductReviewService)(i0.ɵɵinject(i1$2.Store));\n  };\n  ProductReviewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductReviewService,\n    factory: ProductReviewService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductReviewService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductLoadingService = /*#__PURE__*/(() => {\n  class ProductLoadingService {\n    constructor(store, loadingScopes, actions$, platformId, eventService) {\n      this.store = store;\n      this.loadingScopes = loadingScopes;\n      this.actions$ = actions$;\n      this.platformId = platformId;\n      this.eventService = eventService;\n      this.products = {};\n    }\n    get(productCode, scopes) {\n      scopes = this.loadingScopes.expand('product', scopes);\n      this.initProductScopes(productCode, scopes);\n      return this.products[productCode][this.getScopesIndex(scopes)];\n    }\n    initProductScopes(productCode, scopes) {\n      if (!this.products[productCode]) {\n        this.products[productCode] = {};\n      }\n      for (const scope of scopes) {\n        if (!this.products[productCode][scope]) {\n          this.products[productCode][scope] = this.getProductForScope(productCode, scope);\n        }\n      }\n      if (scopes.length > 1) {\n        this.products[productCode][this.getScopesIndex(scopes)] = uniteLatest(scopes.map(scope => this.products[productCode][scope])).pipe(map(productParts => productParts.every(Boolean) ? deepMerge({}, ...productParts) : undefined), distinctUntilChanged());\n      }\n    }\n    getScopesIndex(scopes) {\n      return scopes.join('ɵ');\n    }\n    /**\n     * Creates observable for providing specified product data for the scope\n     *\n     * @param productCode\n     * @param scope\n     */\n    getProductForScope(productCode, scope) {\n      const shouldLoad$ = this.store.pipe(select(getSelectedProductStateFactory(productCode, scope)), map(productState => !productState.loading && !productState.success && !productState.error), distinctUntilChanged(), filter(x => x));\n      const isLoading$ = this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));\n      const productLoadLogic$ = merge(shouldLoad$, ...this.getProductReloadTriggers(productCode, scope)).pipe(debounceTime(0), withLatestFrom(isLoading$), tap(([, isLoading]) => {\n        if (!isLoading) {\n          this.store.dispatch(new LoadProduct(productCode, scope));\n        }\n      }));\n      const productData$ = this.store.pipe(select(getSelectedProductFactory(productCode, scope)));\n      return using(() => productLoadLogic$.subscribe(), () => productData$).pipe(shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n    }\n    /**\n     * Returns reload triggers for product per scope\n     *\n     * @param productCode\n     * @param scope\n     */\n    getProductReloadTriggers(productCode, scope) {\n      const triggers = [];\n      // max age trigger add\n      const maxAge = this.loadingScopes.getMaxAge('product', scope);\n      if (maxAge && isPlatformBrowser(this.platformId)) {\n        // we want to grab load product success and load product fail for this product and scope\n        const loadFinish$ = this.actions$.pipe(filter(action => (action.type === LOAD_PRODUCT_SUCCESS || action.type === LOAD_PRODUCT_FAIL) && action.meta.entityId === productCode && action.meta.scope === scope));\n        const loadStart$ = this.actions$.pipe(ofType(LOAD_PRODUCT), filter(action => action.payload === productCode && action.meta.scope === scope));\n        triggers.push(this.getMaxAgeTrigger(loadStart$, loadFinish$, maxAge));\n      }\n      const reloadTriggers$ = this.loadingScopes.getReloadTriggers('product', scope).map(this.eventService.get);\n      return triggers.concat(reloadTriggers$);\n    }\n    /**\n     * Generic method that returns stream triggering reload by maxAge\n     *\n     * Could be refactored to separate service in future to use in other\n     * max age reload implementations\n     *\n     * @param loadStart$ Stream that emits on load start\n     * @param loadFinish$ Stream that emits on load finish\n     * @param maxAge max age\n     */\n    getMaxAgeTrigger(loadStart$, loadFinish$, maxAge, scheduler) {\n      let timestamp = 0;\n      const now = () => scheduler ? scheduler.now() : Date.now();\n      const timestamp$ = loadFinish$.pipe(tap(() => timestamp = now()));\n      const shouldReload$ = defer(() => {\n        const age = now() - timestamp;\n        const timestampRefresh$ = timestamp$.pipe(delay(maxAge, scheduler), mapTo(true), withdrawOn(loadStart$));\n        if (age > maxAge) {\n          // we should emit first value immediately\n          return merge(of(true), timestampRefresh$);\n        } else if (age === 0) {\n          // edge case, we should emit max age timeout after next load success\n          // could happen with artificial schedulers\n          return timestampRefresh$;\n        } else {\n          // we should emit first value when age will expire\n          return merge(of(true).pipe(delay(maxAge - age, scheduler)), timestampRefresh$);\n        }\n      });\n      return shouldReload$;\n    }\n  }\n  ProductLoadingService.ɵfac = function ProductLoadingService_Factory(t) {\n    return new (t || ProductLoadingService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(LoadingScopesService), i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(EventService));\n  };\n  ProductLoadingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductLoadingService,\n    factory: ProductLoadingService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductLoadingService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductService = /*#__PURE__*/(() => {\n  class ProductService {\n    constructor(store, productLoading) {\n      this.store = store;\n      this.productLoading = productLoading;\n    }\n    /**\n     * Returns the product observable. The product will be loaded\n     * whenever there's no value observed.\n     *\n     * The underlying product loader ensures that the product is\n     * only loaded once, even in case of parallel observers.\n     *\n     * You should provide product data scope you are interested in to not load all\n     * the data if not needed. You can provide more than one scope.\n     *\n     * @param productCode Product code to load\n     * @param scopes Scope or scopes of the product data\n     */\n    get(productCode, scopes = DEFAULT_SCOPE) {\n      return productCode ? this.productLoading.get(productCode, [].concat(scopes)) : of(undefined);\n    }\n    /**\n     * Returns boolean observable for product's loading state\n     */\n    isLoading(productCode, scope = '') {\n      return this.store.pipe(select(getSelectedProductLoadingFactory(productCode, scope)));\n    }\n    /**\n     * Returns boolean observable for product's load success state\n     */\n    isSuccess(productCode, scope = '') {\n      return this.store.pipe(select(getSelectedProductSuccessFactory(productCode, scope)));\n    }\n    /**\n     * Returns boolean observable for product's load error state\n     */\n    hasError(productCode, scope = '') {\n      return this.store.pipe(select(getSelectedProductErrorFactory(productCode, scope)));\n    }\n  }\n  ProductService.ɵfac = function ProductService_Factory(t) {\n    return new (t || ProductService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(ProductLoadingService));\n  };\n  ProductService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductService,\n    factory: ProductService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SearchboxService = /*#__PURE__*/(() => {\n  class SearchboxService extends ProductSearchService {\n    /**\n     * dispatch the search for the search box\n     */\n    search(query, searchConfig) {\n      this.store.dispatch(new SearchProducts({\n        queryText: query,\n        searchConfig: searchConfig\n      }, true));\n    }\n    getResults() {\n      return this.store.pipe(select(getAuxSearchResults));\n    }\n    /**\n     * clears the products and suggestions\n     */\n    clearResults() {\n      this.store.dispatch(new ClearProductSearchResult({\n        clearSearchboxResults: true\n      }));\n    }\n    getSuggestionResults() {\n      return this.store.pipe(select(getProductSuggestions));\n    }\n    searchSuggestions(query, searchConfig) {\n      this.store.dispatch(new GetProductSuggestions({\n        term: query,\n        searchConfig: searchConfig\n      }));\n    }\n  }\n  SearchboxService.ɵfac = /* @__PURE__ */function () {\n    let ɵSearchboxService_BaseFactory;\n    return function SearchboxService_Factory(t) {\n      return (ɵSearchboxService_BaseFactory || (ɵSearchboxService_BaseFactory = i0.ɵɵgetInheritedFactory(SearchboxService)))(t || SearchboxService);\n    };\n  }();\n  SearchboxService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SearchboxService,\n    factory: SearchboxService.ɵfac,\n    providedIn: 'root'\n  });\n  return SearchboxService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves the page data for the Product Listing Page.\n *\n * The page title, and breadcrumbs are resolved in this implementation only.\n */\nlet CategoryPageMetaResolver = /*#__PURE__*/(() => {\n  class CategoryPageMetaResolver extends PageMetaResolver {\n    constructor(productSearchService, cms, translation, basePageMetaResolver) {\n      super();\n      this.productSearchService = productSearchService;\n      this.cms = cms;\n      this.translation = translation;\n      this.basePageMetaResolver = basePageMetaResolver;\n      // reusable observable for search page data\n      this.searchPage$ = this.cms.getCurrentPage().pipe(filter(page => Boolean(page)), switchMap(page =>\n      // only the existence of a plp component tells us if products\n      // are rendered or if this is an ordinary content page\n      this.hasProductListComponent(page) ? this.productSearchService.getResults().pipe(filter(result => Boolean(result))) : of(page)));\n      this.pageType = PageType.CATEGORY_PAGE;\n    }\n    resolveTitle() {\n      return this.searchPage$.pipe(filter(page => !!page.pagination), switchMap(p => {\n        var _a, _b;\n        return this.translation.translate('pageMetaResolver.category.title', {\n          count: (_a = p.pagination) === null || _a === void 0 ? void 0 : _a.totalResults,\n          query: ((_b = p.breadcrumbs) === null || _b === void 0 ? void 0 : _b.length) ? p.breadcrumbs[0].facetValueName : undefined\n        });\n      }));\n    }\n    resolveBreadcrumbs() {\n      return combineLatest([this.searchPage$.pipe(), this.translation.translate('common.home')]).pipe(map(([page, label]) => page.breadcrumbs ? this.resolveBreadcrumbData(page, label) : []));\n    }\n    resolveBreadcrumbData(page, label) {\n      var _a;\n      const breadcrumbs = [];\n      breadcrumbs.push({\n        label: label,\n        link: '/'\n      });\n      for (const br of (_a = page.breadcrumbs) !== null && _a !== void 0 ? _a : []) {\n        if (br.facetValueName) {\n          if (br.facetCode === 'category' || br.facetCode === 'allCategories') {\n            breadcrumbs.push({\n              label: br.facetValueName,\n              link: `/c/${br.facetValueCode}`\n            });\n          }\n          if (br.facetCode === 'brand') {\n            breadcrumbs.push({\n              label: br.facetValueName,\n              link: `/Brands/${br.facetValueName}/c/${br.facetValueCode}`\n            });\n          }\n        }\n      }\n      return breadcrumbs;\n    }\n    hasProductListComponent(page) {\n      return !!Object.keys(page.slots || {}).find(key => {\n        var _a, _b;\n        return !!((_b = (_a = page.slots) === null || _a === void 0 ? void 0 : _a[key].components) === null || _b === void 0 ? void 0 : _b.find(comp => comp.typeCode === 'CMSProductListComponent' || comp.typeCode === 'ProductGridComponent'));\n      });\n    }\n    resolveRobots() {\n      return this.basePageMetaResolver.resolveRobots();\n    }\n    /**\n     * Resolves the canonical url for the category listing page.\n     *\n     * The default options will be used to resolve the url, which means that\n     * all query parameters are removed and https and www are added explicitly.\n     */\n    resolveCanonicalUrl() {\n      return this.basePageMetaResolver.resolveCanonicalUrl();\n    }\n  }\n  CategoryPageMetaResolver.ɵfac = function CategoryPageMetaResolver_Factory(t) {\n    return new (t || CategoryPageMetaResolver)(i0.ɵɵinject(ProductSearchService), i0.ɵɵinject(CmsService), i0.ɵɵinject(TranslationService), i0.ɵɵinject(BasePageMetaResolver));\n  };\n  CategoryPageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CategoryPageMetaResolver,\n    factory: CategoryPageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return CategoryPageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves page meta data for the search result page, in case it's used\n * to query coupons. This is done by adding a `couponcode` query parameter\n * to the search page route.\n *\n * The page resolves an alternative page title and breadcrumb.\n */\nlet CouponSearchPageResolver = /*#__PURE__*/(() => {\n  class CouponSearchPageResolver extends PageMetaResolver {\n    constructor(productSearchService, translation, authService, route, semanticPathService) {\n      super();\n      this.productSearchService = productSearchService;\n      this.translation = translation;\n      this.authService = authService;\n      this.route = route;\n      this.semanticPathService = semanticPathService;\n      this.total$ = this.productSearchService.getResults().pipe(filter(data => !!(data === null || data === void 0 ? void 0 : data.pagination)), map(results => results.pagination.totalResults));\n      this.pageType = PageType.CONTENT_PAGE;\n      this.pageTemplate = 'SearchResultsListPageTemplate';\n    }\n    resolveBreadcrumbs() {\n      return combineLatest([this.translation.translate('common.home'), this.translation.translate('myCoupons.myCoupons'), this.authService.isUserLoggedIn()]).pipe(map(([homeLabel, couponLabel, isLoggedIn]) => {\n        const breadcrumbs = [];\n        breadcrumbs.push({\n          label: homeLabel,\n          link: '/'\n        });\n        if (isLoggedIn) {\n          breadcrumbs.push({\n            label: couponLabel,\n            link: this.semanticPathService.transform({\n              cxRoute: 'coupons'\n            })\n          });\n        }\n        return breadcrumbs;\n      }));\n    }\n    resolveTitle() {\n      return this.total$.pipe(switchMap(total => this.translation.translate('pageMetaResolver.search.findProductTitle', {\n        count: total,\n        coupon: this.couponCode\n      })));\n    }\n    getScore(page) {\n      return super.getScore(page) + (this.couponCode ? 1 : -1);\n    }\n    get couponCode() {\n      var _a, _b;\n      return (_b = (_a = this.route.snapshot) === null || _a === void 0 ? void 0 : _a.queryParams) === null || _b === void 0 ? void 0 : _b.couponcode;\n    }\n  }\n  CouponSearchPageResolver.ɵfac = function CouponSearchPageResolver_Factory(t) {\n    return new (t || CouponSearchPageResolver)(i0.ɵɵinject(ProductSearchService), i0.ɵɵinject(TranslationService), i0.ɵɵinject(AuthService), i0.ɵɵinject(i1$1.ActivatedRoute), i0.ɵɵinject(SemanticPathService));\n  };\n  CouponSearchPageResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CouponSearchPageResolver,\n    factory: CouponSearchPageResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return CouponSearchPageResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves the page data for the Product Detail Page\n * based on the `PageType.PRODUCT_PAGE`.\n *\n * The page title, heading, description, breadcrumbs and\n * first GALLERY image are resolved if available in the data.\n */\nlet ProductPageMetaResolver = /*#__PURE__*/(() => {\n  class ProductPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productService, translation, basePageMetaResolver, pageLinkService) {\n      super();\n      this.routingService = routingService;\n      this.productService = productService;\n      this.translation = translation;\n      this.basePageMetaResolver = basePageMetaResolver;\n      this.pageLinkService = pageLinkService;\n      // reusable observable for product data based on the current page\n      this.product$ = this.routingService.getRouterState().pipe(map(state => state.state.params['productCode']), filter(code => !!code), switchMap(code => this.productService.get(code, \"details\" /* DETAILS */)), filter(p => Boolean(p)));\n      this.pageType = PageType.PRODUCT_PAGE;\n    }\n    /**\n     * Resolves the page heading for the Product Detail Page.\n     * The page heading is used in the UI (`<h1>`), where as the page\n     * title is used by the browser and crawlers.\n     */\n    resolveHeading() {\n      return this.product$.pipe(switchMap(p => this.translation.translate('pageMetaResolver.product.heading', {\n        heading: p.name\n      })));\n    }\n    /**\n     * Resolves the page title for the Product Detail Page. The page title\n     * is resolved with the product name, the first category and the manufacturer.\n     * The page title used by the browser (history, tabs) and crawlers.\n     */\n    resolveTitle() {\n      return this.product$.pipe(switchMap(product => {\n        let title = product.name;\n        title += this.resolveFirstCategory(product);\n        title += this.resolveManufacturer(product);\n        return this.translation.translate('pageMetaResolver.product.title', {\n          title: title\n        });\n      }));\n    }\n    /**\n     * Resolves the page description for the Product Detail Page. The description\n     * is based on the `product.summary`.\n     */\n    resolveDescription() {\n      return this.product$.pipe(switchMap(product => this.translation.translate('pageMetaResolver.product.description', {\n        description: product.summary\n      })));\n    }\n    /**\n     * Resolves breadcrumbs for the Product Detail Page. The breadcrumbs are driven by\n     * a static home page crumb and a crumb for each category.\n     */\n    resolveBreadcrumbs() {\n      return combineLatest([this.product$.pipe(), this.translation.translate('common.home')]).pipe(map(([product, label]) => {\n        const breadcrumbs = [];\n        breadcrumbs.push({\n          label,\n          link: '/'\n        });\n        for (const {\n          name,\n          code,\n          url\n        } of product.categories || []) {\n          breadcrumbs.push({\n            label: name || code,\n            link: url\n          });\n        }\n        return breadcrumbs;\n      }));\n    }\n    /**\n     * Resolves the main page image for the Product Detail Page. The product image\n     * is based on the PRIMARY product image. The zoom format is used by default.\n     */\n    resolveImage() {\n      return this.product$.pipe(map(product => {\n        var _a, _b, _c, _d;\n        return (_d = (_c = (_b = (_a = product.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) === null || _b === void 0 ? void 0 : _b.zoom) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : null;\n      }));\n    }\n    resolveFirstCategory(product) {\n      var _a;\n      const firstCategory = (_a = product === null || product === void 0 ? void 0 : product.categories) === null || _a === void 0 ? void 0 : _a[0];\n      return firstCategory ? ` | ${firstCategory.name || firstCategory.code}` : '';\n    }\n    resolveManufacturer(product) {\n      return product.manufacturer ? ` | ${product.manufacturer}` : '';\n    }\n    resolveRobots() {\n      return this.basePageMetaResolver.resolveRobots();\n    }\n    /**\n     * Resolves the canonical url for the product page using the default canonical url\n     * configuration.\n     *\n     * In case of a variant product, the baseProduct code is used to resolve the url. It's important\n     * to know that this has a few limitations:\n     * - We're not always able to get the super baseProduct, in case of multi-level variants.\n     *   OCC only exposes the direct baseProduct, which might still not resolve in the correct\n     *   canonical URL. This is business driven and subject to change in a customization.\n     * - The url resolved for the variant doesn't contain any content other then the product code.\n     *   This means that we do not provide any product data to resolve pretty URLs (for example\n     *   the product title).\n     */\n    resolveCanonicalUrl() {\n      return this.product$.pipe(switchMap(product => this.findBaseProduct(product)), map(product => {\n        const url = this.routingService.getFullUrl({\n          cxRoute: 'product',\n          params: product\n        });\n        return this.pageLinkService.getCanonicalUrl({}, url);\n      }));\n    }\n    /**\n     * Resolves the base product whenever the given product is a variant product.\n     *\n     * Since product variants can be multi-layered, we recursively try to find the base product\n     * this might be too opinionated for your business though.\n     */\n    findBaseProduct(product) {\n      if (product === null || product === void 0 ? void 0 : product.baseProduct) {\n        return this.productService.get(product.baseProduct, \"list\" /* LIST */).pipe(filter(product => Boolean(product)), switchMap(baseProduct => this.findBaseProduct(baseProduct)));\n      }\n      return of(product);\n    }\n  }\n  ProductPageMetaResolver.ɵfac = function ProductPageMetaResolver_Factory(t) {\n    return new (t || ProductPageMetaResolver)(i0.ɵɵinject(RoutingService), i0.ɵɵinject(ProductService), i0.ɵɵinject(TranslationService), i0.ɵɵinject(BasePageMetaResolver), i0.ɵɵinject(PageLinkService));\n  };\n  ProductPageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductPageMetaResolver,\n    factory: ProductPageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductPageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Resolves the page data for the Search Result Page based on the\n * `PageType.CATEGORY_PAGE` and the `SearchResultsListPageTemplate` template.\n *\n * Only the page title is resolved in the standard implementation.\n */\nlet SearchPageMetaResolver = /*#__PURE__*/(() => {\n  class SearchPageMetaResolver extends PageMetaResolver {\n    constructor(routingService, productSearchService, translation, basePageMetaResolver) {\n      super();\n      this.routingService = routingService;\n      this.productSearchService = productSearchService;\n      this.translation = translation;\n      this.basePageMetaResolver = basePageMetaResolver;\n      this.total$ = this.productSearchService.getResults().pipe(filter(data => !!(data === null || data === void 0 ? void 0 : data.pagination)), map(results => {\n        var _a;\n        return (_a = results.pagination) === null || _a === void 0 ? void 0 : _a.totalResults;\n      }));\n      this.query$ = this.routingService.getRouterState().pipe(map(state => state.state.params['query']));\n      this.pageType = PageType.CONTENT_PAGE;\n      this.pageTemplate = 'SearchResultsListPageTemplate';\n    }\n    resolveTitle() {\n      const sources = [this.total$, this.query$];\n      return combineLatest(sources).pipe(switchMap(([count, query]) => this.translation.translate('pageMetaResolver.search.default_title').pipe(mergeMap(defaultQuery => this.translation.translate('pageMetaResolver.search.title', {\n        count,\n        query: query || defaultQuery\n      })))));\n    }\n    resolveRobots() {\n      return this.basePageMetaResolver.resolveRobots();\n    }\n    /**\n     * Resolves the canonical page for the search page.\n     *\n     * The default options will be used to resolve the url, which means that\n     * the all query parameters are removed and https and www are added explicitly.\n     */\n    resolveCanonicalUrl() {\n      return this.basePageMetaResolver.resolveCanonicalUrl();\n    }\n  }\n  SearchPageMetaResolver.ɵfac = function SearchPageMetaResolver_Factory(t) {\n    return new (t || SearchPageMetaResolver)(i0.ɵɵinject(RoutingService), i0.ɵɵinject(ProductSearchService), i0.ɵɵinject(TranslationService), i0.ɵɵinject(BasePageMetaResolver));\n  };\n  SearchPageMetaResolver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SearchPageMetaResolver,\n    factory: SearchPageMetaResolver.ɵfac,\n    providedIn: 'root'\n  });\n  return SearchPageMetaResolver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction productStoreConfigFactory() {\n  // if we want to reuse PRODUCT_FEATURE const in config, we have to use factory instead of plain object\n  const config = {\n    state: {\n      ssrTransfer: {\n        keys: {\n          [PRODUCT_FEATURE]: StateTransferType.TRANSFER_STATE\n        }\n      }\n    }\n  };\n  return config;\n}\nlet ProductStoreModule = /*#__PURE__*/(() => {\n  class ProductStoreModule {}\n  ProductStoreModule.ɵfac = function ProductStoreModule_Factory(t) {\n    return new (t || ProductStoreModule)();\n  };\n  ProductStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProductStoreModule\n  });\n  ProductStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfigFactory(productStoreConfigFactory), reducerProvider$1],\n    imports: [[CommonModule, StoreModule.forFeature(PRODUCT_FEATURE, reducerToken$1, {\n      metaReducers: metaReducers$1\n    }), EffectsModule.forFeature(effects)]]\n  });\n  return ProductStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst pageTitleResolvers = [{\n  provide: PageMetaResolver,\n  useExisting: ProductPageMetaResolver,\n  multi: true\n}, {\n  provide: PageMetaResolver,\n  useExisting: CategoryPageMetaResolver,\n  multi: true\n}, {\n  provide: PageMetaResolver,\n  useExisting: SearchPageMetaResolver,\n  multi: true\n}, {\n  provide: PageMetaResolver,\n  useExisting: CouponSearchPageResolver,\n  multi: true\n}];\nlet ProductModule = /*#__PURE__*/(() => {\n  class ProductModule {\n    static forRoot() {\n      return {\n        ngModule: ProductModule,\n        providers: [...pageTitleResolvers]\n      };\n    }\n  }\n  ProductModule.ɵfac = function ProductModule_Factory(t) {\n    return new (t || ProductModule)();\n  };\n  ProductModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ProductModule\n  });\n  ProductModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[ProductStoreModule, ProductEventModule]]\n  });\n  return ProductModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserAddressConnector = /*#__PURE__*/(() => {\n  class UserAddressConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getAll(userId) {\n      return this.adapter.loadAll(userId);\n    }\n    add(userId, address) {\n      return this.adapter.add(userId, address);\n    }\n    update(userId, addressId, address) {\n      return this.adapter.update(userId, addressId, address);\n    }\n    verify(userId, address) {\n      return this.adapter.verify(userId, address);\n    }\n    delete(userId, addressId) {\n      return this.adapter.delete(userId, addressId);\n    }\n  }\n  UserAddressConnector.ɵfac = function UserAddressConnector_Factory(t) {\n    return new (t || UserAddressConnector)(i0.ɵɵinject(UserAddressAdapter));\n  };\n  UserAddressConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserAddressConnector,\n    factory: UserAddressConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserAddressConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserConsentConnector = /*#__PURE__*/(() => {\n  class UserConsentConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    loadConsents(userId) {\n      return this.adapter.loadConsents(userId);\n    }\n    giveConsent(userId, consentTemplateId, consentTemplateVersion) {\n      return this.adapter.giveConsent(userId, consentTemplateId, consentTemplateVersion);\n    }\n    withdrawConsent(userId, consentCode) {\n      return this.adapter.withdrawConsent(userId, consentCode);\n    }\n  }\n  UserConsentConnector.ɵfac = function UserConsentConnector_Factory(t) {\n    return new (t || UserConsentConnector)(i0.ɵɵinject(UserConsentAdapter));\n  };\n  UserConsentConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserConsentConnector,\n    factory: UserConsentConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserConsentConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserCostCenterConnector = /*#__PURE__*/(() => {\n  class UserCostCenterConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getActiveList(userId) {\n      return this.adapter.loadActiveList(userId);\n    }\n  }\n  UserCostCenterConnector.ɵfac = function UserCostCenterConnector_Factory(t) {\n    return new (t || UserCostCenterConnector)(i0.ɵɵinject(UserCostCenterAdapter));\n  };\n  UserCostCenterConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserCostCenterConnector,\n    factory: UserCostCenterConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserCostCenterConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CustomerCouponConnector = /*#__PURE__*/(() => {\n  class CustomerCouponConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getCustomerCoupons(userId, pageSize, currentPage, sort) {\n      return this.adapter.getCustomerCoupons(userId, pageSize, currentPage, sort);\n    }\n    turnOnNotification(userId, couponCode) {\n      return this.adapter.turnOnNotification(userId, couponCode);\n    }\n    turnOffNotification(userId, couponCode) {\n      return this.adapter.turnOffNotification(userId, couponCode);\n    }\n    claimCustomerCoupon(userId, couponCode) {\n      return this.adapter.claimCustomerCoupon(userId, couponCode);\n    }\n  }\n  CustomerCouponConnector.ɵfac = function CustomerCouponConnector_Factory(t) {\n    return new (t || CustomerCouponConnector)(i0.ɵɵinject(CustomerCouponAdapter));\n  };\n  CustomerCouponConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CustomerCouponConnector,\n    factory: CustomerCouponConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return CustomerCouponConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserInterestsConnector = /*#__PURE__*/(() => {\n  class UserInterestsConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getInterests(userId, pageSize, currentPage, sort, productCode, notificationType) {\n      return this.adapter.getInterests(userId, pageSize, currentPage, sort, productCode, notificationType);\n    }\n    removeInterest(userId, item) {\n      return this.adapter.removeInterest(userId, item);\n    }\n    addInterest(userId, productCode, notificationType) {\n      return this.adapter.addInterest(userId, productCode, notificationType);\n    }\n  }\n  UserInterestsConnector.ɵfac = function UserInterestsConnector_Factory(t) {\n    return new (t || UserInterestsConnector)(i0.ɵɵinject(UserInterestsAdapter));\n  };\n  UserInterestsConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserInterestsConnector,\n    factory: UserInterestsConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserInterestsConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use OrderConnector in @spartacus/order/core\n */\nlet UserOrderConnector = /*#__PURE__*/(() => {\n  class UserOrderConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    get(userId, orderCode) {\n      return this.adapter.load(userId, orderCode);\n    }\n    getHistory(userId, pageSize, currentPage, sort) {\n      return this.adapter.loadHistory(userId, pageSize, currentPage, sort);\n    }\n    getConsignmentTracking(orderCode, consignmentCode, userId) {\n      return this.adapter.getConsignmentTracking(orderCode, consignmentCode, userId);\n    }\n    cancel(userId, orderCode, cancelRequestInput) {\n      return this.adapter.cancel(userId, orderCode, cancelRequestInput);\n    }\n    return(userId, returnRequestInput) {\n      return this.adapter.createReturnRequest(userId, returnRequestInput);\n    }\n    getReturnRequestDetail(userId, returnRequestCode) {\n      return this.adapter.loadReturnRequestDetail(userId, returnRequestCode);\n    }\n    getReturnRequestList(userId, pageSize, currentPage, sort) {\n      return this.adapter.loadReturnRequestList(userId, pageSize, currentPage, sort);\n    }\n    cancelReturnRequest(userId, returnRequestCode, returnRequestModification) {\n      return this.adapter.cancelReturnRequest(userId, returnRequestCode, returnRequestModification);\n    }\n  }\n  UserOrderConnector.ɵfac = function UserOrderConnector_Factory(t) {\n    return new (t || UserOrderConnector)(i0.ɵɵinject(UserOrderAdapter));\n  };\n  UserOrderConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserOrderConnector,\n    factory: UserOrderConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserOrderConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserPaymentConnector = /*#__PURE__*/(() => {\n  class UserPaymentConnector {\n    constructor(adapter) {\n      this.adapter = adapter;\n    }\n    getAll(userId) {\n      return this.adapter.loadAll(userId);\n    }\n    delete(userId, paymentMethodID) {\n      return this.adapter.delete(userId, paymentMethodID);\n    }\n    setDefault(userId, paymentMethodID) {\n      return this.adapter.setDefault(userId, paymentMethodID);\n    }\n  }\n  UserPaymentConnector.ɵfac = function UserPaymentConnector_Factory(t) {\n    return new (t || UserPaymentConnector)(i0.ɵɵinject(UserPaymentAdapter));\n  };\n  UserPaymentConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserPaymentConnector,\n    factory: UserPaymentConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return UserPaymentConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass UserAddressEvent extends CxEvent {}\nlet UpdateUserAddressEvent = /*#__PURE__*/(() => {\n  class UpdateUserAddressEvent extends UserAddressEvent {}\n  UpdateUserAddressEvent.type = 'UpdateUserAddressEvent';\n  return UpdateUserAddressEvent;\n})();\nlet DeleteUserAddressEvent = /*#__PURE__*/(() => {\n  class DeleteUserAddressEvent extends UserAddressEvent {}\n  DeleteUserAddressEvent.type = 'DeleteUserAddressEvent';\n  return DeleteUserAddressEvent;\n})();\nlet AddUserAddressEvent = /*#__PURE__*/(() => {\n  class AddUserAddressEvent extends UserAddressEvent {}\n  AddUserAddressEvent.type = 'AddUserAddressEvent';\n  return AddUserAddressEvent;\n})();\nlet UserEventBuilder = /*#__PURE__*/(() => {\n  class UserEventBuilder {\n    constructor(stateEventService) {\n      this.stateEventService = stateEventService;\n      this.register();\n    }\n    /**\n     * Registers user events\n     */\n    register() {\n      this.updateUserAddressEvent();\n      this.deleteUserAddressEvent();\n      this.addUserAddressEvent();\n    }\n    /**\n     * Register an address successfully updated event\n     */\n    updateUserAddressEvent() {\n      this.stateEventService.register({\n        action: UPDATE_USER_ADDRESS,\n        event: UpdateUserAddressEvent\n      });\n    }\n    addUserAddressEvent() {\n      this.stateEventService.register({\n        action: ADD_USER_ADDRESS,\n        event: AddUserAddressEvent\n      });\n    }\n    deleteUserAddressEvent() {\n      this.stateEventService.register({\n        action: DELETE_USER_ADDRESS,\n        event: DeleteUserAddressEvent\n      });\n    }\n  }\n  UserEventBuilder.ɵfac = function UserEventBuilder_Factory(t) {\n    return new (t || UserEventBuilder)(i0.ɵɵinject(StateEventService));\n  };\n  UserEventBuilder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserEventBuilder,\n    factory: UserEventBuilder.ɵfac\n  });\n  return UserEventBuilder;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserEventModule = /*#__PURE__*/(() => {\n  class UserEventModule {\n    constructor(_userEventBuilder) {}\n  }\n  UserEventModule.ɵfac = function UserEventModule_Factory(t) {\n    return new (t || UserEventModule)(i0.ɵɵinject(UserEventBuilder));\n  };\n  UserEventModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserEventModule\n  });\n  UserEventModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return UserEventModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Unified facade for both anonymous and registered user consents.\n */\nlet ConsentService = /*#__PURE__*/(() => {\n  class ConsentService {\n    constructor(anonymousConsentsService, userConsentService) {\n      this.anonymousConsentsService = anonymousConsentsService;\n      this.userConsentService = userConsentService;\n    }\n    /**\n     * Returns either anonymous consent or registered consent as they are emmited.\n     * @param templateCode for which to return either anonymous or registered consent.\n     */\n    getConsent(templateCode) {\n      return merge(this.userConsentService.getConsent(templateCode), this.anonymousConsentsService.getConsent(templateCode));\n    }\n    /**\n     * Checks if the `templateId`'s template has a given consent.\n     * The method returns `false` if the consent doesn't exist or if it's withdrawn. Otherwise, `true` is returned.\n     *\n     * @param templateId of a template which's consent should be checked\n     */\n    checkConsentGivenByTemplateId(templateId) {\n      return this.getConsent(templateId).pipe(map(consent => {\n        if (!consent) {\n          return false;\n        }\n        return this.isAnonymousConsentType(consent) ? this.anonymousConsentsService.isConsentGiven(consent) : this.userConsentService.isConsentGiven(consent);\n      }), distinctUntilChanged());\n    }\n    /**\n     * Checks if the `templateId`'s template has a withdrawn consent.\n     * The method returns `true` if the consent doesn't exist or if it's withdrawn. Otherwise, `false` is returned.\n     *\n     * @param templateId of a template which's consent should be checked\n     */\n    checkConsentWithdrawnByTemplateId(templateId) {\n      return this.getConsent(templateId).pipe(map(consent => {\n        if (!consent) {\n          return true;\n        }\n        return this.isAnonymousConsentType(consent) ? this.anonymousConsentsService.isConsentWithdrawn(consent) : this.userConsentService.isConsentWithdrawn(consent);\n      }), distinctUntilChanged());\n    }\n    /**\n     *\n     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentGiven(consent)` or `this.userConsentService.isConsentGiven`\n     *\n     * @param consent a consent to check\n     */\n    isConsentGiven(consent) {\n      return this.isAnonymousConsentType(consent) ? this.anonymousConsentsService.isConsentGiven(consent) : this.userConsentService.isConsentGiven(consent);\n    }\n    /**\n     *\n     * Checks the provided `consent`'s type and delegates to an appropriate method - `anonymousConsentsService.isConsentWithdrawn(consent)` or `this.userConsentService.isConsentWithdrawn`\n     *\n     * @param consent a consent to check\n     */\n    isConsentWithdrawn(consent) {\n      return this.isAnonymousConsentType(consent) ? this.anonymousConsentsService.isConsentWithdrawn(consent) : this.userConsentService.isConsentWithdrawn(consent);\n    }\n    /**\n     * Returns `true` if the provided consent is of type `AnonymousConsent`. Otherwise, `false` is returned.\n     */\n    isAnonymousConsentType(consent) {\n      if (!consent) {\n        return false;\n      }\n      return consent.templateCode !== undefined;\n    }\n    /**\n     * Returns `true` if the provided consent is of type `Consent`. Otherwise, `false` is returned.\n     */\n    isConsentType(consent) {\n      if (!consent) {\n        return false;\n      }\n      return consent.code !== undefined;\n    }\n  }\n  ConsentService.ɵfac = function ConsentService_Factory(t) {\n    return new (t || ConsentService)(i0.ɵɵinject(AnonymousConsentsService), i0.ɵɵinject(UserConsentService));\n  };\n  ConsentService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConsentService,\n    factory: ConsentService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConsentService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CustomerCouponService = /*#__PURE__*/(() => {\n  class CustomerCouponService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Retrieves customer's coupons\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadCustomerCoupons(pageSize, currentPage, sort) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadCustomerCoupons({\n          userId,\n          pageSize: pageSize,\n          currentPage: currentPage,\n          sort: sort\n        }));\n      });\n    }\n    /**\n     * Returns customer coupon search result\n     * @param pageSize page size\n     */\n    getCustomerCoupons(pageSize) {\n      return combineLatest([this.store.pipe(select(getCustomerCouponsState)), this.getClaimCustomerCouponResultLoading()]).pipe(filter(([, loading]) => !loading), tap(([customerCouponsState]) => {\n        const attemptedLoad = customerCouponsState.loading || customerCouponsState.success || customerCouponsState.error;\n        if (!attemptedLoad) {\n          this.loadCustomerCoupons(pageSize);\n        }\n      }), map(([customerCouponsState]) => customerCouponsState.value));\n    }\n    /**\n     * Returns a loaded flag for customer coupons\n     */\n    getCustomerCouponsLoaded() {\n      return this.store.pipe(select(getCustomerCouponsLoaded));\n    }\n    /**\n     * Returns a loading flag for customer coupons\n     */\n    getCustomerCouponsLoading() {\n      return this.store.pipe(select(getCustomerCouponsLoading));\n    }\n    /**\n     * Subscribe a CustomerCoupon Notification\n     * @param couponCode a customer coupon code\n     */\n    subscribeCustomerCoupon(couponCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new SubscribeCustomerCoupon({\n          userId,\n          couponCode: couponCode\n        }));\n      });\n    }\n    /**\n     * Returns the subscribe customer coupon notification process loading flag\n     */\n    getSubscribeCustomerCouponResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the subscribe customer coupon notification process success flag\n     */\n    getSubscribeCustomerCouponResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the subscribe customer coupon notification process error flag\n     */\n    getSubscribeCustomerCouponResultError() {\n      return this.store.pipe(select(getProcessErrorFactory(SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Unsubscribe a CustomerCoupon Notification\n     * @param couponCode a customer coupon code\n     */\n    unsubscribeCustomerCoupon(couponCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new UnsubscribeCustomerCoupon({\n          userId,\n          couponCode: couponCode\n        }));\n      });\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process loading flag\n     */\n    getUnsubscribeCustomerCouponResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process success flag\n     */\n    getUnsubscribeCustomerCouponResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the unsubscribe customer coupon notification process error flag\n     */\n    getUnsubscribeCustomerCouponResultError() {\n      return this.store.pipe(select(getProcessErrorFactory(UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Claim a CustomerCoupon\n     * @param couponCode a customer coupon code\n     */\n    claimCustomerCoupon(couponCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new ClaimCustomerCoupon({\n          userId,\n          couponCode\n        }));\n      });\n    }\n    /**\n     * Returns the claim customer coupon notification process success flag\n     */\n    getClaimCustomerCouponResultSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n    /**\n     * Returns the claim customer coupon notification process loading flag\n     */\n    getClaimCustomerCouponResultLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(CLAIM_CUSTOMER_COUPON_PROCESS_ID)));\n    }\n  }\n  CustomerCouponService.ɵfac = function CustomerCouponService_Factory(t) {\n    return new (t || CustomerCouponService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  CustomerCouponService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CustomerCouponService,\n    factory: CustomerCouponService.ɵfac,\n    providedIn: 'root'\n  });\n  return CustomerCouponService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use OrderReturnRequestFacade in @spartacus/order/root instead\n * TODO: In order lib, processStateStore is added in OrderReturnService's constructor,\n * need to update it in 5.0 migration doc.\n */\nlet OrderReturnRequestService = /*#__PURE__*/(() => {\n  class OrderReturnRequestService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Create order return request\n     * @param orderCode an order code\n     * @param returnRequestInput order return request entry input\n     */\n    createOrderReturnRequest(returnRequestInput) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new CreateOrderReturnRequest({\n          userId,\n          returnRequestInput\n        }));\n      });\n    }\n    /**\n     * Return an order return request\n     */\n    getOrderReturnRequest() {\n      return this.store.pipe(select(getOrderReturnRequest));\n    }\n    /**\n     * Gets order return request list\n     */\n    getOrderReturnRequestList(pageSize) {\n      return this.store.pipe(select(getOrderReturnRequestListState), tap(returnListState => {\n        const attemptedLoad = returnListState.loading || returnListState.success || returnListState.error;\n        if (!attemptedLoad) {\n          this.loadOrderReturnRequestList(pageSize);\n        }\n      }), map(returnListState => returnListState.value));\n    }\n    /**\n     * Loads order return request detail\n     * @param returnRequestCode\n     */\n    loadOrderReturnRequestDetail(returnRequestCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadOrderReturnRequest({\n          userId,\n          returnRequestCode\n        }));\n      });\n    }\n    /**\n     * Loads order return request list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadOrderReturnRequestList(pageSize, currentPage, sort) {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        this.store.dispatch(new LoadOrderReturnRequestList({\n          userId,\n          pageSize,\n          currentPage,\n          sort\n        }));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    /**\n     * Cleaning order return request list\n     */\n    clearOrderReturnRequestList() {\n      this.store.dispatch(new ClearOrderReturnRequestList());\n    }\n    /**\n     * Get the order return request loading flag\n     */\n    getReturnRequestLoading() {\n      return this.store.pipe(select(getOrderReturnRequestLoading));\n    }\n    /**\n     * Get the order return request success flag\n     */\n    getReturnRequestSuccess() {\n      return this.store.pipe(select(getOrderReturnRequestSuccess));\n    }\n    /**\n     * Cleaning order return request details\n     */\n    clearOrderReturnRequestDetail() {\n      this.store.dispatch(new ClearOrderReturnRequest());\n    }\n    /*\n     * Cancel order return request\n     */\n    cancelOrderReturnRequest(returnRequestCode, returnRequestModification) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new CancelOrderReturnRequest({\n          userId,\n          returnRequestCode,\n          returnRequestModification\n        }));\n      });\n    }\n    /**\n     * Returns the cancel return request loading flag\n     */\n    getCancelReturnRequestLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(CANCEL_RETURN_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel return request success flag\n     */\n    getCancelReturnRequestSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(CANCEL_RETURN_PROCESS_ID)));\n    }\n    /**\n     * Resets the cancel return request process flags\n     */\n    resetCancelReturnRequestProcessState() {\n      return this.store.dispatch(new ResetCancelReturnProcess());\n    }\n  }\n  OrderReturnRequestService.ɵfac = function OrderReturnRequestService_Factory(t) {\n    return new (t || OrderReturnRequestService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  OrderReturnRequestService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OrderReturnRequestService,\n    factory: OrderReturnRequestService.ɵfac,\n    providedIn: 'root'\n  });\n  return OrderReturnRequestService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserAddressService = /*#__PURE__*/(() => {\n  class UserAddressService {\n    constructor(store, userIdService, userAddressConnector, command) {\n      this.store = store;\n      this.userIdService = userIdService;\n      this.userAddressConnector = userAddressConnector;\n      this.command = command;\n      this.userAddressVerificationCommand = this.command.create(payload => this.userIdService.takeUserId(false).pipe(switchMap(userId => this.userAddressConnector.verify(userId, payload.address))));\n    }\n    /**\n     * Retrieves user's addresses\n     */\n    loadAddresses() {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadUserAddresses(userId));\n      });\n    }\n    /**\n     * Adds user address\n     * @param address a user address\n     */\n    addUserAddress(address) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new AddUserAddress({\n          userId,\n          address\n        }));\n      });\n    }\n    /**\n     * Sets user address as default\n     * @param addressId a user address ID\n     */\n    setAddressAsDefault(addressId) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new UpdateUserAddress({\n          userId,\n          addressId,\n          address: {\n            defaultAddress: true\n          }\n        }));\n      });\n    }\n    /**\n     * Updates existing user address\n     * @param addressId a user address ID\n     * @param address a user address\n     */\n    updateUserAddress(addressId, address) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new UpdateUserAddress({\n          userId,\n          addressId,\n          address\n        }));\n      });\n    }\n    /**\n     * Deletes existing user address\n     * @param addressId a user address ID\n     */\n    deleteUserAddress(addressId) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new DeleteUserAddress({\n          userId,\n          addressId\n        }));\n      });\n    }\n    /**\n     * Returns addresses\n     */\n    getAddresses() {\n      return this.store.pipe(select(getAddresses));\n    }\n    /**\n     * Returns a loading flag for addresses\n     */\n    getAddressesLoading() {\n      return this.store.pipe(select(getAddressesLoading));\n    }\n    getAddressesLoadedSuccess() {\n      return this.store.pipe(select(getAddressesLoadedSuccess));\n    }\n    /**\n     * Retrieves delivery countries\n     */\n    loadDeliveryCountries() {\n      this.store.dispatch(new LoadDeliveryCountries());\n    }\n    /**\n     * Returns all delivery countries\n     */\n    getDeliveryCountries() {\n      return this.store.pipe(select(getAllDeliveryCountries));\n    }\n    /**\n     * Returns a country based on the provided `isocode`\n     * @param isocode an isocode for a country\n     */\n    getCountry(isocode) {\n      return this.store.pipe(select(countrySelectorFactory(isocode)));\n    }\n    /**\n     * Retrieves regions for specified country by `countryIsoCode`\n     * @param countryIsoCode\n     */\n    loadRegions(countryIsoCode) {\n      this.store.dispatch(new LoadRegions(countryIsoCode));\n    }\n    /**\n     * Clear regions in store - useful when changing country\n     */\n    clearRegions() {\n      this.store.dispatch(new ClearRegions());\n    }\n    /**\n     * Returns all regions\n     */\n    getRegions(countryIsoCode) {\n      return this.store.pipe(select(getRegionsDataAndLoading), map(({\n        regions,\n        country,\n        loading,\n        loaded\n      }) => {\n        if (!countryIsoCode && (loading || loaded)) {\n          this.clearRegions();\n          return [];\n        } else if (loading && !loaded) {\n          // don't interrupt loading\n          return [];\n        } else if (!loading && countryIsoCode !== country && countryIsoCode) {\n          // country changed - clear store and load new regions\n          if (country) {\n            this.clearRegions();\n          }\n          this.loadRegions(countryIsoCode);\n          return [];\n        }\n        return regions;\n      }));\n    }\n    /**\n     * Verifies the address\n     * @param address : the address to be verified\n     */\n    verifyAddress(address) {\n      return this.userAddressVerificationCommand.execute({\n        address\n      });\n    }\n  }\n  UserAddressService.ɵfac = function UserAddressService_Factory(t) {\n    return new (t || UserAddressService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService), i0.ɵɵinject(UserAddressConnector), i0.ɵɵinject(CommandService));\n  };\n  UserAddressService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserAddressService,\n    factory: UserAddressService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserAddressService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserCostCenterService = /*#__PURE__*/(() => {\n  class UserCostCenterService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Load all visible active cost centers for the currently login user\n     */\n    loadActiveCostCenters() {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        this.store.dispatch(new LoadActiveCostCenters(userId));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    getCostCentersState() {\n      return this.store.select(getCostCentersState);\n    }\n    /**\n     * Get all visible active cost centers\n     */\n    getActiveCostCenters() {\n      return this.getCostCentersState().pipe(observeOn(queueScheduler), tap(process => {\n        if (!(process.loading || process.success || process.error)) {\n          this.loadActiveCostCenters();\n        }\n      }), filter(process => process.success || process.error), map(result => result.value));\n    }\n    /**\n     * Get the addresses of the cost center's unit based on cost center id\n     * @param costCenterId cost center id\n     */\n    getCostCenterAddresses(costCenterId) {\n      return this.getActiveCostCenters().pipe(map(costCenters => {\n        const costCenter = costCenters.find(cc => cc.code === costCenterId);\n        if (costCenter && costCenter.unit) {\n          return costCenter.unit.addresses;\n        } else {\n          return [];\n        }\n      }));\n    }\n  }\n  UserCostCenterService.ɵfac = function UserCostCenterService_Factory(t) {\n    return new (t || UserCostCenterService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  UserCostCenterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserCostCenterService,\n    factory: UserCostCenterService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserCostCenterService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserInterestsService = /*#__PURE__*/(() => {\n  class UserInterestsService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Retrieves an product interest list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadProductInterests(pageSize, currentPage, sort, productCode, notificationType) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadProductInterests({\n          userId,\n          pageSize: pageSize,\n          currentPage: currentPage,\n          sort: sort,\n          productCode: productCode,\n          notificationType: notificationType\n        }));\n      });\n    }\n    /**\n     * Returns product interests\n     */\n    getProductInterests() {\n      return this.store.pipe(select(getInterests));\n    }\n    /**\n     * Returns product interests\n     * @param pageSize the page size\n     */\n    getAndLoadProductInterests(pageSize) {\n      return this.store.pipe(select(getInterestsState), tap(interestListState => {\n        const attemptedLoad = interestListState.loading || interestListState.success || interestListState.error;\n        if (!attemptedLoad) {\n          this.loadProductInterests(pageSize);\n        }\n      }), map(interestListState => interestListState.value));\n    }\n    /**\n     * Returns a loading flag for product interests\n     */\n    getProdutInterestsLoading() {\n      return this.store.pipe(select(getInterestsLoading));\n    }\n    /**\n     * Removes a ProductInterestRelation\n     * @param item product interest relation item\n     * @param singleDelete flag to delete only one interest\n     */\n    removeProdutInterest(item, singleDelete) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new RemoveProductInterest({\n          userId,\n          item: item,\n          singleDelete: singleDelete\n        }));\n      });\n    }\n    /**\n     * Returns a loading flag for removing product interests.\n     */\n    getRemoveProdutInterestLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));\n    }\n    /**\n     * Returns a success flag for removing a product interests.\n     */\n    getRemoveProdutInterestSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(REMOVE_PRODUCT_INTERESTS_PROCESS_ID)));\n    }\n    /**\n     * Add a new product interest.\n     *\n     * @param productCode the product code\n     * @param notificationType the notification type\n     */\n    addProductInterest(productCode, notificationType) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new AddProductInterest({\n          userId,\n          productCode: productCode,\n          notificationType: notificationType\n        }));\n      });\n    }\n    /**\n     * Returns a success flag for adding a product interest.\n     */\n    getAddProductInterestSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));\n    }\n    /**\n     * Returns a error flag for adding a product interest.\n     */\n    getAddProductInterestError() {\n      return this.store.pipe(select(getProcessErrorFactory(ADD_PRODUCT_INTEREST_PROCESS_ID)));\n    }\n    /**\n     * Reset product interest adding state.\n     */\n    resetAddInterestState() {\n      this.store.dispatch(new ResetAddInterestState());\n    }\n    /**\n     * Reset product interest removing state.\n     */\n    resetRemoveInterestState() {\n      this.store.dispatch(new ResetRemoveInterestState());\n    }\n    /**\n     * Clears product interests\n     */\n    clearProductInterests() {\n      this.store.dispatch(new ClearProductInterests());\n    }\n  }\n  UserInterestsService.ɵfac = function UserInterestsService_Factory(t) {\n    return new (t || UserInterestsService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  UserInterestsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserInterestsService,\n    factory: UserInterestsService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserInterestsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserNotificationPreferenceService = /*#__PURE__*/(() => {\n  class UserNotificationPreferenceService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Returns all notification preferences.\n     */\n    getPreferences() {\n      return this.store.pipe(select(getPreferences));\n    }\n    /**\n     * Returns all enabled notification preferences.\n     */\n    getEnabledPreferences() {\n      return this.store.pipe(select(getEnabledPreferences));\n    }\n    /**\n     * Loads all notification preferences.\n     */\n    loadPreferences() {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadNotificationPreferences(userId));\n      });\n    }\n    /**\n     * Clear all notification preferences.\n     */\n    clearPreferences() {\n      this.store.dispatch(new ClearNotificationPreferences());\n    }\n    /**\n     * Returns a loading flag for notification preferences.\n     */\n    getPreferencesLoading() {\n      return this.store.pipe(select(getPreferencesLoading));\n    }\n    /**\n     * Updating notification preferences.\n     * @param preferences a preference list\n     */\n    updatePreferences(preferences) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new UpdateNotificationPreferences({\n          userId,\n          preferences: preferences\n        }));\n      });\n    }\n    /**\n     * Returns a loading flag for updating preferences.\n     */\n    getUpdatePreferencesResultLoading() {\n      return this.store.select(getProcessLoadingFactory(UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID));\n    }\n    /**\n     * Resets the update notification preferences process state. The state needs to be\n     * reset after the process concludes, regardless if it's a success or an error.\n     */\n    resetNotificationPreferences() {\n      this.store.dispatch(new ResetNotificationPreferences());\n    }\n  }\n  UserNotificationPreferenceService.ɵfac = function UserNotificationPreferenceService_Factory(t) {\n    return new (t || UserNotificationPreferenceService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  UserNotificationPreferenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserNotificationPreferenceService,\n    factory: UserNotificationPreferenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserNotificationPreferenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use OrderFacade in @spartacus/order/root instead\n * TODO: In order lib, processStateStore is added in OrderService's constructor,\n * need to update it in 5.0 migration doc.\n */\nlet UserOrderService = /*#__PURE__*/(() => {\n  class UserOrderService {\n    constructor(store, userIdService, routingService) {\n      this.store = store;\n      this.userIdService = userIdService;\n      this.routingService = routingService;\n    }\n    /**\n     * Returns an order's detail\n     */\n    getOrderDetails() {\n      return this.store.pipe(select(getOrderDetails));\n    }\n    /**\n     * Retrieves order's details\n     *\n     * @param orderCode an order code\n     */\n    loadOrderDetails(orderCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadOrderDetails({\n          userId,\n          orderCode\n        }));\n      });\n    }\n    /**\n     * Clears order's details\n     */\n    clearOrderDetails() {\n      this.store.dispatch(new ClearOrderDetails());\n    }\n    /**\n     * Returns order history list\n     */\n    getOrderHistoryList(pageSize) {\n      return this.store.pipe(select(getOrdersState), tap(orderListState => {\n        const attemptedLoad = orderListState.loading || orderListState.success || orderListState.error;\n        if (!attemptedLoad) {\n          this.loadOrderList(pageSize);\n        }\n      }), map(orderListState => orderListState.value));\n    }\n    /**\n     * Returns a loaded flag for order history list\n     */\n    getOrderHistoryListLoaded() {\n      return this.store.pipe(select(getOrdersLoaded));\n    }\n    /**\n     * Retrieves an order list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadOrderList(pageSize, currentPage, sort) {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        let replenishmentOrderCode;\n        this.routingService.getRouterState().pipe(take(1)).subscribe(data => {\n          var _a, _b;\n          replenishmentOrderCode = (_b = (_a = data === null || data === void 0 ? void 0 : data.state) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.replenishmentOrderCode;\n        }).unsubscribe();\n        this.store.dispatch(new LoadUserOrders({\n          userId,\n          pageSize,\n          currentPage,\n          sort,\n          replenishmentOrderCode\n        }));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    /**\n     * Cleaning order list\n     */\n    clearOrderList() {\n      this.store.dispatch(new ClearUserOrders());\n    }\n    /**\n     *  Returns a consignment tracking detail\n     */\n    getConsignmentTracking() {\n      return this.store.pipe(select(getConsignmentTracking));\n    }\n    /**\n     * Retrieves consignment tracking details\n     * @param orderCode an order code\n     * @param consignmentCode a consignment code\n     */\n    loadConsignmentTracking(orderCode, consignmentCode) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadConsignmentTracking({\n          userId,\n          orderCode,\n          consignmentCode\n        }));\n      });\n    }\n    /**\n     * Cleaning consignment tracking\n     */\n    clearConsignmentTracking() {\n      this.store.dispatch(new ClearConsignmentTracking());\n    }\n    /*\n     * Cancel an order\n     */\n    cancelOrder(orderCode, cancelRequestInput) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new CancelOrder({\n          userId,\n          orderCode,\n          cancelRequestInput\n        }));\n      });\n    }\n    /**\n     * Returns the cancel order loading flag\n     */\n    getCancelOrderLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(CANCEL_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel order success flag\n     */\n    getCancelOrderSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(CANCEL_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Resets the cancel order process flags\n     */\n    resetCancelOrderProcessState() {\n      return this.store.dispatch(new ResetCancelOrderProcess());\n    }\n  }\n  UserOrderService.ɵfac = function UserOrderService_Factory(t) {\n    return new (t || UserOrderService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService), i0.ɵɵinject(RoutingService));\n  };\n  UserOrderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserOrderService,\n    factory: UserOrderService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserOrderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserPaymentService = /*#__PURE__*/(() => {\n  class UserPaymentService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Loads all user's payment methods.\n     */\n    loadPaymentMethods() {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new LoadUserPaymentMethods(userId));\n      });\n    }\n    /**\n     * Returns all user's payment methods\n     */\n    getPaymentMethods() {\n      return this.store.pipe(select(getPaymentMethods));\n    }\n    /**\n     * Returns a loading flag for payment methods\n     */\n    getPaymentMethodsLoading() {\n      return this.store.pipe(select(getPaymentMethodsLoading));\n    }\n    getPaymentMethodsLoadedSuccess() {\n      return this.store.pipe(select(getPaymentMethodsLoadedSuccess));\n    }\n    /**\n     * Sets the payment as a default one\n     * @param paymentMethodId a payment method ID\n     */\n    setPaymentMethodAsDefault(paymentMethodId) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new SetDefaultUserPaymentMethod({\n          userId,\n          paymentMethodId\n        }));\n      });\n    }\n    /**\n     * Deletes the payment method\n     *\n     * @param paymentMethodId a payment method ID\n     */\n    deletePaymentMethod(paymentMethodId) {\n      this.userIdService.takeUserId().subscribe(userId => {\n        this.store.dispatch(new DeleteUserPaymentMethod({\n          userId,\n          paymentMethodId\n        }));\n      });\n    }\n    /**\n     * Returns all billing countries\n     */\n    getAllBillingCountries() {\n      return this.store.pipe(select(getAllBillingCountries));\n    }\n    /**\n     * Retrieves billing countries\n     */\n    loadBillingCountries() {\n      this.store.dispatch(new LoadBillingCountries());\n    }\n  }\n  UserPaymentService.ɵfac = function UserPaymentService_Factory(t) {\n    return new (t || UserPaymentService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  UserPaymentService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserPaymentService,\n    factory: UserPaymentService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserPaymentService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use ReplenishmentOrderFacade in @spartacus/order/root instead\n * TODO: In order lib, processStateStore is added in ReplenishmentOrderService's constructor,\n * need to update it in 5.0 migration doc.\n */\nlet UserReplenishmentOrderService = /*#__PURE__*/(() => {\n  class UserReplenishmentOrderService {\n    constructor(store, userIdService) {\n      this.store = store;\n      this.userIdService = userIdService;\n    }\n    /**\n     * Returns replenishment order details for a given 'current' user\n     *\n     * @param replenishmentOrderCode a replenishment order code\n     */\n    loadReplenishmentOrderDetails(replenishmentOrderCode) {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        this.store.dispatch(new LoadReplenishmentOrderDetails({\n          userId,\n          replenishmentOrderCode\n        }));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    /**\n     * Returns a replenishment order details\n     */\n    getReplenishmentOrderDetails() {\n      return this.store.pipe(select(getReplenishmentOrderDetailsValue));\n    }\n    /**\n     * Returns a replenishment order details loading flag\n     */\n    getReplenishmentOrderDetailsLoading() {\n      return this.store.pipe(select(getReplenishmentOrderDetailsLoading));\n    }\n    /**\n     * Returns a replenishment order details success flag\n     */\n    getReplenishmentOrderDetailsSuccess() {\n      return this.store.pipe(select(getReplenishmentOrderDetailsSuccess));\n    }\n    /**\n     * Returns a replenishment order details error flag\n     */\n    getReplenishmentOrderDetailsError() {\n      return this.store.pipe(select(getReplenishmentOrderDetailsError));\n    }\n    /**\n     * Clears the replenishment orders details state\n     */\n    clearReplenishmentOrderDetails() {\n      this.store.dispatch(new ClearReplenishmentOrderDetails());\n    }\n    /**\n     * Cancels a specific replenishment order for a given 'current' user\n     *\n     * @param replenishmentOrderCode a replenishment order code\n     */\n    cancelReplenishmentOrder(replenishmentOrderCode) {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        this.store.dispatch(new CancelReplenishmentOrder({\n          userId,\n          replenishmentOrderCode\n        }));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    /**\n     * Returns the cancel replenishment order loading flag\n     */\n    getCancelReplenishmentOrderLoading() {\n      return this.store.pipe(select(getProcessLoadingFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel replenishment order success flag\n     */\n    getCancelReplenishmentOrderSuccess() {\n      return this.store.pipe(select(getProcessSuccessFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Returns the cancel replenishment order error flag\n     */\n    getCancelReplenishmentOrderError() {\n      return this.store.pipe(select(getProcessErrorFactory(CANCEL_REPLENISHMENT_ORDER_PROCESS_ID)));\n    }\n    /**\n     * Clears the cancel replenishment order processing state\n     */\n    clearCancelReplenishmentOrderProcessState() {\n      this.store.dispatch(new ClearCancelReplenishmentOrder());\n    }\n    /**\n     * Returns replenishment order history list\n     */\n    getReplenishmentOrderHistoryList(pageSize) {\n      return this.store.pipe(select(getReplenishmentOrdersState), tap(replenishmentOrderListState => {\n        const attemptedLoad = replenishmentOrderListState.loading || replenishmentOrderListState.success || replenishmentOrderListState.error;\n        if (!attemptedLoad) {\n          this.loadReplenishmentOrderList(pageSize);\n        }\n      }), map(replenishmentOrderListState => replenishmentOrderListState.value));\n    }\n    /**\n     * Returns a loading flag for replenishment order history list\n     */\n    getReplenishmentOrderHistoryListLoading() {\n      return this.store.pipe(select(getReplenishmentOrdersLoading));\n    }\n    /**\n     * Returns a error flag for replenishment order history list\n     */\n    getReplenishmentOrderHistoryListError() {\n      return this.store.pipe(select(getReplenishmentOrdersError));\n    }\n    /**\n     * Returns a success flag for replenishment order history list\n     */\n    getReplenishmentOrderHistoryListSuccess() {\n      return this.store.pipe(select(getReplenishmentOrdersSuccess));\n    }\n    /**\n     * Retrieves a replenishment order list\n     * @param pageSize page size\n     * @param currentPage current page\n     * @param sort sort\n     */\n    loadReplenishmentOrderList(pageSize, currentPage, sort) {\n      this.userIdService.takeUserId(true).subscribe(userId => {\n        this.store.dispatch(new LoadUserReplenishmentOrders({\n          userId,\n          pageSize,\n          currentPage,\n          sort\n        }));\n      }, () => {\n        // TODO: for future releases, refactor this part to thrown errors\n      });\n    }\n    /**\n     * Cleaning replenishment order list\n     */\n    clearReplenishmentOrderList() {\n      this.store.dispatch(new ClearUserReplenishmentOrders());\n    }\n  }\n  UserReplenishmentOrderService.ɵfac = function UserReplenishmentOrderService_Factory(t) {\n    return new (t || UserReplenishmentOrderService)(i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(UserIdService));\n  };\n  UserReplenishmentOrderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserReplenishmentOrderService,\n    factory: UserReplenishmentOrderService.ɵfac,\n    providedIn: 'root'\n  });\n  return UserReplenishmentOrderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BillingCountriesEffect = /*#__PURE__*/(() => {\n  class BillingCountriesEffect {\n    constructor(actions$, siteConnector) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.loadBillingCountries$ = this.actions$.pipe(ofType(LOAD_BILLING_COUNTRIES), switchMap(() => {\n        return this.siteConnector.getCountries(CountryType.BILLING).pipe(map(countries => new LoadBillingCountriesSuccess(countries)), catchError(error => of(new LoadBillingCountriesFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  BillingCountriesEffect.ɵfac = function BillingCountriesEffect_Factory(t) {\n    return new (t || BillingCountriesEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector));\n  };\n  BillingCountriesEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BillingCountriesEffect,\n    factory: BillingCountriesEffect.ɵfac\n  });\n  __decorate([Effect()], BillingCountriesEffect.prototype, \"loadBillingCountries$\", void 0);\n  return BillingCountriesEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClearMiscsDataEffect = /*#__PURE__*/(() => {\n  class ClearMiscsDataEffect {\n    constructor(actions$) {\n      this.actions$ = actions$;\n      this.clearMiscsData$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE, CURRENCY_CHANGE), map(() => {\n        return new ClearUserMiscsData();\n      }));\n    }\n  }\n  ClearMiscsDataEffect.ɵfac = function ClearMiscsDataEffect_Factory(t) {\n    return new (t || ClearMiscsDataEffect)(i0.ɵɵinject(i1$4.Actions));\n  };\n  ClearMiscsDataEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClearMiscsDataEffect,\n    factory: ClearMiscsDataEffect.ɵfac\n  });\n  __decorate([Effect()], ClearMiscsDataEffect.prototype, \"clearMiscsData$\", void 0);\n  return ClearMiscsDataEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet ConsignmentTrackingEffects = /*#__PURE__*/(() => {\n  class ConsignmentTrackingEffects {\n    constructor(actions$, userOrderConnector) {\n      this.actions$ = actions$;\n      this.userOrderConnector = userOrderConnector;\n      this.loadConsignmentTracking$ = this.actions$.pipe(ofType(LOAD_CONSIGNMENT_TRACKING), map(action => action.payload), switchMap(payload => {\n        return this.userOrderConnector.getConsignmentTracking(payload.orderCode, payload.consignmentCode, payload.userId).pipe(map(tracking => new LoadConsignmentTrackingSuccess(tracking)), catchError(error => of(new LoadConsignmentTrackingFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  ConsignmentTrackingEffects.ɵfac = function ConsignmentTrackingEffects_Factory(t) {\n    return new (t || ConsignmentTrackingEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserOrderConnector));\n  };\n  ConsignmentTrackingEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConsignmentTrackingEffects,\n    factory: ConsignmentTrackingEffects.ɵfac\n  });\n  __decorate([Effect()], ConsignmentTrackingEffects.prototype, \"loadConsignmentTracking$\", void 0);\n  return ConsignmentTrackingEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CustomerCouponEffects = /*#__PURE__*/(() => {\n  class CustomerCouponEffects {\n    constructor(actions$, customerCouponConnector) {\n      this.actions$ = actions$;\n      this.customerCouponConnector = customerCouponConnector;\n      this.loadCustomerCoupons$ = this.actions$.pipe(ofType(LOAD_CUSTOMER_COUPONS), map(action => action.payload), mergeMap(payload => {\n        return this.customerCouponConnector.getCustomerCoupons(payload.userId, payload.pageSize, payload.currentPage, payload.sort).pipe(map(coupons => {\n          return new LoadCustomerCouponsSuccess(coupons);\n        }), catchError(error => of(new LoadCustomerCouponsFail(normalizeHttpError(error)))));\n      }));\n      this.subscribeCustomerCoupon$ = this.actions$.pipe(ofType(SUBSCRIBE_CUSTOMER_COUPON), map(action => action.payload), mergeMap(payload => {\n        return this.customerCouponConnector.turnOnNotification(payload.userId, payload.couponCode).pipe(map(data => {\n          return new SubscribeCustomerCouponSuccess(data);\n        }), catchError(error => of(new SubscribeCustomerCouponFail(normalizeHttpError(error)))));\n      }));\n      this.unsubscribeCustomerCoupon$ = this.actions$.pipe(ofType(UNSUBSCRIBE_CUSTOMER_COUPON), map(action => action.payload), mergeMap(payload => {\n        return this.customerCouponConnector.turnOffNotification(payload.userId, payload.couponCode).pipe(map(() => {\n          return new UnsubscribeCustomerCouponSuccess(payload.couponCode);\n        }), catchError(error => of(new UnsubscribeCustomerCouponFail(normalizeHttpError(error)))));\n      }));\n      this.claimCustomerCoupon$ = this.actions$.pipe(ofType(CLAIM_CUSTOMER_COUPON), map(action => action.payload), mergeMap(payload => {\n        return this.customerCouponConnector.claimCustomerCoupon(payload.userId, payload.couponCode).pipe(map(data => {\n          return new ClaimCustomerCouponSuccess(data);\n        }), catchError(error => of(new ClaimCustomerCouponFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  CustomerCouponEffects.ɵfac = function CustomerCouponEffects_Factory(t) {\n    return new (t || CustomerCouponEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(CustomerCouponConnector));\n  };\n  CustomerCouponEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CustomerCouponEffects,\n    factory: CustomerCouponEffects.ɵfac\n  });\n  __decorate([Effect()], CustomerCouponEffects.prototype, \"loadCustomerCoupons$\", void 0);\n  __decorate([Effect()], CustomerCouponEffects.prototype, \"subscribeCustomerCoupon$\", void 0);\n  __decorate([Effect()], CustomerCouponEffects.prototype, \"unsubscribeCustomerCoupon$\", void 0);\n  __decorate([Effect()], CustomerCouponEffects.prototype, \"claimCustomerCoupon$\", void 0);\n  return CustomerCouponEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeliveryCountriesEffects = /*#__PURE__*/(() => {\n  class DeliveryCountriesEffects {\n    constructor(actions$, siteConnector) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.loadDeliveryCountries$ = this.actions$.pipe(ofType(LOAD_DELIVERY_COUNTRIES), switchMap(() => {\n        return this.siteConnector.getCountries(CountryType.SHIPPING).pipe(map(countries => new LoadDeliveryCountriesSuccess(countries)), catchError(error => of(new LoadDeliveryCountriesFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  DeliveryCountriesEffects.ɵfac = function DeliveryCountriesEffects_Factory(t) {\n    return new (t || DeliveryCountriesEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector));\n  };\n  DeliveryCountriesEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DeliveryCountriesEffects,\n    factory: DeliveryCountriesEffects.ɵfac\n  });\n  __decorate([Effect()], DeliveryCountriesEffects.prototype, \"loadDeliveryCountries$\", void 0);\n  return DeliveryCountriesEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NotificationPreferenceEffects = /*#__PURE__*/(() => {\n  class NotificationPreferenceEffects {\n    constructor(actions$, connector) {\n      this.actions$ = actions$;\n      this.connector = connector;\n      this.loadPreferences$ = this.actions$.pipe(ofType(LOAD_NOTIFICATION_PREFERENCES), map(action => action.payload), switchMap(payload => this.connector.loadAll(payload).pipe(map(preferences => new LoadNotificationPreferencesSuccess(preferences)), catchError(error => of(new LoadNotificationPreferencesFail(normalizeHttpError(error)))))));\n      this.updatePreferences$ = this.actions$.pipe(ofType(UPDATE_NOTIFICATION_PREFERENCES), map(action => action.payload), mergeMap(payload => this.connector.update(payload.userId, payload.preferences).pipe(map(() => new UpdateNotificationPreferencesSuccess(payload.preferences)), catchError(error => of(new UpdateNotificationPreferencesFail(normalizeHttpError(error)))))));\n    }\n  }\n  NotificationPreferenceEffects.ɵfac = function NotificationPreferenceEffects_Factory(t) {\n    return new (t || NotificationPreferenceEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserNotificationPreferenceConnector));\n  };\n  NotificationPreferenceEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NotificationPreferenceEffects,\n    factory: NotificationPreferenceEffects.ɵfac\n  });\n  __decorate([Effect()], NotificationPreferenceEffects.prototype, \"loadPreferences$\", void 0);\n  __decorate([Effect()], NotificationPreferenceEffects.prototype, \"updatePreferences$\", void 0);\n  return NotificationPreferenceEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet OrderDetailsEffect = /*#__PURE__*/(() => {\n  class OrderDetailsEffect {\n    constructor(actions$, orderConnector, globalMessageService) {\n      this.actions$ = actions$;\n      this.orderConnector = orderConnector;\n      this.globalMessageService = globalMessageService;\n      this.loadOrderDetails$ = this.actions$.pipe(ofType(LOAD_ORDER_DETAILS), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.get(payload.userId, payload.orderCode).pipe(map(order => {\n          return new LoadOrderDetailsSuccess(order);\n        }), catchError(error => of(new LoadOrderDetailsFail(normalizeHttpError(error)))));\n      }));\n      this.cancelOrder$ = this.actions$.pipe(ofType(CANCEL_ORDER), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.cancel(payload.userId, payload.orderCode, payload.cancelRequestInput).pipe(map(() => new CancelOrderSuccess()), catchError(error => {\n          var _a;\n          (_a = error.error) === null || _a === void 0 ? void 0 : _a.errors.forEach(err => this.globalMessageService.add(err.message, GlobalMessageType.MSG_TYPE_ERROR));\n          return of(new CancelOrderFail(normalizeHttpError(error)));\n        }));\n      }));\n    }\n  }\n  OrderDetailsEffect.ɵfac = function OrderDetailsEffect_Factory(t) {\n    return new (t || OrderDetailsEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserOrderConnector), i0.ɵɵinject(GlobalMessageService));\n  };\n  OrderDetailsEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OrderDetailsEffect,\n    factory: OrderDetailsEffect.ɵfac\n  });\n  __decorate([Effect()], OrderDetailsEffect.prototype, \"loadOrderDetails$\", void 0);\n  __decorate([Effect()], OrderDetailsEffect.prototype, \"cancelOrder$\", void 0);\n  return OrderDetailsEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet OrderReturnRequestEffect = /*#__PURE__*/(() => {\n  class OrderReturnRequestEffect {\n    constructor(actions$, orderConnector) {\n      this.actions$ = actions$;\n      this.orderConnector = orderConnector;\n      this.createReturnRequest$ = this.actions$.pipe(ofType(CREATE_ORDER_RETURN_REQUEST), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.return(payload.userId, payload.returnRequestInput).pipe(map(returnRequest => new CreateOrderReturnRequestSuccess(returnRequest)), catchError(error => of(new CreateOrderReturnRequestFail(normalizeHttpError(error)))));\n      }));\n      this.loadReturnRequest$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.getReturnRequestDetail(payload.userId, payload.returnRequestCode).pipe(map(returnRequest => new LoadOrderReturnRequestSuccess(returnRequest)), catchError(error => of(new LoadOrderReturnRequestFail(normalizeHttpError(error)))));\n      }));\n      this.cancelReturnRequest$ = this.actions$.pipe(ofType(CANCEL_ORDER_RETURN_REQUEST), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.cancelReturnRequest(payload.userId, payload.returnRequestCode, payload.returnRequestModification).pipe(map(() => new CancelOrderReturnRequestSuccess()), catchError(error => of(new CancelOrderReturnRequestFail(normalizeHttpError(error)))));\n      }));\n      this.loadReturnRequestList$ = this.actions$.pipe(ofType(LOAD_ORDER_RETURN_REQUEST_LIST), map(action => action.payload), switchMap(payload => {\n        return this.orderConnector.getReturnRequestList(payload.userId, payload.pageSize, payload.currentPage, payload.sort).pipe(map(returnRequestList => new LoadOrderReturnRequestListSuccess(returnRequestList)), catchError(error => of(new LoadOrderReturnRequestListFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  OrderReturnRequestEffect.ɵfac = function OrderReturnRequestEffect_Factory(t) {\n    return new (t || OrderReturnRequestEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserOrderConnector));\n  };\n  OrderReturnRequestEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OrderReturnRequestEffect,\n    factory: OrderReturnRequestEffect.ɵfac\n  });\n  __decorate([Effect()], OrderReturnRequestEffect.prototype, \"createReturnRequest$\", void 0);\n  __decorate([Effect()], OrderReturnRequestEffect.prototype, \"loadReturnRequest$\", void 0);\n  __decorate([Effect()], OrderReturnRequestEffect.prototype, \"cancelReturnRequest$\", void 0);\n  __decorate([Effect()], OrderReturnRequestEffect.prototype, \"loadReturnRequestList$\", void 0);\n  return OrderReturnRequestEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserPaymentMethodsEffects = /*#__PURE__*/(() => {\n  class UserPaymentMethodsEffects {\n    constructor(actions$, userPaymentMethodConnector) {\n      this.actions$ = actions$;\n      this.userPaymentMethodConnector = userPaymentMethodConnector;\n      this.loadUserPaymentMethods$ = this.actions$.pipe(ofType(LOAD_USER_PAYMENT_METHODS), map(action => action.payload), mergeMap(payload => {\n        return this.userPaymentMethodConnector.getAll(payload).pipe(map(payments => {\n          return new LoadUserPaymentMethodsSuccess(payments);\n        }), catchError(error => of(new LoadUserPaymentMethodsFail(normalizeHttpError(error)))));\n      }));\n      this.setDefaultUserPaymentMethod$ = this.actions$.pipe(ofType(SET_DEFAULT_USER_PAYMENT_METHOD), map(action => action.payload), mergeMap(payload => {\n        return this.userPaymentMethodConnector.setDefault(payload.userId, payload.paymentMethodId).pipe(switchMap(data => [new SetDefaultUserPaymentMethodSuccess(data), new LoadUserPaymentMethods(payload.userId)]), catchError(error => of(new SetDefaultUserPaymentMethodFail(normalizeHttpError(error)))));\n      }));\n      this.deleteUserPaymentMethod$ = this.actions$.pipe(ofType(DELETE_USER_PAYMENT_METHOD), map(action => action.payload), mergeMap(payload => {\n        return this.userPaymentMethodConnector.delete(payload.userId, payload.paymentMethodId).pipe(switchMap(data => [new DeleteUserPaymentMethodSuccess(data), new LoadUserPaymentMethods(payload.userId)]), catchError(error => of(new DeleteUserPaymentMethodFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  UserPaymentMethodsEffects.ɵfac = function UserPaymentMethodsEffects_Factory(t) {\n    return new (t || UserPaymentMethodsEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserPaymentConnector));\n  };\n  UserPaymentMethodsEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserPaymentMethodsEffects,\n    factory: UserPaymentMethodsEffects.ɵfac\n  });\n  __decorate([Effect()], UserPaymentMethodsEffects.prototype, \"loadUserPaymentMethods$\", void 0);\n  __decorate([Effect()], UserPaymentMethodsEffects.prototype, \"setDefaultUserPaymentMethod$\", void 0);\n  __decorate([Effect()], UserPaymentMethodsEffects.prototype, \"deleteUserPaymentMethod$\", void 0);\n  return UserPaymentMethodsEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ProductInterestsEffect = /*#__PURE__*/(() => {\n  class ProductInterestsEffect {\n    constructor(actions$, userInterestsConnector) {\n      this.actions$ = actions$;\n      this.userInterestsConnector = userInterestsConnector;\n      this.loadProductInteres$ = this.actions$.pipe(ofType(LOAD_PRODUCT_INTERESTS), map(action => action.payload), switchMap(payload => {\n        return this.userInterestsConnector.getInterests(payload.userId, payload.pageSize, payload.currentPage, payload.sort, payload.productCode, payload.notificationType).pipe(map(interests => {\n          return new LoadProductInterestsSuccess(interests);\n        }), catchError(error => of(new LoadProductInterestsFail(normalizeHttpError(error)))));\n      }));\n      this.removeProductInterest$ = this.actions$.pipe(ofType(REMOVE_PRODUCT_INTEREST), map(action => action.payload), switchMap(payload => this.userInterestsConnector.removeInterest(payload.userId, payload.item).pipe(switchMap(data => [new LoadProductInterests(payload.singleDelete ? {\n        userId: payload.userId,\n        productCode: payload.item.product.code,\n        notificationType: payload.item.productInterestEntry[0].interestType\n      } : {\n        userId: payload.userId\n      }), new RemoveProductInterestSuccess(data)]), catchError(error => of(new RemoveProductInterestFail(normalizeHttpError(error)))))));\n      this.addProductInterest$ = this.actions$.pipe(ofType(ADD_PRODUCT_INTEREST), map(action => action.payload), switchMap(payload => this.userInterestsConnector.addInterest(payload.userId, payload.productCode, payload.notificationType).pipe(switchMap(res => [new LoadProductInterests({\n        userId: payload.userId,\n        productCode: payload.productCode,\n        notificationType: payload.notificationType\n      }), new AddProductInterestSuccess(res)]), catchError(error => of(new AddProductInterestFail(normalizeHttpError(error)))))));\n    }\n  }\n  ProductInterestsEffect.ɵfac = function ProductInterestsEffect_Factory(t) {\n    return new (t || ProductInterestsEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserInterestsConnector));\n  };\n  ProductInterestsEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ProductInterestsEffect,\n    factory: ProductInterestsEffect.ɵfac\n  });\n  __decorate([Effect()], ProductInterestsEffect.prototype, \"loadProductInteres$\", void 0);\n  __decorate([Effect()], ProductInterestsEffect.prototype, \"removeProductInterest$\", void 0);\n  __decorate([Effect()], ProductInterestsEffect.prototype, \"addProductInterest$\", void 0);\n  return ProductInterestsEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RegionsEffects = /*#__PURE__*/(() => {\n  class RegionsEffects {\n    constructor(actions$, siteConnector) {\n      this.actions$ = actions$;\n      this.siteConnector = siteConnector;\n      this.loadRegions$ = this.actions$.pipe(ofType(LOAD_REGIONS), map(action => {\n        return action.payload;\n      }), switchMap(countryCode => {\n        return this.siteConnector.getRegions(countryCode).pipe(map(regions => new LoadRegionsSuccess({\n          entities: regions,\n          country: countryCode\n        })), catchError(error => of(new LoadRegionsFail(normalizeHttpError(error)))));\n      }));\n      this.resetRegions$ = this.actions$.pipe(ofType(CLEAR_USER_MISCS_DATA, CLEAR_REGIONS), map(() => {\n        return new LoaderResetAction(REGIONS);\n      }));\n    }\n  }\n  RegionsEffects.ɵfac = function RegionsEffects_Factory(t) {\n    return new (t || RegionsEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(SiteConnector));\n  };\n  RegionsEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RegionsEffects,\n    factory: RegionsEffects.ɵfac\n  });\n  __decorate([Effect()], RegionsEffects.prototype, \"loadRegions$\", void 0);\n  __decorate([Effect()], RegionsEffects.prototype, \"resetRegions$\", void 0);\n  return RegionsEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet ReplenishmentOrderDetailsEffect = /*#__PURE__*/(() => {\n  class ReplenishmentOrderDetailsEffect {\n    constructor(actions$, replenishmentOrderConnector, globalMessageService) {\n      this.actions$ = actions$;\n      this.replenishmentOrderConnector = replenishmentOrderConnector;\n      this.globalMessageService = globalMessageService;\n      this.loadReplenishmentOrderDetails$ = this.actions$.pipe(ofType(LOAD_REPLENISHMENT_ORDER_DETAILS), map(action => action.payload), switchMap(payload => {\n        return this.replenishmentOrderConnector.load(payload.userId, payload.replenishmentOrderCode).pipe(map(replenishmentOrder => {\n          return new LoadReplenishmentOrderDetailsSuccess(replenishmentOrder);\n        }), catchError(error => of(new LoadReplenishmentOrderDetailsFail(normalizeHttpError(error)))));\n      }));\n      this.cancelReplenishmentOrder$ = this.actions$.pipe(ofType(CANCEL_REPLENISHMENT_ORDER), map(action => action.payload), switchMap(payload => {\n        return this.replenishmentOrderConnector.cancelReplenishmentOrder(payload.userId, payload.replenishmentOrderCode).pipe(map(replenishmentOrder => new CancelReplenishmentOrderSuccess(replenishmentOrder)), catchError(error => {\n          var _a;\n          (_a = error === null || error === void 0 ? void 0 : error.error) === null || _a === void 0 ? void 0 : _a.errors.forEach(err => this.globalMessageService.add(err.message, GlobalMessageType.MSG_TYPE_ERROR));\n          return of(new CancelReplenishmentOrderFail(normalizeHttpError(error)));\n        }));\n      }));\n    }\n  }\n  ReplenishmentOrderDetailsEffect.ɵfac = function ReplenishmentOrderDetailsEffect_Factory(t) {\n    return new (t || ReplenishmentOrderDetailsEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserReplenishmentOrderConnector), i0.ɵɵinject(GlobalMessageService));\n  };\n  ReplenishmentOrderDetailsEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ReplenishmentOrderDetailsEffect,\n    factory: ReplenishmentOrderDetailsEffect.ɵfac\n  });\n  __decorate([Effect()], ReplenishmentOrderDetailsEffect.prototype, \"loadReplenishmentOrderDetails$\", void 0);\n  __decorate([Effect()], ReplenishmentOrderDetailsEffect.prototype, \"cancelReplenishmentOrder$\", void 0);\n  return ReplenishmentOrderDetailsEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserAddressesEffects = /*#__PURE__*/(() => {\n  class UserAddressesEffects {\n    constructor(actions$, userAddressConnector, userAddressService, messageService) {\n      this.actions$ = actions$;\n      this.userAddressConnector = userAddressConnector;\n      this.userAddressService = userAddressService;\n      this.messageService = messageService;\n      this.loadUserAddresses$ = this.actions$.pipe(ofType(LOAD_USER_ADDRESSES), map(action => action.payload), mergeMap(payload => {\n        return this.userAddressConnector.getAll(payload).pipe(map(addresses => {\n          return new LoadUserAddressesSuccess(addresses);\n        }), catchError(error => of(new LoadUserAddressesFail(normalizeHttpError(error)))));\n      }));\n      this.addUserAddress$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS), map(action => action.payload), mergeMap(payload => {\n        return this.userAddressConnector.add(payload.userId, payload.address).pipe(map(data => {\n          return new AddUserAddressSuccess(data);\n        }), catchError(error => of(new AddUserAddressFail(normalizeHttpError(error)))));\n      }));\n      this.updateUserAddress$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS), map(action => action.payload), mergeMap(payload => {\n        return this.userAddressConnector.update(payload.userId, payload.addressId, payload.address).pipe(map(data => {\n          // don't show the message if just setting address as default\n          if (payload.address && Object.keys(payload.address).length === 1 && payload.address.defaultAddress) {\n            return new LoadUserAddresses(payload.userId);\n          } else {\n            return new UpdateUserAddressSuccess(data);\n          }\n        }), catchError(error => of(new UpdateUserAddressFail(normalizeHttpError(error)))));\n      }));\n      this.deleteUserAddress$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS), map(action => action.payload), mergeMap(payload => {\n        return this.userAddressConnector.delete(payload.userId, payload.addressId).pipe(map(data => {\n          return new DeleteUserAddressSuccess(data);\n        }), catchError(error => of(new DeleteUserAddressFail(normalizeHttpError(error)))));\n      }));\n      /**\n       *  Reload addresses and notify about add success\n       */\n      this.showGlobalMessageOnAddSuccess$ = this.actions$.pipe(ofType(ADD_USER_ADDRESS_SUCCESS), tap(() => {\n        this.loadAddresses();\n        this.showGlobalMessage('addressForm.userAddressAddSuccess');\n      }));\n      /**\n       *  Reload addresses and notify about update success\n       */\n      this.showGlobalMessageOnUpdateSuccess$ = this.actions$.pipe(ofType(UPDATE_USER_ADDRESS_SUCCESS), tap(() => {\n        this.loadAddresses();\n        this.showGlobalMessage('addressForm.userAddressUpdateSuccess');\n      }));\n      /**\n       *  Reload addresses and notify about delete success\n       */\n      this.showGlobalMessageOnDeleteSuccess$ = this.actions$.pipe(ofType(DELETE_USER_ADDRESS_SUCCESS), tap(() => {\n        this.loadAddresses();\n        this.showGlobalMessage('addressForm.userAddressDeleteSuccess');\n      }));\n    }\n    /**\n     * Show global confirmation message with provided text\n     */\n    showGlobalMessage(text) {\n      this.messageService.add({\n        key: text\n      }, GlobalMessageType.MSG_TYPE_CONFIRMATION);\n    }\n    loadAddresses() {\n      this.userAddressService.loadAddresses();\n    }\n  }\n  UserAddressesEffects.ɵfac = function UserAddressesEffects_Factory(t) {\n    return new (t || UserAddressesEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserAddressConnector), i0.ɵɵinject(UserAddressService), i0.ɵɵinject(GlobalMessageService));\n  };\n  UserAddressesEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserAddressesEffects,\n    factory: UserAddressesEffects.ɵfac\n  });\n  __decorate([Effect()], UserAddressesEffects.prototype, \"loadUserAddresses$\", void 0);\n  __decorate([Effect()], UserAddressesEffects.prototype, \"addUserAddress$\", void 0);\n  __decorate([Effect()], UserAddressesEffects.prototype, \"updateUserAddress$\", void 0);\n  __decorate([Effect()], UserAddressesEffects.prototype, \"deleteUserAddress$\", void 0);\n  __decorate([Effect({\n    dispatch: false\n  })], UserAddressesEffects.prototype, \"showGlobalMessageOnAddSuccess$\", void 0);\n  __decorate([Effect({\n    dispatch: false\n  })], UserAddressesEffects.prototype, \"showGlobalMessageOnUpdateSuccess$\", void 0);\n  __decorate([Effect({\n    dispatch: false\n  })], UserAddressesEffects.prototype, \"showGlobalMessageOnDeleteSuccess$\", void 0);\n  return UserAddressesEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserConsentsEffect = /*#__PURE__*/(() => {\n  class UserConsentsEffect {\n    constructor(actions$, userConsentConnector) {\n      this.actions$ = actions$;\n      this.userConsentConnector = userConsentConnector;\n      this.resetConsents$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map(() => new ResetLoadUserConsents()));\n      this.getConsents$ = this.actions$.pipe(ofType(LOAD_USER_CONSENTS), map(action => action.payload), concatMap(userId => this.userConsentConnector.loadConsents(userId).pipe(map(consents => new LoadUserConsentsSuccess(consents)), catchError(error => of(new LoadUserConsentsFail(normalizeHttpError(error)))))));\n      this.giveConsent$ = this.actions$.pipe(ofType(GIVE_USER_CONSENT, TRANSFER_ANONYMOUS_CONSENT), concatMap(action => this.userConsentConnector.giveConsent(action.payload.userId, action.payload.consentTemplateId, action.payload.consentTemplateVersion).pipe(map(consent => new GiveUserConsentSuccess(consent)), catchError(error => {\n        const errors = [new GiveUserConsentFail(normalizeHttpError(error))];\n        if (action.type === TRANSFER_ANONYMOUS_CONSENT && error.status === 409) {\n          errors.push(new RemoveMessagesByType(GlobalMessageType.MSG_TYPE_ERROR));\n        }\n        return of(...errors);\n      }))));\n      this.withdrawConsent$ = this.actions$.pipe(ofType(WITHDRAW_USER_CONSENT), map(action => action.payload), concatMap(({\n        userId,\n        consentCode\n      }) => this.userConsentConnector.withdrawConsent(userId, consentCode).pipe(map(() => new WithdrawUserConsentSuccess()), catchError(error => of(new WithdrawUserConsentFail(normalizeHttpError(error)))))));\n    }\n  }\n  UserConsentsEffect.ɵfac = function UserConsentsEffect_Factory(t) {\n    return new (t || UserConsentsEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserConsentConnector));\n  };\n  UserConsentsEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserConsentsEffect,\n    factory: UserConsentsEffect.ɵfac\n  });\n  __decorate([Effect()], UserConsentsEffect.prototype, \"resetConsents$\", void 0);\n  __decorate([Effect()], UserConsentsEffect.prototype, \"getConsents$\", void 0);\n  __decorate([Effect()], UserConsentsEffect.prototype, \"giveConsent$\", void 0);\n  __decorate([Effect()], UserConsentsEffect.prototype, \"withdrawConsent$\", void 0);\n  return UserConsentsEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserCostCenterEffects = /*#__PURE__*/(() => {\n  class UserCostCenterEffects {\n    constructor(actions$, userCostCenterConnector) {\n      this.actions$ = actions$;\n      this.userCostCenterConnector = userCostCenterConnector;\n      this.loadActiveCostCenters$ = this.actions$.pipe(ofType(LOAD_ACTIVE_COST_CENTERS), map(action => action.payload), switchMap(payload => this.userCostCenterConnector.getActiveList(payload).pipe(\n      // TODO(#8875): Should we use here serialize utils?\n      map(data => new LoadActiveCostCentersSuccess(data.values)), catchError(error => of(new LoadActiveCostCentersFail(normalizeHttpError(error)))))));\n    }\n  }\n  UserCostCenterEffects.ɵfac = function UserCostCenterEffects_Factory(t) {\n    return new (t || UserCostCenterEffects)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserCostCenterConnector));\n  };\n  UserCostCenterEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserCostCenterEffects,\n    factory: UserCostCenterEffects.ɵfac\n  });\n  __decorate([Effect()], UserCostCenterEffects.prototype, \"loadActiveCostCenters$\", void 0);\n  return UserCostCenterEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet UserOrdersEffect = /*#__PURE__*/(() => {\n  class UserOrdersEffect {\n    constructor(actions$, orderConnector, replenishmentOrderConnector) {\n      this.actions$ = actions$;\n      this.orderConnector = orderConnector;\n      this.replenishmentOrderConnector = replenishmentOrderConnector;\n      this.loadUserOrders$ = this.actions$.pipe(ofType(LOAD_USER_ORDERS), map(action => action.payload), switchMap(payload => {\n        return (Boolean(payload.replenishmentOrderCode) ? this.replenishmentOrderConnector.loadReplenishmentDetailsHistory(payload.userId, payload.replenishmentOrderCode, payload.pageSize, payload.currentPage, payload.sort) : this.orderConnector.getHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort)).pipe(map(orders => {\n          return new LoadUserOrdersSuccess(orders);\n        }), catchError(error => of(new LoadUserOrdersFail(normalizeHttpError(error)))));\n      }));\n      this.resetUserOrders$ = this.actions$.pipe(ofType(LANGUAGE_CHANGE), map(() => {\n        return new ClearUserOrders();\n      }));\n    }\n  }\n  UserOrdersEffect.ɵfac = function UserOrdersEffect_Factory(t) {\n    return new (t || UserOrdersEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserOrderConnector), i0.ɵɵinject(UserReplenishmentOrderConnector));\n  };\n  UserOrdersEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserOrdersEffect,\n    factory: UserOrdersEffect.ɵfac\n  });\n  __decorate([Effect()], UserOrdersEffect.prototype, \"loadUserOrders$\", void 0);\n  __decorate([Effect()], UserOrdersEffect.prototype, \"resetUserOrders$\", void 0);\n  return UserOrdersEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nlet UserReplenishmentOrdersEffect = /*#__PURE__*/(() => {\n  class UserReplenishmentOrdersEffect {\n    constructor(actions$, replenishmentOrderConnector) {\n      this.actions$ = actions$;\n      this.replenishmentOrderConnector = replenishmentOrderConnector;\n      this.loadUserReplenishmentOrders$ = this.actions$.pipe(ofType(LOAD_USER_REPLENISHMENT_ORDERS), map(action => action.payload), switchMap(payload => {\n        return this.replenishmentOrderConnector.loadHistory(payload.userId, payload.pageSize, payload.currentPage, payload.sort).pipe(map(orders => {\n          return new LoadUserReplenishmentOrdersSuccess(orders);\n        }), catchError(error => of(new LoadUserReplenishmentOrdersFail(normalizeHttpError(error)))));\n      }));\n    }\n  }\n  UserReplenishmentOrdersEffect.ɵfac = function UserReplenishmentOrdersEffect_Factory(t) {\n    return new (t || UserReplenishmentOrdersEffect)(i0.ɵɵinject(i1$4.Actions), i0.ɵɵinject(UserReplenishmentOrderConnector));\n  };\n  UserReplenishmentOrdersEffect.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserReplenishmentOrdersEffect,\n    factory: UserReplenishmentOrdersEffect.ɵfac\n  });\n  __decorate([Effect()], UserReplenishmentOrdersEffect.prototype, \"loadUserReplenishmentOrders$\", void 0);\n  return UserReplenishmentOrdersEffect;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use effectsTransitional_4_2 with order lib instead\n */\nconst effectsTransitional = [ClearMiscsDataEffect, DeliveryCountriesEffects, RegionsEffects, UserAddressesEffects, UserPaymentMethodsEffects, UserOrdersEffect, OrderDetailsEffect, BillingCountriesEffect, UserConsentsEffect, ConsignmentTrackingEffects, CustomerCouponEffects, NotificationPreferenceEffects, ProductInterestsEffect, OrderReturnRequestEffect, UserCostCenterEffects, ReplenishmentOrderDetailsEffect, UserReplenishmentOrdersEffect];\nconst initialState$f = {\n  entities: {}\n};\nfunction reducer$f(state = initialState$f, action) {\n  switch (action.type) {\n    case LOAD_BILLING_COUNTRIES_SUCCESS:\n      {\n        const billingCountries = action.payload;\n        const entities = billingCountries.reduce((countryEntities, name) => {\n          return Object.assign(Object.assign({}, countryEntities), {\n            [name.isocode]: name\n          });\n        }, Object.assign({}, state.entities));\n        return Object.assign(Object.assign({}, state), {\n          entities\n        });\n      }\n    case CLEAR_USER_MISCS_DATA:\n      {\n        return initialState$f;\n      }\n  }\n  return state;\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst initialState$e = {};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer$e(state = initialState$e, action) {\n  switch (action.type) {\n    case LOAD_CONSIGNMENT_TRACKING_SUCCESS:\n      {\n        const tracking = action.payload;\n        return {\n          tracking\n        };\n      }\n    case CLEAR_CONSIGNMENT_TRACKING:\n      {\n        return initialState$e;\n      }\n  }\n  return state;\n}\nconst initialState$d = {\n  coupons: [],\n  sorts: [],\n  pagination: {}\n};\nfunction reducer$d(state = initialState$d, action) {\n  switch (action.type) {\n    case LOAD_CUSTOMER_COUPONS_SUCCESS:\n      {\n        return action.payload;\n      }\n    case SUBSCRIBE_CUSTOMER_COUPON_SUCCESS:\n      {\n        const updatedCustomerCoupon = action.payload.coupon;\n        const customerCoupons = new Array(state.coupons.length);\n        state.coupons.forEach((customerCoupon, index) => customerCoupon.couponId === updatedCustomerCoupon.couponId ? customerCoupons[index] = updatedCustomerCoupon : customerCoupons[index] = customerCoupon);\n        return Object.assign(Object.assign({}, state), {\n          coupons: customerCoupons\n        });\n      }\n    case UNSUBSCRIBE_CUSTOMER_COUPON_SUCCESS:\n      {\n        const updatedCouponCode = action.payload;\n        const customerCoupons = new Array(state.coupons.length);\n        state.coupons.forEach((customerCoupon, index) => customerCoupon.couponId === updatedCouponCode ? customerCoupons[index] = Object.assign(Object.assign({}, customerCoupon), {\n          notificationOn: false\n        }) : customerCoupons[index] = customerCoupon);\n        return Object.assign(Object.assign({}, state), {\n          coupons: customerCoupons\n        });\n      }\n  }\n  return state;\n}\nconst initialState$c = {\n  entities: {}\n};\nfunction reducer$c(state = initialState$c, action) {\n  switch (action.type) {\n    case LOAD_DELIVERY_COUNTRIES_SUCCESS:\n      {\n        const deliveryCountries = action.payload;\n        const entities = deliveryCountries.reduce((countryEntities, country) => {\n          return Object.assign(Object.assign({}, countryEntities), {\n            [country.isocode]: country\n          });\n        }, Object.assign({}, state.entities));\n        return Object.assign(Object.assign({}, state), {\n          entities\n        });\n      }\n    case CLEAR_USER_MISCS_DATA:\n      {\n        return initialState$c;\n      }\n  }\n  return state;\n}\nconst initialState$b = [];\nfunction reducer$b(state = initialState$b, action) {\n  switch (action.type) {\n    case LOAD_NOTIFICATION_PREFERENCES_FAIL:\n      {\n        return initialState$b;\n      }\n    case LOAD_NOTIFICATION_PREFERENCES_SUCCESS:\n    case UPDATE_NOTIFICATION_PREFERENCES_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$b;\n      }\n  }\n  return state;\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst initialState$a = {};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer$a(state = initialState$a, action) {\n  switch (action.type) {\n    case LOAD_ORDER_DETAILS_SUCCESS:\n      {\n        const order = action.payload;\n        return order;\n      }\n  }\n  return state;\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst initialState$9 = {\n  returnRequests: [],\n  pagination: {},\n  sorts: []\n};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer$9(state = initialState$9, action) {\n  switch (action.type) {\n    case LOAD_ORDER_RETURN_REQUEST_LIST_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$9;\n      }\n  }\n  return state;\n}\nconst initialState$8 = [];\nfunction reducer$8(state = initialState$8, action) {\n  switch (action.type) {\n    case LOAD_USER_PAYMENT_METHODS_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$8;\n      }\n    case LOAD_USER_PAYMENT_METHODS_FAIL:\n      {\n        return initialState$8;\n      }\n  }\n  return state;\n}\nconst initialState$7 = {\n  results: [],\n  pagination: {},\n  sorts: []\n};\nfunction reducer$7(state = initialState$7, action) {\n  switch (action.type) {\n    case LOAD_PRODUCT_INTERESTS_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$7;\n      }\n    case LOAD_PRODUCT_INTERESTS_FAIL:\n      {\n        return initialState$7;\n      }\n  }\n  return state;\n}\nconst initialState$6 = {\n  entities: [],\n  country: null\n};\nfunction reducer$6(state = initialState$6, action) {\n  switch (action.type) {\n    case LOAD_REGIONS_SUCCESS:\n      {\n        const entities = action.payload.entities;\n        const country = action.payload.country;\n        if (entities || country) {\n          return Object.assign(Object.assign({}, state), {\n            entities,\n            country\n          });\n        }\n        return initialState$6;\n      }\n  }\n  return state;\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst initialState$5 = {};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer$5(state = initialState$5, action) {\n  switch (action.type) {\n    case LOAD_REPLENISHMENT_ORDER_DETAILS_SUCCESS:\n    case CANCEL_REPLENISHMENT_ORDER_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$5;\n      }\n    default:\n      {\n        return state;\n      }\n  }\n}\nconst initialState$4 = [];\nfunction reducer$4(state = initialState$4, action) {\n  switch (action.type) {\n    case LOAD_USER_ADDRESSES_FAIL:\n      {\n        return initialState$4;\n      }\n    case LOAD_USER_ADDRESSES_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$4;\n      }\n  }\n  return state;\n}\nconst initialState$3 = [];\nfunction reducer$3(state = initialState$3, action) {\n  switch (action.type) {\n    case LOAD_USER_CONSENTS_SUCCESS:\n      {\n        const consents = action.payload;\n        return consents ? consents : initialState$3;\n      }\n    case GIVE_USER_CONSENT_SUCCESS:\n      {\n        const updatedConsentTemplate = action.consentTemplate;\n        return state.map(consentTemplate => consentTemplate.id === updatedConsentTemplate.id ? updatedConsentTemplate : consentTemplate);\n      }\n  }\n  return state;\n}\nconst initialState$2 = [];\nfunction reducer$2(state = initialState$2, action) {\n  switch (action.type) {\n    case LOAD_ACTIVE_COST_CENTERS_FAIL:\n      {\n        return initialState$2;\n      }\n    case LOAD_ACTIVE_COST_CENTERS_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$2;\n      }\n  }\n  return state;\n}\n\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nconst initialState$1 = {\n  orders: [],\n  pagination: {},\n  sorts: []\n};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer$1(state = initialState$1, action) {\n  switch (action.type) {\n    case LOAD_USER_ORDERS_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState$1;\n      }\n    case LOAD_USER_ORDERS_FAIL:\n      {\n        return initialState$1;\n      }\n  }\n  return state;\n}\nconst initialState = {\n  replenishmentOrders: [],\n  pagination: {},\n  sorts: []\n};\n/**\n * @deprecated since 4.2 - use order lib instead\n */\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case LOAD_USER_REPLENISHMENT_ORDERS_SUCCESS:\n      {\n        return action.payload ? action.payload : initialState;\n      }\n    case CANCEL_REPLENISHMENT_ORDER_SUCCESS:\n      {\n        const cancelledReplenishmentOrder = action.payload;\n        const userReplenishmentOrders = [...state.replenishmentOrders];\n        const index = userReplenishmentOrders.findIndex(replenishmentOrder => replenishmentOrder.replenishmentOrderCode === cancelledReplenishmentOrder.replenishmentOrderCode);\n        if (index === -1) {\n          return initialState;\n        } else {\n          userReplenishmentOrders[index] = Object.assign({}, cancelledReplenishmentOrder);\n        }\n        return Object.assign(Object.assign({}, state), {\n          replenishmentOrders: userReplenishmentOrders\n        });\n      }\n  }\n  return state;\n}\nfunction getReducers() {\n  return {\n    addresses: loaderReducer(USER_ADDRESSES, reducer$4),\n    billingCountries: reducer$f,\n    consents: loaderReducer(USER_CONSENTS, reducer$3),\n    payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),\n    orders: loaderReducer(USER_ORDERS, reducer$1),\n    order: loaderReducer(USER_ORDER_DETAILS, reducer$a),\n    replenishmentOrders: loaderReducer(USER_REPLENISHMENT_ORDERS, reducer),\n    orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),\n    orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$9),\n    countries: reducer$c,\n    regions: loaderReducer(REGIONS, reducer$6),\n    consignmentTracking: reducer$e,\n    customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),\n    notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),\n    productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),\n    costCenters: loaderReducer(USER_COST_CENTERS, reducer$2),\n    replenishmentOrder: loaderReducer(USER_REPLENISHMENT_ORDER_DETAILS, reducer$5)\n  };\n}\nconst reducerToken = new InjectionToken('UserReducers');\nconst reducerProvider = {\n  provide: reducerToken,\n  useFactory: getReducers\n};\nfunction clearUserState(reducer) {\n  return function (state, action) {\n    if (action.type === LOGOUT) {\n      state = undefined;\n    }\n    return reducer(state, action);\n  };\n}\nconst metaReducers = [clearUserState];\n\n/**\n * @deprecated since 4.2 - use getReducersTransitional_4_2 with order lib instead\n */\nfunction getReducersTransitional() {\n  return {\n    addresses: loaderReducer(USER_ADDRESSES, reducer$4),\n    billingCountries: reducer$f,\n    consents: loaderReducer(USER_CONSENTS, reducer$3),\n    payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),\n    orders: loaderReducer(USER_ORDERS, reducer$1),\n    order: loaderReducer(USER_ORDER_DETAILS, reducer$a),\n    replenishmentOrders: loaderReducer(USER_REPLENISHMENT_ORDERS, reducer),\n    orderReturn: loaderReducer(USER_RETURN_REQUEST_DETAILS),\n    orderReturnList: loaderReducer(USER_RETURN_REQUESTS, reducer$9),\n    countries: reducer$c,\n    regions: loaderReducer(REGIONS, reducer$6),\n    consignmentTracking: reducer$e,\n    customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),\n    notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),\n    productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),\n    costCenters: loaderReducer(USER_COST_CENTERS, reducer$2),\n    replenishmentOrder: loaderReducer(USER_REPLENISHMENT_ORDER_DETAILS, reducer$5)\n  };\n}\n/**\n * @deprecated since 4.2 - use reducerTransitional_4_2_Provider with order lib instead\n */\nconst reducerTransitionalProvider = {\n  provide: reducerToken,\n  useFactory: getReducersTransitional\n};\n\n/**\n * @deprecated since 4.2 - use UserStoreTransitional_4_2_Module with order lib instead\n */\nlet UserStoreTransitionalModule = /*#__PURE__*/(() => {\n  class UserStoreTransitionalModule {}\n  UserStoreTransitionalModule.ɵfac = function UserStoreTransitionalModule_Factory(t) {\n    return new (t || UserStoreTransitionalModule)();\n  };\n  UserStoreTransitionalModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserStoreTransitionalModule\n  });\n  UserStoreTransitionalModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerTransitionalProvider],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(USER_FEATURE, reducerToken, {\n      metaReducers\n    }), EffectsModule.forFeature(effectsTransitional), RouterModule]]\n  });\n  return UserStoreTransitionalModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @deprecated since 4.2 - use UserTransitional_4_2_Module with order lib instead\n */\nlet UserTransitionalModule = /*#__PURE__*/(() => {\n  class UserTransitionalModule {\n    static forRoot() {\n      return {\n        ngModule: UserTransitionalModule\n      };\n    }\n  }\n  UserTransitionalModule.ɵfac = function UserTransitionalModule_Factory(t) {\n    return new (t || UserTransitionalModule)();\n  };\n  UserTransitionalModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserTransitionalModule\n  });\n  UserTransitionalModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [UserEventBuilder],\n    imports: [[UserStoreTransitionalModule, UserEventModule]]\n  });\n  return UserTransitionalModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effectsTransitional_4_2 = [ClearMiscsDataEffect, DeliveryCountriesEffects, RegionsEffects, UserAddressesEffects, UserPaymentMethodsEffects, BillingCountriesEffect, UserConsentsEffect, CustomerCouponEffects, NotificationPreferenceEffects, ProductInterestsEffect, UserCostCenterEffects];\nfunction getReducersTransitional_4_2() {\n  return {\n    addresses: loaderReducer(USER_ADDRESSES, reducer$4),\n    billingCountries: reducer$f,\n    consents: loaderReducer(USER_CONSENTS, reducer$3),\n    payments: loaderReducer(USER_PAYMENT_METHODS, reducer$8),\n    countries: reducer$c,\n    regions: loaderReducer(REGIONS, reducer$6),\n    customerCoupons: loaderReducer(CUSTOMER_COUPONS, reducer$d),\n    notificationPreferences: loaderReducer(NOTIFICATION_PREFERENCES, reducer$b),\n    productInterests: loaderReducer(PRODUCT_INTERESTS, reducer$7),\n    costCenters: loaderReducer(USER_COST_CENTERS, reducer$2)\n  };\n}\nconst reducerTransitional_4_2_Provider = {\n  provide: reducerToken,\n  useFactory: getReducersTransitional_4_2\n};\nlet UserStoreTransitional_4_2_Module = /*#__PURE__*/(() => {\n  class UserStoreTransitional_4_2_Module {}\n  UserStoreTransitional_4_2_Module.ɵfac = function UserStoreTransitional_4_2_Module_Factory(t) {\n    return new (t || UserStoreTransitional_4_2_Module)();\n  };\n  UserStoreTransitional_4_2_Module.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserStoreTransitional_4_2_Module\n  });\n  UserStoreTransitional_4_2_Module.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerTransitional_4_2_Provider],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(USER_FEATURE, reducerToken, {\n      metaReducers\n    }), EffectsModule.forFeature(effectsTransitional_4_2), RouterModule]]\n  });\n  return UserStoreTransitional_4_2_Module;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserTransitional_4_2_Module = /*#__PURE__*/(() => {\n  class UserTransitional_4_2_Module {\n    static forRoot() {\n      return {\n        ngModule: UserTransitional_4_2_Module\n      };\n    }\n  }\n  UserTransitional_4_2_Module.ɵfac = function UserTransitional_4_2_Module_Factory(t) {\n    return new (t || UserTransitional_4_2_Module)();\n  };\n  UserTransitional_4_2_Module.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UserTransitional_4_2_Module\n  });\n  UserTransitional_4_2_Module.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [UserEventBuilder],\n    imports: [[UserStoreTransitional_4_2_Module, UserEventModule]]\n  });\n  return UserTransitional_4_2_Module;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet QueryService = /*#__PURE__*/(() => {\n  class QueryService {\n    constructor(eventService) {\n      this.eventService = eventService;\n      this.subscriptions = new Subscription();\n    }\n    create(loaderFactory, options) {\n      var _a, _b, _c, _d, _e, _f;\n      const initialState = {\n        data: undefined,\n        error: false,\n        loading: true\n      };\n      const state$ = new BehaviorSubject(initialState);\n      // if the query will be unsubscribed from while the data is being loaded, we will end up with the loading flag set to true\n      // we want to retry this load on next subscription\n      const onSubscribeLoad$ = iif(() => state$.value.loading, of(undefined));\n      const loadTrigger$ = this.getTriggersStream([onSubscribeLoad$, ...((_a = options === null || options === void 0 ? void 0 : options.reloadOn) !== null && _a !== void 0 ? _a : []), ...((_b = options === null || options === void 0 ? void 0 : options.resetOn) !== null && _b !== void 0 ? _b : [])]);\n      const resetTrigger$ = this.getTriggersStream((_c = options === null || options === void 0 ? void 0 : options.resetOn) !== null && _c !== void 0 ? _c : []);\n      const reloadTrigger$ = this.getTriggersStream((_d = options === null || options === void 0 ? void 0 : options.reloadOn) !== null && _d !== void 0 ? _d : []);\n      const load$ = loadTrigger$.pipe(tap(() => {\n        if (!state$.value.loading) {\n          state$.next(Object.assign(Object.assign({}, state$.value), {\n            loading: true\n          }));\n        }\n      }), switchMapTo(loaderFactory().pipe(takeUntil(resetTrigger$))), tap(data => {\n        state$.next({\n          loading: false,\n          error: false,\n          data\n        });\n      }), catchError((error, retryStream$) => {\n        state$.next({\n          loading: false,\n          error,\n          data: undefined\n        });\n        return retryStream$;\n      }), share());\n      // reload logic\n      if ((_e = options === null || options === void 0 ? void 0 : options.reloadOn) === null || _e === void 0 ? void 0 : _e.length) {\n        this.subscriptions.add(reloadTrigger$.subscribe(() => {\n          if (!state$.value.loading) {\n            state$.next(Object.assign(Object.assign({}, state$.value), {\n              loading: true\n            }));\n          }\n        }));\n      }\n      // reset logic\n      if ((_f = options === null || options === void 0 ? void 0 : options.resetOn) === null || _f === void 0 ? void 0 : _f.length) {\n        this.subscriptions.add(resetTrigger$.subscribe(() => {\n          if (state$.value.data !== undefined || state$.value.error !== false || state$.value.loading !== false) {\n            state$.next(initialState);\n          }\n        }));\n      }\n      const query$ = using(() => load$.subscribe(), () => state$);\n      const data$ = query$.pipe(pluck('data'), distinctUntilChanged());\n      return {\n        get: () => data$,\n        getState: () => query$\n      };\n    }\n    getTriggersStream(triggers) {\n      if (!triggers.length) {\n        return EMPTY;\n      }\n      const observables = triggers.map(trigger => {\n        if (isObservable(trigger)) {\n          return trigger;\n        }\n        return this.eventService.get(trigger);\n      });\n      return merge(...observables);\n    }\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n    }\n  }\n  QueryService.ɵfac = function QueryService_Factory(t) {\n    return new (t || QueryService)(i0.ɵɵinject(EventService));\n  };\n  QueryService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: QueryService,\n    factory: QueryService.ɵfac,\n    providedIn: 'root'\n  });\n  return QueryService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar ScriptPlacement = /*#__PURE__*/(() => {\n  (function (ScriptPlacement) {\n    ScriptPlacement[\"HEAD\"] = \"head\";\n    ScriptPlacement[\"BODY\"] = \"body\";\n  })(ScriptPlacement || (ScriptPlacement = {}));\n  return ScriptPlacement;\n})();\nlet ScriptLoader = /*#__PURE__*/(() => {\n  class ScriptLoader {\n    constructor(document, platformId) {\n      this.document = document;\n      this.platformId = platformId;\n    }\n    /**\n     * Embeds a javascript from an external URL.\n     *\n     * @param embedOptions\n     * src: URL for the script to be loaded\n     * params: additional parameters to be attached to the given URL\n     * attributes: the attributes of HTML script tag (exclude src)\n     * callback: a function to be invoked after the script has been loaded\n     * errorCallback: function to be invoked after error during script loading\n     * placement: HTML body or head where script will be placed\n     */\n    embedScript(embedOptions) {\n      const {\n        src,\n        params,\n        attributes,\n        callback,\n        errorCallback,\n        placement = ScriptPlacement.HEAD\n      } = embedOptions;\n      const isSSR = isPlatformServer(this.platformId);\n      if ((callback || errorCallback) && isSSR) {\n        return;\n      }\n      const source = params ? src + this.parseParams(params) : src;\n      if (!isSSR && this.hasScript(source)) {\n        return;\n      }\n      const script = this.document.createElement('script');\n      script.src = source;\n      script.async = true;\n      script.defer = true;\n      if (attributes) {\n        Object.keys(attributes).forEach(key => {\n          // custom attributes\n          if (key.startsWith('data-')) {\n            script.setAttribute(key, attributes[key]);\n          } else {\n            script[key] = attributes[key];\n          }\n        });\n      }\n      if (callback) {\n        script.addEventListener('load', callback);\n      }\n      if (errorCallback) {\n        script.addEventListener('error', errorCallback);\n      }\n      placement === ScriptPlacement.HEAD ? this.document.head.appendChild(script) : this.document.body.appendChild(script);\n    }\n    /**\n     * Indicates if the script is already added to the DOM.\n     */\n    hasScript(src) {\n      return !!this.document.querySelector(`script[src=\"${src}\"]`);\n    }\n    /**\n     * Parses the given object with parameters to a string \"param1=value1&param2=value2\"\n     * @param params object containing parameters\n     */\n    parseParams(params) {\n      let result = '';\n      const keysArray = Object.keys(params);\n      if (keysArray.length > 0) {\n        result = '?' + keysArray.map(key => encodeURI(key) + '=' + encodeURI(params[key])).join('&');\n      }\n      return result;\n    }\n  }\n  ScriptLoader.ɵfac = function ScriptLoader_Factory(t) {\n    return new (t || ScriptLoader)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID));\n  };\n  ScriptLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScriptLoader,\n    factory: ScriptLoader.ɵfac,\n    providedIn: 'root'\n  });\n  return ScriptLoader;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass TimeUtils {\n  /**\n   * Returns the local timezone in a format that can be appended to a date-like string.\n   * @param invert (default: false): returns the opposite operator relative to the local timezone\n   *\n   * @example\n   * When locale is set to a CEST timezone, `getLocalTimezoneOffset()` returns '+02:00'\n   * and `getLocalTimezoneOffset(true)` returns '-02:00'\n   */\n  static getLocalTimezoneOffset(invert) {\n    const offset = new Date().getTimezoneOffset() * -1;\n    const hours = Math.abs(Math.floor(offset / 60)).toString().padStart(2, '0');\n    const minutes = (offset % 60).toString().padStart(2, '0');\n    const sign = offset >= 0 ? invert ? `-` : `+` : invert ? `+` : `-`;\n    return `${sign}${hours}:${minutes}`;\n  }\n  static convertDateToDatetime(date, endOfDay) {\n    return `${date}T${!endOfDay ? '00:00:00' : '23:59:59'}${TimeUtils.getLocalTimezoneOffset()}`;\n  }\n  static convertDatetimeToDate(datetime) {\n    return new Date(`${datetime.substring(0, 19)}${TimeUtils.getLocalTimezoneOffset(true)}`).toISOString().substring(0, 10);\n  }\n}\nlet FeatureModulesService = /*#__PURE__*/(() => {\n  class FeatureModulesService {\n    constructor(cmsConfig, lazyModules) {\n      this.cmsConfig = cmsConfig;\n      this.lazyModules = lazyModules;\n      /*\n       * Contains resolvers for features.\n       * Each resolver runs only once and caches the result.\n       */\n      this.features = new Map();\n    }\n    /**\n     * Check if feature is configured properly by providing module the shell app\n     *\n     * @param featureName\n     */\n    isConfigured(featureName) {\n      var _a;\n      return !!((_a = this.getFeatureConfig(featureName)) === null || _a === void 0 ? void 0 : _a.module);\n    }\n    /**\n     * Resolve feature based on feature name, if feature was not yet resolved\n     *\n     * It will first resolve all module dependencies if defined\n     */\n    resolveFeature(featureName) {\n      featureName = this.resolveFeatureAlias(featureName);\n      return defer(() => {\n        if (!this.features.has(featureName)) {\n          if (!this.isConfigured(featureName)) {\n            return throwError(new Error('No module defined for Feature Module ' + featureName));\n          }\n          const featureConfig = this.getFeatureConfig(featureName);\n          this.features.set(featureName, this.resolveDependencies(featureConfig.dependencies).pipe(switchMap(deps => this.lazyModules.resolveModuleInstance(featureConfig.module, featureName, deps)), shareReplay()));\n        }\n        return this.features.get(featureName);\n      });\n    }\n    /**\n     * Resolve\n     * @param featureName\n     * @protected\n     */\n    getFeatureConfig(featureName) {\n      var _a;\n      return (_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[this.resolveFeatureAlias(featureName)];\n    }\n    /**\n     * Will return target feature name, resolving optional feature to feature\n     * string mapping\n     *\n     * @param featureName\n     * @protected\n     */\n    resolveFeatureAlias(featureName) {\n      var _a, _b;\n      while (typeof ((_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[featureName]) === 'string') {\n        featureName = (_b = this.cmsConfig.featureModules) === null || _b === void 0 ? void 0 : _b[featureName];\n      }\n      return featureName;\n    }\n    /**\n     * Resolve dependency modules for the feature\n     *\n     * @param dependencies\n     * @protected\n     */\n    resolveDependencies(dependencies = []) {\n      return (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) ? forkJoin(dependencies.map(dependency => {\n        if (typeof dependency === 'string') {\n          // dependency is a feature, referenced by a feature name\n          return this.resolveFeature(dependency);\n        }\n        // resolve dependency from a module function\n        return this.lazyModules.resolveDependencyModuleInstance(dependency);\n      })) : of(undefined);\n    }\n  }\n  FeatureModulesService.ɵfac = function FeatureModulesService_Factory(t) {\n    return new (t || FeatureModulesService)(i0.ɵɵinject(CmsConfig), i0.ɵɵinject(LazyModulesService));\n  };\n  FeatureModulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FeatureModulesService,\n    factory: FeatureModulesService.ɵfac,\n    providedIn: 'root'\n  });\n  return FeatureModulesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Service that can create proxy facade, which is a service that will expose\n * methods and properties from a facade implemented in the lazy loaded module.\n *\n * Returned proxy facade will lazy load the feature and facade implementation\n * at first method call or when first property observable will be subscribed.\n */\nlet FacadeFactoryService = /*#__PURE__*/(() => {\n  class FacadeFactoryService {\n    constructor(featureModules, injector) {\n      this.featureModules = featureModules;\n      this.injector = injector;\n    }\n    getResolver(feature, facadeClass, async = false) {\n      if (!this.featureModules.isConfigured(feature)) {\n        return throwError(new Error(`Feature ${feature} is not configured properly`));\n      }\n      let facadeService$ = this.featureModules.resolveFeature(feature).pipe(map(moduleRef => moduleRef.injector), map(injector => injector.get(facadeClass)));\n      if (async) {\n        facadeService$ = facadeService$.pipe(delay(0));\n      }\n      return facadeService$.pipe(shareReplay());\n    }\n    /**\n     * Calls a method on a facade\n     *\n     * Method should either return an observable or void. Any other return type\n     * than observable is ignored.\n     *\n     * @param resolver$\n     * @param method\n     * @param args\n     * @protected\n     */\n    call(resolver$, method, args) {\n      const callResult$ = resolver$.pipe(map(service => service[method](...args)), publishReplay());\n      callResult$.connect();\n      return callResult$.pipe(switchMap(result => {\n        if (isObservable(result)) {\n          return result;\n        }\n        return EMPTY;\n      }));\n    }\n    /**\n     * Get the property value from the facade\n     *\n     * Property has to be an aobservable\n     *\n     * @param resolver$\n     * @param property\n     * @protected\n     */\n    get(resolver$, property) {\n      return resolver$.pipe(switchMap(service => service[property]));\n    }\n    create({\n      facade,\n      feature,\n      methods,\n      properties,\n      async\n    }) {\n      const resolver$ = this.getResolver(feature, facade, async);\n      const result = new class extends facade {}();\n      (methods !== null && methods !== void 0 ? methods : []).forEach(method => {\n        result[method] = (...args) => this.call(resolver$, method, args);\n      });\n      (properties !== null && properties !== void 0 ? properties : []).forEach(property => {\n        result[property] = this.get(resolver$, property);\n      });\n      return result;\n    }\n  }\n  FacadeFactoryService.ɵfac = function FacadeFactoryService_Factory(t) {\n    return new (t || FacadeFactoryService)(i0.ɵɵinject(FeatureModulesService), i0.ɵɵinject(i0.Injector));\n  };\n  FacadeFactoryService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FacadeFactoryService,\n    factory: FacadeFactoryService.ɵfac,\n    providedIn: 'root'\n  });\n  return FacadeFactoryService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Factory that will create proxy facade, which is a service that will expose\n * methods and properties from a facade implemented in the lazy loaded module.\n *\n * Returned proxy facade will lazy load the feature and facade implementation\n * at first method call or when first property observable will be subscribed.\n *\n * @param descriptor\n */\nfunction facadeFactory(descriptor) {\n  return inject(FacadeFactoryService).create(descriptor);\n}\nfunction moduleInitializersFactory(lazyModuleService, moduleInitializerFunctions) {\n  const factoryFunction = () => {\n    return Promise.all(lazyModuleService.runModuleInitializerFunctions(moduleInitializerFunctions)).catch(error => {\n      console.error('MODULE_INITIALIZER promise was rejected during app initialization.', error);\n      throw error;\n    });\n  };\n  return factoryFunction;\n}\nlet LazyLoadingModule = /*#__PURE__*/(() => {\n  class LazyLoadingModule {\n    static forRoot() {\n      return {\n        ngModule: LazyLoadingModule,\n        providers: [{\n          provide: APP_INITIALIZER,\n          useFactory: moduleInitializersFactory,\n          deps: [LazyModulesService, [new Optional(), MODULE_INITIALIZER]],\n          multi: true\n        }]\n      };\n    }\n  }\n  LazyLoadingModule.ɵfac = function LazyLoadingModule_Factory(t) {\n    return new (t || LazyLoadingModule)();\n  };\n  LazyLoadingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LazyLoadingModule\n  });\n  LazyLoadingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LazyLoadingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseCoreModule = /*#__PURE__*/(() => {\n  class BaseCoreModule {\n    static forRoot() {\n      return {\n        ngModule: BaseCoreModule\n      };\n    }\n  }\n  BaseCoreModule.ɵfac = function BaseCoreModule_Factory(t) {\n    return new (t || BaseCoreModule)();\n  };\n  BaseCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BaseCoreModule\n  });\n  BaseCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[StateModule.forRoot(), ConfigModule.forRoot(), ConfigInitializerModule.forRoot(), ConfigValidatorModule.forRoot(), I18nModule.forRoot(), CmsModule.forRoot(), GlobalMessageModule.forRoot(), ProcessModule.forRoot(), FeaturesConfigModule.forRoot(), SiteContextModule.forRoot(), MetaTagConfigModule.forRoot(), BaseOccModule.forRoot(), LazyLoadingModule.forRoot()]]\n  });\n  return BaseCoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of core\n */\n/** AUGMENTABLE_TYPES_END */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ADDRESS_LIST_NORMALIZER, ADDRESS_NORMALIZER, ADDRESS_SERIALIZER, ADDRESS_VALIDATION_NORMALIZER, ADD_PRODUCT_INTEREST_PROCESS_ID, ADD_VOUCHER_PROCESS_ID, ANONYMOUS_CONSENTS, ANONYMOUS_CONSENTS_HEADER, ANONYMOUS_CONSENTS_STORE_FEATURE, ANONYMOUS_CONSENT_NORMALIZER, ANONYMOUS_CONSENT_STATUS, ActivatedRoutesService, ActiveCartService, AddUserAddressEvent, AnonymousConsentNormalizer, AnonymousConsentTemplatesAdapter, AnonymousConsentTemplatesConnector, anonymousConsentsGroup as AnonymousConsentsActions, AnonymousConsentsConfig, AnonymousConsentsInterceptor, AnonymousConsentsModule, anonymousConsentsGroup_selectors as AnonymousConsentsSelectors, AnonymousConsentsService, AnonymousConsentsStatePersistenceService, authGroup_actions as AuthActions, AuthConfig, AuthConfigService, AuthFlowRoutesService, AuthGuard, AuthHttpHeaderService, AuthInterceptor, AuthModule, AuthRedirectService, AuthRedirectStorageService, AuthService, AuthStatePersistenceService, AuthStorageService, B2BPaymentTypeEnum, B2BUserRole, BASE_SITE_CONTEXT_ID, BASE_SITE_NORMALIZER, BadGatewayHandler, BadRequestHandler, BaseCoreModule, BaseOccModule, BasePageMetaResolver, BaseSiteInitializer, BaseSiteNormalizer, BaseSiteService, CANCEL_ORDER_PROCESS_ID, CANCEL_REPLENISHMENT_ORDER_PROCESS_ID, CANCEL_RETURN_PROCESS_ID, CART_MODIFICATION_NORMALIZER, CART_NORMALIZER, CART_VALIDATION_NORMALIZER, CART_VOUCHER_NORMALIZER, CLAIM_CUSTOMER_COUPON_PROCESS_ID, CLIENT_AUTH_FEATURE, CLIENT_TOKEN_DATA, CMS_COMPONENT_NORMALIZER, CMS_FEATURE, CMS_FLEX_COMPONENT_TYPE, CMS_PAGE_NORMALIZER, COMPONENT_ENTITY, CONFIG_INITIALIZER, CONSENT_TEMPLATE_NORMALIZER, CONSIGNMENT_TRACKING_NORMALIZER, COST_CENTERS_NORMALIZER, COST_CENTER_NORMALIZER, COST_CENTER_SERIALIZER, COUNTRY_NORMALIZER, CURRENCY_CONTEXT_ID, CURRENCY_NORMALIZER, CUSTOMER_COUPONS, CUSTOMER_COUPON_SEARCH_RESULT_NORMALIZER, cartGroup_actions as CartActions, CartAdapter, CartAddEntryEvent, CartAddEntryFailEvent, CartAddEntrySuccessEvent, CartConfig, CartConfigService, CartConnector, CartEntryAdapter, CartEntryConnector, CartEvent, CartEventBuilder, CartEventModule, CartModule, CartOccModule, CartPersistenceModule, CartRemoveEntryFailEvent, CartRemoveEntrySuccessEvent, CartUpdateEntryFailEvent, CartUpdateEntrySuccessEvent, CartValidationAdapter, CartValidationConnector, CartValidationService, CartValidationStatusCode, CartVoucherAdapter, CartVoucherConnector, CartVoucherService, CategoryPageMetaResolver, clientTokenGroup_actions as ClientAuthActions, ClientAuthModule, clientTokenGroup_selectors as ClientAuthSelectors, ClientAuthenticationTokenService, ClientErrorHandlingService, ClientTokenInterceptor, ClientTokenService, cmsGroup_actions as CmsActions, CmsBannerCarouselEffect, CmsComponentAdapter, CmsComponentConnector, CmsConfig, CmsModule, CmsOccModule, CmsPageAdapter, CmsPageConnector, cmsGroup_selectors as CmsSelectors, CmsService, CmsStructureConfig, CmsStructureConfigService, Command, CommandService, CommandStrategy, ComponentDecorator, Config, ConfigChunk, ConfigInitializerModule, ConfigInitializerService, ConfigModule, ConfigValidatorModule, ConfigValidatorToken, ConfigurableRoutesService, ConfigurationService, ConflictHandler, ConsentService, ContentPageMetaResolver, ContextServiceMap, ConverterService, CostCenterModule, CostCenterOccModule, CountryType, CurrencyInitializer, CurrencyService, CurrencySetEvent, CurrencyStatePersistenceService, CustomerCouponAdapter, CustomerCouponConnector, CustomerCouponService, CxDatePipe, CxEvent, CxNumericPipe, DEFAULT_SCOPE, DEFAULT_URL_MATCHER, DaysOfWeek, DefaultConfig, DefaultConfigChunk, DefaultRoutePageMetaResolver, DeferLoadingStrategy, DeleteUserAddressEvent, DynamicAttributeService, EMAIL_PATTERN, EventService, ExternalRoutesConfig, ExternalRoutesGuard, ExternalRoutesModule, ExternalRoutesService, FacadeFactoryService, FacetChangedEvent, FeatureConfigService, FeatureDirective, FeatureLevelDirective, FeatureModulesService, FeaturesConfig, FeaturesConfigModule, ForbiddenHandler, GIVE_CONSENT_PROCESS_ID, GLOBAL_MESSAGE_FEATURE, GatewayTimeoutHandler, GlobService, globalMessageGroup_actions as GlobalMessageActions, GlobalMessageConfig, GlobalMessageModule, globalMessageGroup_selectors as GlobalMessageSelectors, GlobalMessageService, GlobalMessageType, HOME_PAGE_CONTEXT, HttpErrorHandler, HttpErrorModel, HttpParamsURIEncoder, HttpResponseStatus, I18nConfig, I18nConfigInitializer, I18nModule, I18nTestingModule, I18nextTranslationService, ImageType, InterceptorUtil, InternalServerErrorHandler, JSP_INCLUDE_CMS_COMPONENT_TYPE, JavaRegExpConverter, LANGUAGE_CONTEXT_ID, LANGUAGE_NORMALIZER, LanguageInitializer, LanguageService, LanguageSetEvent, LanguageStatePersistenceService, LazyModulesService, LegacyOccCmsComponentAdapter, LoadingScopesService, LoginEvent, LogoutEvent, MEDIA_BASE_URL_META_TAG_NAME, MEDIA_BASE_URL_META_TAG_PLACEHOLDER, MODULE_INITIALIZER, MULTI_CART_DATA, MULTI_CART_FEATURE, MetaTagConfigModule, MockDatePipe, MockTranslatePipe, ModuleInitializedEvent, multiCartGroup_selectors as MultiCartSelectors, MultiCartService, MultiCartStatePersistenceService, NAVIGATION_DETAIL_ENTITY, NOTIFICATION_PREFERENCES, NotAuthGuard, NotFoundHandler, NotificationType, OAuthFlow, OAuthLibWrapperService, OCC_BASE_URL_META_TAG_NAME, OCC_BASE_URL_META_TAG_PLACEHOLDER, OCC_CART_ID_CURRENT, OCC_USER_ID_ANONYMOUS, OCC_USER_ID_CURRENT, OCC_USER_ID_GUEST, ORDER_HISTORY_NORMALIZER, ORDER_NORMALIZER, ORDER_RETURNS_NORMALIZER, ORDER_RETURN_REQUEST_INPUT_SERIALIZER, ORDER_RETURN_REQUEST_NORMALIZER, ORDER_TYPE, Occ, OccAnonymousConsentTemplatesAdapter, OccCartAdapter, OccCartEntryAdapter, OccCartNormalizer, OccCartValidationAdapter, OccCartVoucherAdapter, OccCmsComponentAdapter, OccCmsPageAdapter, OccCmsPageNormalizer, OccConfig, OccCostCenterListNormalizer, OccCostCenterNormalizer, OccCostCenterSerializer, OccCustomerCouponAdapter, OccEndpointsService, OccFieldsService, OccOrderNormalizer, OccProductAdapter, OccProductReferencesAdapter, OccProductReferencesListNormalizer, OccProductReviewsAdapter, OccProductSearchAdapter, OccProductSearchPageNormalizer, OccReplenishmentOrderNormalizer, OccRequestsOptimizerService, OccReturnRequestNormalizer, OccSiteAdapter, OccUserAddressAdapter, OccUserConsentAdapter, OccUserInterestsAdapter, OccUserInterestsNormalizer, OccUserNotificationPreferenceAdapter, OccUserOrderAdapter, OccUserPaymentAdapter, OccUserReplenishmentOrderAdapter, OrderEntryPromotionsService, OrderOccModule, OrderReturnRequestService, PASSWORD_PATTERN, PAYMENT_DETAILS_NORMALIZER, POINT_OF_SERVICE_NORMALIZER, PROCESS_FEATURE, PRODUCT_DETAIL_ENTITY, PRODUCT_FEATURE, PRODUCT_INTERESTS, PRODUCT_INTERESTS_NORMALIZER, PRODUCT_NORMALIZER, PRODUCT_REFERENCES_NORMALIZER, PRODUCT_REVIEW_NORMALIZER, PRODUCT_REVIEW_SERIALIZER, PRODUCT_SEARCH_PAGE_NORMALIZER, PRODUCT_SUGGESTION_NORMALIZER, PageContext, PageLinkService, PageMetaConfig, PageMetaModule, PageMetaResolver, PageMetaService, PageRobotsMeta, PageType, PriceType, ProcessModule, process_selectors as ProcessSelectors, productGroup_actions as ProductActions, ProductAdapter, ProductConnector, ProductEventBuilder, ProductEventModule, ProductImageNormalizer, ProductLoadingService, ProductModule, ProductNameNormalizer, ProductOccModule, ProductPageMetaResolver, ProductReferenceNormalizer, ProductReferenceService, ProductReferencesAdapter, ProductReferencesConnector, ProductReviewService, ProductReviewsAdapter, ProductReviewsConnector, ProductSearchAdapter, ProductSearchConnector, ProductSearchService, productGroup_selectors as ProductSelectors, ProductService, ProductURLPipe, PromotionLocation, ProtectedRoutesGuard, ProtectedRoutesService, QueryService, REGIONS, REGION_NORMALIZER, REGISTER_USER_PROCESS_ID, REMOVE_PRODUCT_INTERESTS_PROCESS_ID, REPLENISHMENT_ORDER_HISTORY_NORMALIZER, REPLENISHMENT_ORDER_NORMALIZER, ROUTING_FEATURE, RootConfig, routingGroup_actions as RoutingActions, RoutingConfig, RoutingConfigService, RoutingModule, RoutingPageMetaResolver, RoutingParamsService, routingGroup_selectors as RoutingSelector, RoutingService, SAVE_CART_NORMALIZER, SERVER_REQUEST_ORIGIN, SERVER_REQUEST_URL, SITE_CONTEXT_FEATURE, SMART_EDIT_CONTEXT, SUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, SaveCartAdapter, SaveCartConnector, ScriptLoader, ScriptPlacement, SearchPageMetaResolver, SearchboxService, SelectiveCartService, SemanticPathService, SiteAdapter, SiteConnector, siteContextGroup_actions as SiteContextActions, SiteContextConfig, SiteContextConfigInitializer, SiteContextEventBuilder, SiteContextEventModule, SiteContextInterceptor, SiteContextModule, SiteContextOccModule, SiteContextParamsService, siteContextGroup_selectors as SiteContextSelectors, SiteContextUrlSerializer, SlotDecorator, StateConfig, StateEventService, StateModule, StatePersistenceService, StateTransferType, utilsGroup as StateUtils, StorageSyncType, StringTemplate, THEME_CONTEXT_ID, TestConfigModule, TimeUtils, TokenRevocationInterceptor, TranslatePipe, TranslationChunkService, TranslationService, UNSUBSCRIBE_CUSTOMER_COUPON_PROCESS_ID, UPDATE_NOTIFICATION_PREFERENCES_PROCESS_ID, USER_ADDRESSES, USER_CONSENTS, USER_COST_CENTERS, USER_FEATURE, USER_ORDERS, USER_ORDER_DETAILS, USER_PAYMENT_METHODS, USER_REPLENISHMENT_ORDERS, USER_REPLENISHMENT_ORDER_DETAILS, USER_RETURN_REQUESTS, USER_RETURN_REQUEST_DETAILS, USE_CLIENT_TOKEN, USE_CUSTOMER_SUPPORT_AGENT_TOKEN, UnifiedInjector, UnknownErrorHandler, UpdateUserAddressEvent, UrlMatcherService, UrlModule, UrlParsingService, UrlPipe, UserAccountFacadeTransitionalToken, userGroup_actions as UserActions, UserAddressAdapter, UserAddressConnector, UserAddressEvent, UserAddressService, UserAuthEventBuilder, UserAuthEventModule, UserAuthModule, UserConsentAdapter, UserConsentConnector, UserConsentService, UserCostCenterAdapter, UserCostCenterConnector, UserCostCenterService, UserEventBuilder, UserEventModule, UserIdService, UserInterestsAdapter, UserInterestsConnector, UserInterestsService, UserNotificationPreferenceService, UserOccModule, UserOccTransitionalModule, UserOccTransitional_4_2_Module, UserOrderAdapter, UserOrderConnector, UserOrderService, UserPaymentAdapter, UserPaymentConnector, UserPaymentService, UserProfileFacadeTransitionalToken, UserReplenishmentOrderAdapter, UserReplenishmentOrderConnector, UserReplenishmentOrderService, UserService, UserTransitionalModule, UserTransitional_4_2_Module, usersGroup_selectors as UsersSelectors, VariantQualifier, VariantType, WITHDRAW_CONSENT_PROCESS_ID, WindowRef, WishListService, WithCredentialsInterceptor, configInitializerFactory, configValidatorFactory, contextServiceMapProvider, createFrom, deepMerge, defaultAnonymousConsentsConfig, defaultCmsModuleConfig, defaultOccConfig, defaultPageMetaConfig, errorHandlers, facadeFactory, getCartIdByUserId, getContextParameterDefault, getContextParameterValues, getLastValueSync, getWishlistName, httpErrorInterceptors, initConfigurableRoutes, isCartNotFoundError, isFeatureEnabled, isFeatureLevel, isNotNullable, isNotUndefined, isObject, isSelectiveCart, isTempCartId, locationInitializedFactory, mediaServerConfigFromMetaTagFactory, normalizeHttpError, occConfigValidator, occServerConfigFromMetaTagFactory, provideConfig, provideConfigFactory, provideConfigFromMetaTags, provideConfigValidator, provideDefaultConfig, provideDefaultConfigFactory, recurrencePeriod, resolveApplicable, serviceMapFactory, uniteLatest, urlPathJoin, validateConfig, withdrawOn };\n//# sourceMappingURL=spartacus-core.js.map","map":null,"metadata":{},"sourceType":"module"}