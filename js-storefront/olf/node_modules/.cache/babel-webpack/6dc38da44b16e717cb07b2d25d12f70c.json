{"ast":null,"code":"import { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, NgModule } from '@angular/core';\nimport * as i1$1 from '@spartacus/core';\nimport { StateUtils, normalizeHttpError, StateModule, provideDefaultConfig, MODULE_INITIALIZER, OccConfig, Config } from '@spartacus/core';\nimport * as i1$2 from '@ngrx/store';\nimport { createFeatureSelector, createSelector, select, StoreModule } from '@ngrx/store';\nimport { of, Subscription, combineLatest } from 'rxjs';\nimport { map, switchMap, catchError, filter } from 'rxjs/operators';\nimport { __decorate } from 'tslib';\nimport * as i1 from '@ngrx/effects';\nimport { ofType, Effect, EffectsModule } from '@ngrx/effects';\nimport * as i3 from '@spartacus/asm/root';\nconst defaultAsmConfig = {\n  asm: {\n    agentSessionTimer: {\n      startingDelayInSeconds: 600\n    },\n    customerSearch: {\n      maxResults: 20\n    }\n  }\n};\nclass AsmAdapter {}\nlet AsmConnector = /*#__PURE__*/(() => {\n  class AsmConnector {\n    constructor(asmAdapter) {\n      this.asmAdapter = asmAdapter;\n    }\n    customerSearch(options) {\n      return this.asmAdapter.customerSearch(options);\n    }\n  }\n  AsmConnector.ɵfac = function AsmConnector_Factory(t) {\n    return new (t || AsmConnector)(i0.ɵɵinject(AsmAdapter));\n  };\n  AsmConnector.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmConnector,\n    factory: AsmConnector.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmConnector;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ASM_UI_UPDATE = '[Asm] UI Update';\nclass AsmUiUpdate {\n  constructor(payload) {\n    this.payload = payload;\n    this.type = ASM_UI_UPDATE;\n  }\n}\nconst ASM_FEATURE = 'asm';\nconst CUSTOMER_SEARCH_DATA = '[asm] Customer search data';\nconst CUSTOMER_SEARCH = '[Asm] Customer Search';\nconst CUSTOMER_SEARCH_FAIL = '[Asm] Customer Search Fail';\nconst CUSTOMER_SEARCH_SUCCESS = '[Asm] Customer Search Success';\nconst CUSTOMER_SEARCH_RESET = '[Asm] Customer Search Reset';\nclass CustomerSearch extends StateUtils.LoaderLoadAction {\n  constructor(payload) {\n    super(CUSTOMER_SEARCH_DATA);\n    this.payload = payload;\n    this.type = CUSTOMER_SEARCH;\n  }\n}\nclass CustomerSearchFail extends StateUtils.LoaderFailAction {\n  constructor(payload) {\n    super(CUSTOMER_SEARCH_DATA);\n    this.payload = payload;\n    this.type = CUSTOMER_SEARCH_FAIL;\n  }\n}\nclass CustomerSearchSuccess extends StateUtils.LoaderSuccessAction {\n  constructor(payload) {\n    super(CUSTOMER_SEARCH_DATA);\n    this.payload = payload;\n    this.type = CUSTOMER_SEARCH_SUCCESS;\n  }\n}\nclass CustomerSearchReset extends StateUtils.LoaderResetAction {\n  constructor() {\n    super(CUSTOMER_SEARCH_DATA);\n    this.type = CUSTOMER_SEARCH_RESET;\n  }\n}\nconst LOGOUT_CUSTOMER_SUPPORT_AGENT = '[Auth] Logout Customer Support Agent';\n/**\n * Action dispatched after customer support agent logout. Used to clear store data (ui, search results)\n */\nclass LogoutCustomerSupportAgent {\n  constructor() {\n    this.type = LOGOUT_CUSTOMER_SUPPORT_AGENT;\n  }\n}\nvar customerGroup_actions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ASM_UI_UPDATE: ASM_UI_UPDATE,\n  AsmUiUpdate: AsmUiUpdate,\n  CUSTOMER_SEARCH: CUSTOMER_SEARCH,\n  CUSTOMER_SEARCH_FAIL: CUSTOMER_SEARCH_FAIL,\n  CUSTOMER_SEARCH_SUCCESS: CUSTOMER_SEARCH_SUCCESS,\n  CUSTOMER_SEARCH_RESET: CUSTOMER_SEARCH_RESET,\n  CustomerSearch: CustomerSearch,\n  CustomerSearchFail: CustomerSearchFail,\n  CustomerSearchSuccess: CustomerSearchSuccess,\n  CustomerSearchReset: CustomerSearchReset,\n  LOGOUT_CUSTOMER_SUPPORT_AGENT: LOGOUT_CUSTOMER_SUPPORT_AGENT,\n  LogoutCustomerSupportAgent: LogoutCustomerSupportAgent\n});\nlet CustomerEffects = /*#__PURE__*/(() => {\n  class CustomerEffects {\n    constructor(actions$, asmConnector) {\n      this.actions$ = actions$;\n      this.asmConnector = asmConnector;\n      this.customerSearch$ = this.actions$.pipe(ofType(CUSTOMER_SEARCH), map(action => action.payload), switchMap(options => this.asmConnector.customerSearch(options).pipe(map(customerSearchResults => {\n        return new CustomerSearchSuccess(customerSearchResults);\n      }), catchError(error => of(new CustomerSearchFail(normalizeHttpError(error)))))));\n    }\n  }\n  CustomerEffects.ɵfac = function CustomerEffects_Factory(t) {\n    return new (t || CustomerEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(AsmConnector));\n  };\n  CustomerEffects.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CustomerEffects,\n    factory: CustomerEffects.ɵfac\n  });\n  __decorate([Effect()], CustomerEffects.prototype, \"customerSearch$\", void 0);\n  return CustomerEffects;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst effects = [CustomerEffects];\nconst initialState = {\n  collapsed: false\n};\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case ASM_UI_UPDATE:\n      {\n        return Object.assign(Object.assign({}, state), action.payload);\n      }\n    default:\n      {\n        return state;\n      }\n  }\n}\nfunction getReducers() {\n  return {\n    customerSearchResult: StateUtils.loaderReducer(CUSTOMER_SEARCH_DATA),\n    asmUi: reducer\n  };\n}\nconst reducerToken = new InjectionToken('AsmReducers');\nconst reducerProvider = {\n  provide: reducerToken,\n  useFactory: getReducers\n};\nfunction clearCustomerSupportAgentAsmState(reducer) {\n  return function (state, action) {\n    if (action.type === LOGOUT_CUSTOMER_SUPPORT_AGENT) {\n      state = Object.assign(Object.assign({}, state), {\n        customerSearchResult: {}\n      });\n    }\n    return reducer(state, action);\n  };\n}\nconst metaReducers = [clearCustomerSupportAgentAsmState];\nconst getAsmState = createFeatureSelector(ASM_FEATURE);\nconst getAsmUi = createSelector(getAsmState, state => state.asmUi);\nconst getCustomerSearchResultsLoaderState = createSelector(getAsmState, state => state.customerSearchResult);\nconst getCustomerSearchResults = createSelector(getCustomerSearchResultsLoaderState, state => StateUtils.loaderValueSelector(state));\nconst getCustomerSearchResultsLoading = createSelector(getCustomerSearchResultsLoaderState, state => StateUtils.loaderLoadingSelector(state));\nvar asmGroup_selectors = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getAsmUi: getAsmUi,\n  getCustomerSearchResultsLoaderState: getCustomerSearchResultsLoaderState,\n  getCustomerSearchResults: getCustomerSearchResults,\n  getCustomerSearchResultsLoading: getCustomerSearchResultsLoading,\n  getAsmState: getAsmState\n});\n\n/**\n * Responsible for storing ASM state in the browser storage.\n * Uses `StatePersistenceService` mechanism.\n */\nlet AsmStatePersistenceService = /*#__PURE__*/(() => {\n  class AsmStatePersistenceService {\n    constructor(statePersistenceService, store, authStorageService) {\n      this.statePersistenceService = statePersistenceService;\n      this.store = store;\n      this.authStorageService = authStorageService;\n      this.subscription = new Subscription();\n      /**\n       * Identifier used for storage key.\n       */\n      this.key = 'asm';\n    }\n    /**\n     * Initializes the synchronization between state and browser storage.\n     */\n    initSync() {\n      this.subscription.add(this.statePersistenceService.syncWithStorage({\n        key: this.key,\n        state$: this.getAsmState(),\n        onRead: state => this.onRead(state)\n      }));\n    }\n    /**\n     * Gets and transforms state from different sources into the form that should\n     * be saved in storage.\n     */\n    getAsmState() {\n      return combineLatest([this.store.pipe(\n      // Since getAsmState() may be called while the module is lazy loded\n      // The asm state slice may not exist yet in the first store emissions.\n      filter(store => !!store.asm), select(getAsmUi)), of(this.authStorageService.getEmulatedUserToken()), this.authStorageService.getTokenTarget()]).pipe(map(([ui, emulatedUserToken, tokenTarget]) => {\n        let emulatedToken = emulatedUserToken;\n        if (emulatedToken) {\n          emulatedToken = Object.assign({}, emulatedUserToken);\n          // To minimize risk of user account hijacking we don't persist emulated user refresh_token\n          delete emulatedToken.refresh_token;\n        }\n        return {\n          ui,\n          emulatedUserToken: emulatedToken,\n          tokenTarget\n        };\n      }));\n    }\n    /**\n     * Function called on each browser storage read.\n     * Used to update state from browser -> state.\n     */\n    onRead(state) {\n      if (state) {\n        if (state.ui) {\n          this.store.dispatch(new AsmUiUpdate(state.ui));\n        }\n        if (state.emulatedUserToken) {\n          this.authStorageService.setEmulatedUserToken(state.emulatedUserToken);\n        }\n        if (state.tokenTarget) {\n          this.authStorageService.setTokenTarget(state.tokenTarget);\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  AsmStatePersistenceService.ɵfac = function AsmStatePersistenceService_Factory(t) {\n    return new (t || AsmStatePersistenceService)(i0.ɵɵinject(i1$1.StatePersistenceService), i0.ɵɵinject(i1$2.Store), i0.ɵɵinject(i3.AsmAuthStorageService));\n  };\n  AsmStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmStatePersistenceService,\n    factory: AsmStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AsmStoreModule = /*#__PURE__*/(() => {\n  class AsmStoreModule {}\n  AsmStoreModule.ɵfac = function AsmStoreModule_Factory(t) {\n    return new (t || AsmStoreModule)();\n  };\n  AsmStoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AsmStoreModule\n  });\n  AsmStoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [reducerProvider],\n    imports: [[CommonModule, StateModule, StoreModule.forFeature(ASM_FEATURE, reducerToken, {\n      metaReducers\n    }), EffectsModule.forFeature(effects)]]\n  });\n  return AsmStoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction asmStatePersistenceFactory(asmStatePersistenceService) {\n  const result = () => asmStatePersistenceService.initSync();\n  return result;\n}\nlet AsmCoreModule = /*#__PURE__*/(() => {\n  class AsmCoreModule {}\n  AsmCoreModule.ɵfac = function AsmCoreModule_Factory(t) {\n    return new (t || AsmCoreModule)();\n  };\n  AsmCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AsmCoreModule\n  });\n  AsmCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideDefaultConfig(defaultAsmConfig), AsmConnector, {\n      provide: MODULE_INITIALIZER,\n      useFactory: asmStatePersistenceFactory,\n      deps: [AsmStatePersistenceService],\n      multi: true\n    }],\n    imports: [[CommonModule, AsmStoreModule]]\n  });\n  return AsmCoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AsmConfig = /*#__PURE__*/(() => {\n  class AsmConfig extends OccConfig {}\n  AsmConfig.ɵfac = /* @__PURE__ */function () {\n    let ɵAsmConfig_BaseFactory;\n    return function AsmConfig_Factory(t) {\n      return (ɵAsmConfig_BaseFactory || (ɵAsmConfig_BaseFactory = i0.ɵɵgetInheritedFactory(AsmConfig)))(t || AsmConfig);\n    };\n  }();\n  AsmConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmConfig,\n    factory: function AsmConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new (t || AsmConfig)();\n      } else {\n        r = i0.ɵɵinject(Config);\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return AsmConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CUSTOMER_SEARCH_PAGE_NORMALIZER = new InjectionToken('CustomerSearchPageNormalizer');\nlet AsmService = /*#__PURE__*/(() => {\n  class AsmService {\n    constructor(store) {\n      this.store = store;\n    }\n    /**\n     * Search for customers\n     * @param options\n     */\n    customerSearch(options) {\n      this.store.dispatch(new CustomerSearch(options));\n    }\n    /**\n     * Reset the customer search result data to the initial state.\n     */\n    customerSearchReset() {\n      this.store.dispatch(new CustomerSearchReset());\n    }\n    /**\n     * Returns the customer search result data.\n     */\n    getCustomerSearchResults() {\n      return this.store.pipe(select(getCustomerSearchResults));\n    }\n    /**\n     * Returns the customer search result loading status.\n     */\n    getCustomerSearchResultsLoading() {\n      return this.store.pipe(select(getCustomerSearchResultsLoading));\n    }\n    /**\n     * Updates the state of the ASM UI\n     */\n    updateAsmUiState(asmUi) {\n      this.store.dispatch(new AsmUiUpdate(asmUi));\n    }\n    /**\n     * Get the state of the ASM UI\n     */\n    getAsmUiState() {\n      return this.store.pipe(select(getAsmUi));\n    }\n  }\n  AsmService.ɵfac = function AsmService_Factory(t) {\n    return new (t || AsmService)(i0.ɵɵinject(i1$2.Store));\n  };\n  AsmService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AsmService,\n    factory: AsmService.ɵfac,\n    providedIn: 'root'\n  });\n  return AsmService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ASM_FEATURE, customerGroup_actions as AsmActions, AsmAdapter, AsmConfig, AsmConnector, AsmCoreModule, asmGroup_selectors as AsmSelectors, AsmService, AsmStatePersistenceService, CUSTOMER_SEARCH_DATA, CUSTOMER_SEARCH_PAGE_NORMALIZER, asmStatePersistenceFactory };\n//# sourceMappingURL=spartacus-asm-core.js.map","map":null,"metadata":{},"sourceType":"module"}