{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, NgModule } from '@angular/core';\nimport * as i1$1 from '@spartacus/cart/quick-order/root';\nimport { defaultQuickOrderConfig, QuickOrderFacade } from '@spartacus/cart/quick-order/root';\nimport * as i1 from '@spartacus/core';\nimport { CartAddEntrySuccessEvent, CartAddEntryFailEvent, HttpErrorModel, BASE_SITE_CONTEXT_ID, StorageSyncType } from '@spartacus/core';\nimport { Subject, BehaviorSubject, of, timer, Subscription } from 'rxjs';\nimport { map, take, first, switchMap, filter, tap } from 'rxjs/operators';\nlet QuickOrderService = /*#__PURE__*/(() => {\n  class QuickOrderService {\n    constructor(activeCartService, productAdapter,\n    // TODO(#14059): Remove this service\n    eventService, productSearchConnector //TODO(#14059): Make it required\n    ) {\n      this.activeCartService = activeCartService;\n      this.productAdapter = productAdapter;\n      this.eventService = eventService;\n      this.productSearchConnector = productSearchConnector;\n      this.productAdded$ = new Subject();\n      this.entries$ = new BehaviorSubject([]);\n      this.softDeletedEntries$ = new BehaviorSubject({});\n      this.nonPurchasableProductError$ = new BehaviorSubject(null);\n      this.hardDeleteTimeout = 5000;\n      this.quickOrderListLimit = 0;\n      this.clearDeleteTimeouts = {};\n    }\n    ngOnDestroy() {\n      this.clearDeletedEntries();\n    }\n    /**\n     * Get entries\n     */\n    getEntries() {\n      return this.entries$;\n    }\n    /**\n     * @deprecated since 4.2 - use searchProducts instead\n     * Search product using SKU\n     */\n    search(productCode) {\n      return this.productAdapter.load(productCode);\n    }\n    /**\n     * Search products using query\n     */\n    searchProducts(query, maxProducts) {\n      var _a, _b;\n      // TODO(#14059): Remove condition\n      if (this.productSearchConnector) {\n        const searchConfig = {\n          pageSize: maxProducts || ((_b = (_a = defaultQuickOrderConfig.quickOrder) === null || _a === void 0 ? void 0 : _a.searchForm) === null || _b === void 0 ? void 0 : _b.maxProducts)\n        };\n        return this.productSearchConnector.search(query, searchConfig).pipe(map(searchPage => searchPage.products || []));\n      } else {\n        return of([]);\n      }\n    }\n    /**\n     * Clear a list of added entries\n     */\n    clearList() {\n      this.entries$.next([]);\n    }\n    /**\n     * Get information about the possibility to add the next product\n     */\n    canAdd(code) {\n      if (code) {\n        return of(this.isProductOnTheList(code) || !this.isLimitExceeded());\n      } else {\n        return of(!this.isLimitExceeded());\n      }\n    }\n    /**\n     * Set quick order list limit property\n     */\n    setListLimit(limit) {\n      this.quickOrderListLimit = limit;\n    }\n    /**\n     * Load a list of entries\n     */\n    loadEntries(entries = []) {\n      this.entries$.next(entries);\n    }\n    /**\n     * Load a list of entries\n     */\n    updateEntryQuantity(entryIndex, quantity) {\n      const entries = this.entries$.getValue() || [];\n      entries[entryIndex].quantity = quantity;\n      this.entries$.next(entries);\n    }\n    /**\n     * Delete single entry from the list\n     */\n    softDeleteEntry(index) {\n      this.entries$.pipe(take(1)).subscribe(entries => {\n        const entriesList = entries;\n        this.addSoftEntryDeletion(entriesList[index], true);\n        entriesList.splice(index, 1);\n        this.entries$.next(entriesList);\n      });\n    }\n    /**\n     * @deprecated since 4.2 - use softDeleteEntry instead\n     */\n    removeEntry(index) {\n      this.softDeleteEntry(index);\n    }\n    /**\n     * Add product to the quick order list\n     */\n    addProduct(product, quantity = 1) {\n      const entry = this.generateOrderEntry(product, quantity);\n      this.addEntry(entry);\n    }\n    /**\n     * Return product added subject\n     */\n    getProductAdded() {\n      return this.productAdded$;\n    }\n    /**\n     * Set product added subject\n     */\n    setProductAdded(productCode) {\n      this.productAdded$.next(productCode);\n    }\n    /**\n     * Adding to cart all products from the list\n     */\n    addToCart() {\n      let entries = [];\n      const events = [];\n      const subscription = this.eventService.get(CartAddEntrySuccessEvent).subscribe(cartEvent => {\n        if (cartEvent.quantityAdded === 0 || !!cartEvent.quantityAdded && cartEvent.quantityAdded < cartEvent.quantity) {\n          events.push(this.createQuickOrderResultEvent(cartEvent));\n        }\n      });\n      subscription.add(this.eventService.get(CartAddEntryFailEvent).subscribe(cartEvent => {\n        events.push(this.createQuickOrderResultEvent(cartEvent));\n      }));\n      return this.getEntries().pipe(first(), switchMap(elements => {\n        entries = elements;\n        this.activeCartService.addEntries(elements);\n        this.clearList();\n        return this.activeCartService.isStable();\n      }), filter(isStable => isStable), map(() => [entries, events]), tap(() => subscription.unsubscribe()));\n    }\n    /**\n     * Return soft deleted entries\n     */\n    getSoftDeletedEntries() {\n      return this.softDeletedEntries$;\n    }\n    /**\n     * Restore soft deleted entry\n     */\n    restoreSoftDeletedEntry(productCode) {\n      const entry = this.getSoftDeletedEntry(productCode);\n      this.addEntry(entry);\n      this.hardDeleteEntry(productCode);\n    }\n    /**\n     * Clear deleted entry from the list\n     */\n    hardDeleteEntry(productCode) {\n      const entry = this.getSoftDeletedEntry(productCode);\n      const deletedEntries = this.softDeletedEntries$.getValue();\n      if (entry) {\n        delete deletedEntries[productCode];\n        this.softDeletedEntries$.next(deletedEntries);\n      }\n      this.clearDeleteTimeout(productCode);\n    }\n    /**\n     * Clear all deleted entries and timeout subscriptions\n     */\n    clearDeletedEntries() {\n      Object.values(this.clearDeleteTimeouts).forEach(subscription => subscription.unsubscribe());\n      this.softDeletedEntries$.next({});\n      this.clearDeleteTimeouts = {};\n    }\n    /**\n     *  Return non purchasable product error\n     */\n    getNonPurchasableProductError() {\n      return this.nonPurchasableProductError$;\n    }\n    /**\n     * Set error that selected product is not purchasable\n     */\n    setNonPurchasableProductError(product) {\n      this.nonPurchasableProductError$.next(product);\n    }\n    /**\n     * Clear not purchasable product error\n     */\n    clearNonPurchasableProductError() {\n      this.nonPurchasableProductError$.next(null);\n    }\n    /**\n     * Add soft deleted entry to the cached list\n     */\n    addSoftEntryDeletion(entry, clearTimeout = true) {\n      var _a;\n      const deletedEntries = this.softDeletedEntries$.getValue();\n      const productCode = (_a = entry === null || entry === void 0 ? void 0 : entry.product) === null || _a === void 0 ? void 0 : _a.code;\n      if (productCode) {\n        deletedEntries[productCode] = entry;\n        this.softDeletedEntries$.next(deletedEntries);\n        if (clearTimeout) {\n          const subscription = timer(this.hardDeleteTimeout).subscribe(() => {\n            this.hardDeleteEntry(productCode);\n          });\n          this.clearDeleteTimeouts[productCode] = subscription;\n        }\n      }\n    }\n    /**\n     * Get soft deletion entry\n     */\n    getSoftDeletedEntry(productCode) {\n      const deletedEntries = this.softDeletedEntries$.getValue();\n      return deletedEntries[productCode];\n    }\n    /**\n     * Generate Order Entry from Product\n     */\n    generateOrderEntry(product, quantity) {\n      return {\n        basePrice: product.price,\n        product,\n        quantity,\n        totalPrice: product.price\n      };\n    }\n    /**\n     * Add single entry to the list\n     */\n    addEntry(entry) {\n      var _a, _b, _c, _d, _e;\n      if (((_a = entry === null || entry === void 0 ? void 0 : entry.product) === null || _a === void 0 ? void 0 : _a.code) && !this.isProductOnTheList(entry.product.code) && this.isLimitExceeded()) {\n        return;\n      }\n      const entries = this.entries$.getValue() || [];\n      const entryStockLevel = (_c = (_b = entry.product) === null || _b === void 0 ? void 0 : _b.stock) === null || _c === void 0 ? void 0 : _c.stockLevel;\n      if (entryStockLevel && entry.quantity && entry.quantity > entryStockLevel) {\n        entry.quantity = entryStockLevel;\n      }\n      if (((_d = entry.product) === null || _d === void 0 ? void 0 : _d.code) && this.isProductOnTheList(entry.product.code)) {\n        const entryIndex = entries.findIndex(item => {\n          var _a, _b;\n          return ((_a = item.product) === null || _a === void 0 ? void 0 : _a.code) === ((_b = entry.product) === null || _b === void 0 ? void 0 : _b.code);\n        });\n        let quantity = entries[entryIndex].quantity;\n        if (quantity && entry.quantity) {\n          entries[entryIndex].quantity = quantity + (entry === null || entry === void 0 ? void 0 : entry.quantity);\n          let newQuantity = entries[entryIndex].quantity;\n          if (newQuantity && entryStockLevel && newQuantity > entryStockLevel) {\n            entries[entryIndex].quantity = entryStockLevel;\n          }\n          this.entries$.next([...entries]);\n        }\n      } else {\n        this.entries$.next([...entries, ...[entry]]);\n      }\n      this.productAdded$.next((_e = entry.product) === null || _e === void 0 ? void 0 : _e.code);\n    }\n    /**\n     * Verify if product is already on the list\n     */\n    isProductOnTheList(productCode) {\n      const entries = this.entries$.getValue() || [];\n      return !!entries.find(item => {\n        var _a;\n        return ((_a = item.product) === null || _a === void 0 ? void 0 : _a.code) === productCode;\n      });\n    }\n    isLimitExceeded() {\n      const entries = this.entries$.getValue() || [];\n      return entries.length >= this.quickOrderListLimit;\n    }\n    createQuickOrderResultEvent(cartEvent) {\n      var _a, _b, _c;\n      const evt = {\n        productCode: cartEvent.productCode,\n        quantity: cartEvent.quantity\n      };\n      if ('entry' in cartEvent) {\n        evt.entry = cartEvent.entry;\n      }\n      if ('quantityAdded' in cartEvent) {\n        evt.quantityAdded = cartEvent.quantityAdded;\n      }\n      if ('error' in cartEvent && cartEvent.error instanceof HttpErrorModel) {\n        evt.error = cartEvent.error;\n      }\n      if ((_b = (_a = evt.error) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.length) {\n        const isOutOfStock = (_c = evt.error) === null || _c === void 0 ? void 0 : _c.details.some(e => e.type === 'InsufficientStockError');\n        evt.quantityAdded = isOutOfStock ? 0 : evt.quantity;\n      }\n      return evt;\n    }\n    clearDeleteTimeout(productCode) {\n      const clearMessageTimout = this.clearDeleteTimeouts[productCode];\n      if (clearMessageTimout) {\n        clearMessageTimout.unsubscribe();\n        delete this.clearDeleteTimeouts[productCode];\n      }\n    }\n  }\n  QuickOrderService.ɵfac = function QuickOrderService_Factory(t) {\n    return new (t || QuickOrderService)(i0.ɵɵinject(i1.ActiveCartService), i0.ɵɵinject(i1.ProductAdapter), i0.ɵɵinject(i1.EventService), i0.ɵɵinject(i1.ProductSearchConnector));\n  };\n  QuickOrderService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: QuickOrderService,\n    factory: QuickOrderService.ɵfac\n  });\n  return QuickOrderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst facadeProviders = [QuickOrderService, {\n  provide: QuickOrderFacade,\n  useExisting: QuickOrderService\n}];\nlet QuickOrderStatePersistenceService = /*#__PURE__*/(() => {\n  class QuickOrderStatePersistenceService {\n    constructor(quickOrderService, siteContextParamsService, statePersistenceService) {\n      this.quickOrderService = quickOrderService;\n      this.siteContextParamsService = siteContextParamsService;\n      this.statePersistenceService = statePersistenceService;\n      this.subscription = new Subscription();\n      /**\n       * Identifier used for storage key.\n       */\n      this.key = 'quick-order';\n    }\n    /**\n     * Initializes the synchronization between state and browser storage.\n     */\n    initSync() {\n      this.subscription.add(this.statePersistenceService.syncWithStorage({\n        key: this.key,\n        state$: this.quickOrderService.getEntries(),\n        context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]),\n        storageType: StorageSyncType.SESSION_STORAGE,\n        onRead: state => this.onRead(state)\n      }));\n    }\n    onRead(state) {\n      if (state) {\n        this.quickOrderService.loadEntries(state);\n      }\n    }\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n  }\n  QuickOrderStatePersistenceService.ɵfac = function QuickOrderStatePersistenceService_Factory(t) {\n    return new (t || QuickOrderStatePersistenceService)(i0.ɵɵinject(i1$1.QuickOrderFacade), i0.ɵɵinject(i1.SiteContextParamsService), i0.ɵɵinject(i1.StatePersistenceService));\n  };\n  QuickOrderStatePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: QuickOrderStatePersistenceService,\n    factory: QuickOrderStatePersistenceService.ɵfac,\n    providedIn: 'root'\n  });\n  return QuickOrderStatePersistenceService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet QuickOrderCoreModule = /*#__PURE__*/(() => {\n  class QuickOrderCoreModule {\n    static forRoot() {\n      return {\n        ngModule: QuickOrderCoreModule\n      };\n    }\n  }\n  QuickOrderCoreModule.ɵfac = function QuickOrderCoreModule_Factory(t) {\n    return new (t || QuickOrderCoreModule)();\n  };\n  QuickOrderCoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: QuickOrderCoreModule\n  });\n  QuickOrderCoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [...facadeProviders, QuickOrderStatePersistenceService]\n  });\n  return QuickOrderCoreModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { QuickOrderCoreModule, QuickOrderService, QuickOrderStatePersistenceService };\n//# sourceMappingURL=spartacus-cart-quick-order-core.js.map","map":null,"metadata":{},"sourceType":"module"}